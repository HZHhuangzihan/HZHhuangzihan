<!DOCTYPE html><html lang="zh-CN" class="loading"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><title>运算符 - 黄子涵</title><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="google" content="notranslate"><meta name="keywords" content="黄子涵,"><meta name="description" content="运算符
运算符用于连接值。

算术运算符四则运算
在Java中，使用算术运算符+、一、*、/表示加、减、乘、除运算。当参与/运算的两个操作数都是整数时，表示整数除法；否则，表示浮点除法。整数的求余操,"><meta name="author" content="黄子涵"><link rel="alternative" href="atom.xml" title="黄子涵" type="application/atom+xml"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="/css/diaspora.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><meta name="generator" content="Hexo 5.4.0"><link rel="stylesheet" href="/css/prism-atom-dark.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script>
<script src="/js/prism-line-numbers.min.js"></script></head><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><body class="loading"><span id="config-title" style="display:none">黄子涵</span><div id="loader"></div><div id="single"><div id="top" style="display:block"><div class="bar" style="width:0"></div><a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://www.huangzihan.top"></a><div title="播放/暂停" class="iconfont icon-play"></div><h3 class="subtitle">运算符</h3><div class="social"><div><div class="share"><a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a></div><div id="qr"></div></div></div><div class="scrollbar"></div></div><div class="section"><div class="article"><div class="main"><h1 class="title">运算符</h1><div class="stuff"><span>七月 03, 2021</span><ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/Math%E7%B1%BB/" rel="tag">Math类</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/floorMod%E6%96%B9%E6%B3%95/" rel="tag">floorMod方法</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/sqrt%E6%96%B9%E6%B3%95/" rel="tag">sqrt方法</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E4%B8%89%E5%85%83%E6%93%8D%E4%BD%9C%E7%AC%A6/" rel="tag">三元操作符</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" rel="tag">强制类型转换</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E6%8E%A9%E7%A0%81%E6%8A%80%E6%9C%AF/" rel="tag">掩码技术</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E8%BF%90%E7%AE%97%E7%AC%A6/" rel="tag">运算符</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/" rel="tag">静态方法</a></li></ul></div><div class="content markdown"><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><blockquote><p>运算符用于连接值。</p></blockquote><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><h3 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h3><blockquote><p>在Java中，使用算术运算符+、一、*、/表示加、减、乘、除运算。当参与/运算的两个操作数都是整数时，表示整数除法；否则，表示浮点除法。整数的求余操作（有时称为取模）用%表示。例如，15/2等于7，15%2等于1，15.0/2等于7.5。需要注意，整数被0除将会产生一个异常，而浮点数被0除将会得到无穷大或NaN结果。</p></blockquote><h4 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">public class HuangZiHanTest
&#123;  
   public static void main(String[] args)
   &#123;
		System.out.println(15&#x2F;2);
		System.out.println(15%2);
		System.out.println(15.0&#x2F;2);
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">7
1
7.5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><span id="more"></span><h3 id="整数除0"><a href="#整数除0" class="headerlink" title="整数除0"></a>整数除0</h3><h4 id="程序示例-1"><a href="#程序示例-1" class="headerlink" title="程序示例"></a>程序示例</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">public class HuangZiHanTest
&#123;  
   public static void main(String[] args)
   &#123;
		System.out.println(1&#x2F;0);
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">Exception in thread &quot;main&quot; java.lang.ArithmeticException: &#x2F; by zero
	at HuangZiHanTest.main(HuangZiHanTest.java:8)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="浮点数被0除"><a href="#浮点数被0除" class="headerlink" title="浮点数被0除"></a>浮点数被0除</h3><h4 id="程序示例-2"><a href="#程序示例-2" class="headerlink" title="程序示例"></a>程序示例</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">public class HuangZiHanTest
&#123;  
   public static void main(String[] args)
   &#123;
		System.out.println(1.0&#x2F;0);
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行结果-2"><a href="#运行结果-2" class="headerlink" title="运行结果"></a>运行结果</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">Infinity<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><blockquote><p>可移植性是Java语言的设计目标之一。无论在哪个虚拟机上运行，同一运算应该得到同样的结果。对于浮点数的算术运算，实现这样的可移植性是相当困难的。double类型使用64位存储一个数值，而有些处理器则使用80位浮点寄存器。这些寄存器增加了中间过程的计算精度。例如，以下运算：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">double w&#x3D;x*y&#x2F;z;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>很多Intel处理器计算x<br>×y，并且将结果存储在80位的寄存器中，再除以z并将结果截断为64位。这样可以得到一个更加精确的计算结果，并且还能够避免产生指数溢出。但是，这个结果可能与始终使用64位计算的结果<strong>不一样</strong>。因此，Java虚拟机的最初规范规定所有的中间计算都必须进行截断。这种做法遭到了数字社区的反对。截断计算不仅可能导致溢出，而且由于截断操作需要消耗时间，所以在计算速度上实际上要比精确计算慢。为此，Java程序设计语言承认了最优性能与理想的可再生性之间存在的冲突，并给予了改进。在默认情况下，现在虚拟机设计者允许对中间计算结果采用扩展的精度。但是，对于使用<strong>strictfp</strong>关键字标记的方法必须使用严格的浮点计算来生成可再生的结果。</p><p>例如，可以把main方法标记为</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">public static **strictfp** void main(String[] args)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>那么，<strong>main</strong>方法中的所有指令都将使用严格的浮点计算。如果将一个类标记为<strong>strictfp</strong>，这个类中的所有方法都要使用严格的浮点计算。</p><p>具体的计算细节取决于Intel处理器的行为。在默认情况下，中间结果允许使用扩展的指数，但不允许使用扩展的尾数（Intel芯片支持截断尾数时并不损失性能）。因此，这两种方式的区别仅仅是采用默认方式不会产生溢出，而采用严格的计算有可能产生溢出。</p></blockquote><h2 id="数学函数与常量"><a href="#数学函数与常量" class="headerlink" title="数学函数与常量"></a>数学函数与常量</h2><blockquote><p>在Math类中，包含了各种各样的数学函数。在编写不同类别的程序时，可能需要的函数也不同。</p></blockquote><h3 id="sqrt方法"><a href="#sqrt方法" class="headerlink" title="sqrt方法"></a>sqrt方法</h3><blockquote><p>要想计算一个数值的平方根，可以使用<strong>sqrt</strong>方法：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">double x&#x3D;4;
double y&#x3D;Math.sqrt(x);
System.out.println(y);   &#x2F;&#x2F;prints 2.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="程序示例-3"><a href="#程序示例-3" class="headerlink" title="程序示例"></a>程序示例</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">public class HuangZiHanTest
&#123;  
	public static void main(String[] args)
   &#123;
		double huangzihan_x&#x3D;4;
		double huangzihan_y&#x3D;Math.sqrt(huangzihan_x);
		System.out.println(huangzihan_y);   &#x2F;&#x2F;prints 2.0
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行结果-3"><a href="#运行结果-3" class="headerlink" title="运行结果"></a>运行结果</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">2.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="注释-1"><a href="#注释-1" class="headerlink" title="注释"></a>注释</h3><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><blockquote><p><strong>println</strong>方法和<strong>sqrt</strong>方法存在微小的差异。<strong>println</strong>方法处理<strong>System.out</strong>对象。但是，<strong>Math</strong>类中的<strong>sqrt</strong>方法并不处理任何对象，这样的方法被称为<strong>静态</strong>方法。</p></blockquote><h3 id="幂运算"><a href="#幂运算" class="headerlink" title="幂运算"></a>幂运算</h3><blockquote><p>在Java中，没有幂运算，因此需要借助于<strong>Math</strong>类的<strong>pow</strong>方法。以下语句：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">double y&#x3D;Math.pow(x,a);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>将y的值设置为x的a次幂（xe）。pow方法有两个double类型的参数，其返回结果也为double类型。</p></blockquote><h4 id="程序示例-4"><a href="#程序示例-4" class="headerlink" title="程序示例"></a>程序示例</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">public class HuangZiHanTest
&#123;  
   public static void main(String[] args)
   &#123;
		double huangzihan_x&#x3D;2.0;
		double huangzihan_a&#x3D;3.0;
		double huangzihan_y&#x3D;Math.pow(huangzihan_x,huangzihan_a);
		System.out.println(huangzihan_y);   
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行结果-4"><a href="#运行结果-4" class="headerlink" title="运行结果"></a>运行结果</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">8.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="floorMod方法"><a href="#floorMod方法" class="headerlink" title="floorMod方法"></a>floorMod方法</h3><blockquote><p><strong>floorMod</strong>方法的目的是解决一个长期存在的有关整数余数的问题。考虑表达式n%2。所有人都知道，如果n是偶数，这个表达式为0；如果n是奇数，表达式则为1。当然，除非n是负数。如果n为负，这个表达式则为-1。为什么呢？设计最早的计算机时，必须有人制定规则，明确整数除法和求余对负数操作数该如何处理。数学家们几百年来都知道这样一个最优（或称“欧几里得”）规则：余数总是要≥0。不过，最早制定规则的人并没有翻开数学书好好研究，而是提出了一些看似合理但实际上很不方便的规则。</p><p>下面考虑这样一个问题：计算一个时钟时针的位置。这里要做一个时间调整，而且要归一化为一个0 ~ 11之间的数。这很简单：<strong>(position + adjustment)%12</strong>。不过，如果这个调整为负会怎么样呢？你可能会得到一个负数。所以要引入一个分支，或者使用<code>((position +adjustment)%12+12)%12</code>。不管怎样都很麻烦。</p><p><strong>floorMod</strong>方法就让这个问题变得容易了：<code>floorMod(position+adjustment,12)</code>总会得到一个0 ~ 11之间的数。（遗憾的是，对于负除数，<strong>floorMod</strong>会得到负数结果，不过这种情况在实际中很少出现。）</p></blockquote><h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><blockquote><p>Math类提供了一些常用的三角函数：</p></blockquote><ul><li><strong>Math.sin</strong></li><li><strong>Math.cos</strong></li><li><strong>Math.tan</strong></li><li><strong>Math.atan</strong></li><li><strong>Math.atan2</strong></li></ul><blockquote><p>还有指数函数以及它的反函数——自然对数以及以10为底的对数：</p></blockquote><ul><li><strong>Math.exp</strong></li><li><strong>Math.log</strong></li><li><strong>Math.log10</strong></li></ul><blockquote><p>最后，Java还提供了两个用于表示π和e常量的最接近的近似值：</p></blockquote><ul><li><strong>Math.PI</strong></li><li><strong>Math.E</strong></li></ul><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><blockquote><p>不必在数学方法名和常量名前添加前缀“Math”，只要在源文件的顶部加上下面这行代码就可以了。</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">import static java.lang.Math.*;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>例如：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">System.out.println(&quot;The square root of\u03c0 is&quot;+sqrt(PI));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="程序示例-5"><a href="#程序示例-5" class="headerlink" title="程序示例"></a>程序示例</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">import static java.lang.Math.*;

public class HuangZiHanTest
&#123;  
   public static void main(String[] args)
   &#123;
	   System.out.println(&quot;平方根\u03c0为：&quot;+sqrt(PI));  
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行结果-5"><a href="#运行结果-5" class="headerlink" title="运行结果"></a>运行结果</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">平方根π为：1.7724538509055159<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="注释-2"><a href="#注释-2" class="headerlink" title="注释"></a>注释</h3><blockquote><p>在Math类中，为了达到最佳的性能，所有的方法都使用计算机浮点单元中的例程。如果得到一个完全可预测的结果比运行速度更重要的话，那么就应该使用<strong>StrictMath</strong>类。它实现了“可自由分发的数学库（Freely Distributable Math Library，FDLIBM）”的算法（www.netlib.org/fdlibm），确保在所有平台上得到相同的结果。</p></blockquote><h3 id="注释-3"><a href="#注释-3" class="headerlink" title="注释"></a>注释</h3><blockquote><p>Math类提供了一些方法使整数有更好的运算安全性。如果一个计算溢出，数学运算符只是悄悄地返回错误的结果而不做任何提醒。例如，10亿乘以3（1000000000*3）的计算结果将是-1294967296，因为最大的int值也只是刚刚超过20亿。不过，如果调用<code>Math.multiplyExact(1000000000,3)</code>，就会生成一个异常。你可以捕获这个异常或者让程序终止，而不是允许它给出一个错误的结果然后悄无声息地继续运行。另外还有一些方法（addExact、subtractExact、incrementExact、decrementExact和negateExact）也可以正确地处理int和long参数。</p></blockquote><h2 id="数值类型之间的转换"><a href="#数值类型之间的转换" class="headerlink" title="数值类型之间的转换"></a>数值类型之间的转换</h2><h3 id="数值类型之间的合法转换"><a href="#数值类型之间的合法转换" class="headerlink" title="数值类型之间的合法转换"></a>数值类型之间的合法转换</h3><blockquote><p>我们经常需要将一种数值类型转换为另一种数值类型。图（数值类型之间的合法转换）给出了数值类型之间的合法转换。</p></blockquote><center><img src="/2021/07/03/%E8%BF%90%E7%AE%97%E7%AC%A6/数值类型之间的合法转换.png" width="70%" height="70%"> 数值类型之间的合法转换</center><blockquote><p>在图（数值类型之间的合法转换）中有6个实线箭头，表示无信息丢失的转换；另外有3个虚线箭头，表示可能有精度损失的转换。例如，123456789是一个大整数，它所包含的位数比float类型所能够表示的位数多。当将这个整数转换为float类型时，将会得到正确的大小，但是会损失一些精度。</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">int n&#x3D;123456789;
float f&#x3D;n;   &#x2F;&#x2F;f is 1.23456792E8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="程序示例-6"><a href="#程序示例-6" class="headerlink" title="程序示例"></a>程序示例</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">public class HuangZiHanTest
&#123;  
   public static void main(String[] args)
   &#123;
	   int huangzihan_n&#x3D;123456789;
	   float huangzihan_f&#x3D;huangzihan_n;   &#x2F;&#x2F;f is 1.23456792E8
	   System.out.println(huangzihan_f);  
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行结果-6"><a href="#运行结果-6" class="headerlink" title="运行结果"></a>运行结果</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">1.23456792E8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="二元运算符连接两个值"><a href="#二元运算符连接两个值" class="headerlink" title="二元运算符连接两个值"></a>二元运算符连接两个值</h3><blockquote><p>当用一个二元运算符连接两个值时（例如n+f，n是整数，f是浮点数），先要将两个操作数转换为同一种类型，然后再进行计算。</p></blockquote><ul><li>如果两个操作数中有一个是double类型，另一个操作数就会转换为double类型。</li><li>否则，如果其中一个操作数是float类型，另一个操作数将会转换为float类型。</li><li>否则，如果其中一个操作数是long类型，另一个操作数将会转换为long类型。</li><li>否则，两个操作数都将被转换为int类型。</li></ul><h4 id="程序示例-7"><a href="#程序示例-7" class="headerlink" title="程序示例"></a>程序示例</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">public class HuangZiHanTest
&#123;  
   public static void main(String[] args)
   &#123;
	   int huangzihan_i&#x3D;123;
	   float huangzihan_f&#x3D;12;   
	   double huangzihan_d&#x3D;12.34;
	   long huangzihan_l&#x3D;1234;
	   System.out.println(huangzihan_i+huangzihan_d);  
	   System.out.println(huangzihan_i+huangzihan_f);
	   System.out.println(huangzihan_i+huangzihan_l);
	   System.out.println(huangzihan_i+huangzihan_i);
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行结果-7"><a href="#运行结果-7" class="headerlink" title="运行结果"></a>运行结果</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">135.34
135.0
1357
246<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><h3 id="强制类型转换的例子"><a href="#强制类型转换的例子" class="headerlink" title="强制类型转换的例子"></a>强制类型转换的例子</h3><blockquote><p>int类型的值将会自动地转换为double类型。但另一方面，有时也需要将double转换成int。在Java中，允许进行这种数值之间的类型转换，当然，有可能会丢失一些信息。这种可能损失信息的转换要通过<strong>强制类型转换</strong>（cast）来完成。强制类型转换的语法格式是在圆括号中给出想要转换的目标类型，后面紧跟待转换的变量名。例如：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">double x&#x3D;9.997;
int nx&#x3D;(int) x;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>这样，变量nx的值为9，因为强制类型转换通过截断小数部分将浮点值转换为整型。</p></blockquote><h4 id="程序示例-8"><a href="#程序示例-8" class="headerlink" title="程序示例"></a>程序示例</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">public class HuangZiHanTest
&#123;  
   public static void main(String[] args)
   &#123;
	   double huangzihan_x&#x3D;9.997;
	   int huangzihan_y&#x3D;(int) huangzihan_x;
	   System.out.println(huangzihan_y);  
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行结果-8"><a href="#运行结果-8" class="headerlink" title="运行结果"></a>运行结果</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">9<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="浮点数舍入运算"><a href="#浮点数舍入运算" class="headerlink" title="浮点数舍入运算"></a>浮点数舍入运算</h3><blockquote><p>如果想对浮点数进行<strong>舍入运算</strong>，以便得到<strong>最接近</strong>的整数（在很多情况下，这种操作更有用），那就需要使用<strong>Math.round</strong>方法：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">double x&#x3D;9.997;
int nx&#x3D;(int) Math.round(x);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="程序示例-9"><a href="#程序示例-9" class="headerlink" title="程序示例"></a>程序示例</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">public class HuangZiHanTest
&#123;  
   public static void main(String[] args)
   &#123;
	   double huangzihan_z&#x3D;9.997;
	   int huangzihan_x&#x3D;(int) Math.round(huangzihan_z);
	   long huangzihan_y&#x3D;Math.round(huangzihan_z);
	   System.out.println(huangzihan_x);  
	   System.out.println(huangzihan_y);
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行结果-9"><a href="#运行结果-9" class="headerlink" title="运行结果"></a>运行结果</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">10<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>现在，变量nx的值为10。当调用<strong>round</strong>的时候，仍然需要使用强制类型转换（int）。其原因是<strong>round</strong>方法返回的结果为<strong>long</strong>类型，由于存在信息丢失的可能性，所以只有使用显式的强制类型转换才能够将<strong>long</strong>类型转换成<strong>int</strong>类型。</p></blockquote><h3 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h3><blockquote><p>如果试图将一个数值从一种类型强制转换为另一种类型，而又超出了目标类型的表示范围，结果就会截断成一个完全不同的值。例如，(byte)300的实际值为44。</p></blockquote><h4 id="程序示例-10"><a href="#程序示例-10" class="headerlink" title="程序示例"></a>程序示例</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">public class HuangZiHanTest
&#123;  
   public static void main(String[] args)
   &#123;
	   int huangzihan&#x3D;(byte)300;
	   System.out.println(huangzihan);  
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行结果-10"><a href="#运行结果-10" class="headerlink" title="运行结果"></a>运行结果</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">44<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="结合赋值和运算符"><a href="#结合赋值和运算符" class="headerlink" title="结合赋值和运算符"></a>结合赋值和运算符</h2><blockquote><p>可以在赋值中使用二元运算符，这是一种很方便的简写形式。例如，</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">x +&#x3D; 4;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>等价于：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">x &#x3D; x + 4;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>（一般来说，要把运算符放在=号左边，如*=或%=）。</p></blockquote><h3 id="程序示例-11"><a href="#程序示例-11" class="headerlink" title="程序示例"></a>程序示例</h3><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">public class HuangZiHanTest
&#123;  
   public static void main(String[] args)
   &#123;
	   int huangzihan_x&#x3D;4;
	   huangzihan_x+&#x3D;4;
	   System.out.println(huangzihan_x);  
	   
	   int huangzihan_y&#x3D;4;
	   huangzihan_y&#x3D;huangzihan_y+4;
	   System.out.println(huangzihan_y);
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="运行结果-11"><a href="#运行结果-11" class="headerlink" title="运行结果"></a>运行结果</h3><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">8
8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="注释-4"><a href="#注释-4" class="headerlink" title="注释"></a>注释</h3><blockquote><p>如果运算符得到一个值，其类型与左侧操作数的类型不同，就会发生强制类型转换。例如，如果x是一个int，则以下语句</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">x +&#x3D; 3.5;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>是合法的，将把x设置为(int)(x+3.5)。</p></blockquote><h4 id="程序示例-12"><a href="#程序示例-12" class="headerlink" title="程序示例"></a>程序示例</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">public class HuangZiHanTest
&#123;  
   public static void main(String[] args)
   &#123;
	   int huangzihan_x&#x3D;4;
	   huangzihan_x +&#x3D; 3.5;
	   System.out.println(huangzihan_x);  
	   
	   int huangzihan_y&#x3D;4;
	   huangzihan_y +&#x3D; 3.5;
	   System.out.println(huangzihan_y);
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行结果-12"><a href="#运行结果-12" class="headerlink" title="运行结果"></a>运行结果</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">7
7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="自增与自减运算符"><a href="#自增与自减运算符" class="headerlink" title="自增与自减运算符"></a>自增与自减运算符</h2><blockquote><p>当然，程序员都知道加1、减1是数值变量最常见的操作。在Java中，借鉴了C和<code>C++</code>中的做法，也提供了自增、自减运算符：n++将变量n的当前值加1，n—则将n的值减1。例如，以下代码：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">int n&#x3D;12;
n++;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="程序示例-13"><a href="#程序示例-13" class="headerlink" title="程序示例"></a>程序示例</h3><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">public class HuangZiHanTest
&#123;  
   public static void main(String[] args)
   &#123;
	   int huangzihan_n&#x3D;12;
	   huangzihan_n++;
	   System.out.println(huangzihan_n);  
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="运行结果-13"><a href="#运行结果-13" class="headerlink" title="运行结果"></a>运行结果</h3><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">13<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>将n的值改为13。由于这些运算符改变的是变量的值，所以它们不能应用于数值本身。例如，4++就不是一个合法的语句。</p></blockquote><h3 id="前后缀形式"><a href="#前后缀形式" class="headerlink" title="前后缀形式"></a>前后缀形式</h3><blockquote><p>实际上，这些运算符有两种形式；上面介绍的是运算符放在操作数后面的“后缀”形式。还有一种“前缀”形式：++n。后缀和前缀形式都会使变量值加1或减1。但用在表达式中时，二者就有区别了。前缀形式会先完成加1；而后缀形式会使用变量原来的值。</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">int m&#x3D;7;
int n&#x3D;7;
int a&#x3D;2 * ++m;  &#x2F;&#x2F;now a is 16，m is 8
int b&#x3D;2 * n++;  &#x2F;&#x2F;now b is 14，n is 8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="程序示例-14"><a href="#程序示例-14" class="headerlink" title="程序示例"></a>程序示例</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">public class HuangZiHanTest
&#123;  
   public static void main(String[] args)
   &#123;
	   int huangzihan_m&#x3D;7;
	   int huangzihan_n&#x3D;7;
	   int huangzihan_a&#x3D;2 * ++huangzihan_m;  &#x2F;&#x2F;now huangzihan_a is 16，huangzihan_m is 8
	   int huangzihan_b&#x3D;2 * huangzihan_n++;  &#x2F;&#x2F;now huangzihan_b is 14，huangzihan_n is 8
	   System.out.println(huangzihan_a);  
	   System.out.println(huangzihan_b);
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行结果-14"><a href="#运行结果-14" class="headerlink" title="运行结果"></a>运行结果</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">16
14<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>建议不要在表达式中使用++，因为这样的代码很容易让人困惑，而且会带来烦人的bug。</p></blockquote><h2 id="关系和boolean运算符"><a href="#关系和boolean运算符" class="headerlink" title="关系和boolean运算符"></a>关系和boolean运算符</h2><h3 id="检测相等性"><a href="#检测相等性" class="headerlink" title="检测相等性"></a>检测相等性</h3><blockquote><p>Java包含丰富的关系运算符。要检测相等性，可以使用两个等号==。例如，</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">3&#x3D;&#x3D;7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>的值为false。</p><p>另外可以使用!=检测不相等。例如，</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">3!&#x3D;7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>的值为true。</p><p>最后，还有经常使用的&lt;（小于）、&gt;（大于）、&lt;=（小于等于）和&gt;=（大于等于）运算符。</p></blockquote><h4 id="程序示例-15"><a href="#程序示例-15" class="headerlink" title="程序示例"></a>程序示例</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">public class HuangZiHanTest
&#123;  
   public static void main(String[] args)
   &#123;
	   System.out.println(3&#x3D;&#x3D;7);  
	   System.out.println(3!&#x3D;7);
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行结果-15"><a href="#运行结果-15" class="headerlink" title="运行结果"></a>运行结果</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">false
true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="amp-amp-运算符"><a href="#amp-amp-运算符" class="headerlink" title="&amp;&amp;运算符"></a>&amp;&amp;运算符</h3><blockquote><p>Java沿用了C++的做法，使用&amp;&amp;表示逻辑“与”运算符，使用||表示逻辑“或”运算符。从!=运算符可以想到，感叹号!就是逻辑非运算符。&amp;&amp;和||运算符是按照“短路”方式来求值的：如果第一个操作数已经能够确定表达式的值，第二个操作数就不必计算了。如果用&amp;&amp;运算符合并两个表达式，</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">expression1 &amp;&amp; expression2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>而且已经计算得到第一个表达式的真值为false，那么结果就不可能为true。因此，第二个表达式就不必计算了。可以利用这一点来避免错误。例如，在下面的表达式中：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">x !&#x3D; 0 &amp;&amp; 1&#x2F;x &gt; x+y &#x2F;&#x2F;no division by 0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="程序示例-16"><a href="#程序示例-16" class="headerlink" title="程序示例"></a>程序示例</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">public class HuangZiHanTest
&#123;  
   public static void main(String[] args)
   &#123;
	   int huangzihan_x&#x3D;1;
	   int huangzihan_y&#x3D;2;
	   boolean huangzihan_z;
	   huangzihan_z&#x3D;huangzihan_x !&#x3D; 0 &amp;&amp; 1&#x2F;huangzihan_x &gt; huangzihan_x+huangzihan_y;  &#x2F;&#x2F;no division by 0
	   System.out.println(huangzihan_z);
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行结果-16"><a href="#运行结果-16" class="headerlink" title="运行结果"></a>运行结果</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>如果x等于0，那么第二部分就不会计算。因此，如果x为0，也就不会计算1/x，除以0的错误就不会出现。</p><p>类似地，如果第一个表达式为<strong>true</strong>，<code>expression1||expression2</code>的值就自动为<strong>true</strong>，而无须计算第二个表达式。</p></blockquote><h3 id="三元操作符"><a href="#三元操作符" class="headerlink" title="三元操作符?:"></a>三元操作符<code>?:</code></h3><blockquote><p>最后一点，Java支持三元操作符<code>?:</code>，这个操作符有时很有用。如果条件为<strong>true</strong>，下面的表达式</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">condition?expression1:expression2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>就为第一个表达式的值，否则计算为第二个表达式的值。例如，</p></blockquote><center><img src="/2021/07/03/%E8%BF%90%E7%AE%97%E7%AC%A6/三元操作符.png" width="30%" height="30%"> 三元操作符</center><blockquote><p>会返回x和y中较小的一个。</p></blockquote><h4 id="程序示例-17"><a href="#程序示例-17" class="headerlink" title="程序示例"></a>程序示例</h4><center><img src="/2021/07/03/%E8%BF%90%E7%AE%97%E7%AC%A6/三元运算符程序示例.png" width="90%" height="90%"> 三元运算符程序示例</center><h4 id="运行结果-17"><a href="#运行结果-17" class="headerlink" title="运行结果"></a>运行结果</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><h3 id="掩码技术"><a href="#掩码技术" class="headerlink" title="掩码技术"></a>掩码技术</h3><blockquote><p>处理整型类型时，可以直接对组成整数的各个位完成操作。这意味着可以使用掩码技术得到整数中的各个位。位运算符包括：</p></blockquote><center><img src="/2021/07/03/%E8%BF%90%E7%AE%97%E7%AC%A6/位运算符.png" width="50%" height="50%"> 位运算符</center><blockquote><p>这些运算符按位模式处理。例如，如果n是一个整数变量，而且用二进制表示的n从右边数第4位为1，则</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">int fourthBitFromRight&#x3D;(n&amp;0b1000)&#x2F;0b1000;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>会返回1，否则返回0。利用&amp;并结合使用适当的2的幂，可以把其他位掩掉，而只留下其中的某一位。</p></blockquote><h4 id="程序示例-18"><a href="#程序示例-18" class="headerlink" title="程序示例"></a>程序示例</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">public class HuangZiHanTest
&#123;  
   public static void main(String[] args)
   &#123;
	   int huangzihan_n&#x3D;1;
	   System.out.println(huangzihan_n&amp;0b1000);
	   int fourthBitFromRight&#x3D;(huangzihan_n&amp;0b1000)&#x2F;0b1000;
	   System.out.println(fourthBitFromRight);
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行结果-18"><a href="#运行结果-18" class="headerlink" title="运行结果"></a>运行结果</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">0
0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="注释-5"><a href="#注释-5" class="headerlink" title="注释"></a>注释</h3><blockquote><p>应用在布尔值上时，<code>&amp;</code>和<code>|</code>运算符也会得到一个布尔值。这些运算符<code>&amp;&amp;</code>与和<code>||</code>运算符很类似，不过<code>&amp;</code>和<code>|</code>运算符不采用“短路”方式来求值，也就是说，得到计算结果之前两个操作数都需要计算。</p></blockquote><h4 id="左移右移运算符"><a href="#左移右移运算符" class="headerlink" title="左移右移运算符"></a>左移右移运算符</h4><blockquote><p>另外，还有<code>&gt;&gt;</code>和<code>&lt;&lt;</code>运算符可以将位模式左移或右移。需要建立位模式来完成位掩码时，这两个运算符会很方便：</p></blockquote><center><img src="/2021/07/03/%E8%BF%90%E7%AE%97%E7%AC%A6/左移右移运算符程序示例一.png" width="50%" height="50%"> 左移右移运算符程序示例一</center><h5 id="程序示例-19"><a href="#程序示例-19" class="headerlink" title="程序示例"></a>程序示例</h5><center><img src="/2021/07/03/%E8%BF%90%E7%AE%97%E7%AC%A6/左移右移运算符程序示例二.png" width="90%" height="90%"> 左移右移运算符程序示例二</center><h5 id="运行结果-19"><a href="#运行结果-19" class="headerlink" title="运行结果"></a>运行结果</h5><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">0
0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>最后，&gt;&gt;&gt;运算符会用0填充高位，这与&gt;&gt;不同，它会用符号位填充高位。不存在&lt;&lt;&lt;运算符。</p></blockquote><h3 id="警告-1"><a href="#警告-1" class="headerlink" title="警告"></a>警告</h3><center><img src="/2021/07/03/%E8%BF%90%E7%AE%97%E7%AC%A6/警告.png" width="90%" height="90%"> 警告</center><h4 id="程序示例-20"><a href="#程序示例-20" class="headerlink" title="程序示例"></a>程序示例</h4><center><img src="/2021/07/03/%E8%BF%90%E7%AE%97%E7%AC%A6/左移右移运算符程序示例三.png" width="55%" height="55%"> 左移右移运算符程序示例三</center><h4 id="运行结果-20"><a href="#运行结果-20" class="headerlink" title="运行结果"></a>运行结果</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">8
8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="括号与运算符级别"><a href="#括号与运算符级别" class="headerlink" title="括号与运算符级别"></a>括号与运算符级别</h2><blockquote><p>表（运算符优先级）给出了运算符的优先级。如果不使用圆括号，就按照给出的运算符优先级次序进行计算。同一个级别的运算符按照从左到右的次序进行计算（但右结合运算符除外，如表中所示）。例如，由于<code>&amp;&amp;</code>的优先级比<code>||</code>的优先级高，所以表达式</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">a &amp;&amp; b || c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>等价于</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">(a &amp;&amp; b) || c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="程序示例-21"><a href="#程序示例-21" class="headerlink" title="程序示例"></a>程序示例</h3><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">public class HuangZiHanTest
&#123;  
   public static void main(String[] args)
   &#123;
	   boolean huangzihan_a&#x3D;true;
	   boolean huangzihan_b&#x3D;false;
	   boolean huangzihan_c&#x3D;true;
	   System.out.println(huangzihan_a &amp;&amp; huangzihan_b || huangzihan_c);
	   
	   System.out.println();
	   
	   boolean huangzihan_d&#x3D;true;
	   boolean huangzihan_e&#x3D;false;
	   boolean huangzihan_f&#x3D;true;
	   System.out.println((huangzihan_d &amp;&amp; huangzihan_e) || huangzihan_f);
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="运行结果-21"><a href="#运行结果-21" class="headerlink" title="运行结果"></a>运行结果</h3><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">false
false

true
true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>又因为<code>+=</code>是右结合运算符，所以表达式</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">a +&#x3D; b +&#x3D; c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>等价于</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">a +&#x3D; (b +&#x3D; c)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>也就是将<code>b += c</code>的结果（加上c之后的b）加到a上。</p></blockquote><h3 id="程序示例-22"><a href="#程序示例-22" class="headerlink" title="程序示例"></a>程序示例</h3><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">public class HuangZiHanTest
&#123;  
   public static void main(String[] args)
   &#123;
	   int huangzihan_a&#x3D;1;
	   int huangzihan_b&#x3D;2;
	   int huangzihan_c&#x3D;3;
	   System.out.println(huangzihan_a +&#x3D; huangzihan_b +&#x3D; huangzihan_c);
	   
	   System.out.println();
	   
	   int huangzihan_d&#x3D;1;
	   int huangzihan_e&#x3D;2;
	   int huangzihan_f&#x3D;3;
	   System.out.println(huangzihan_d +&#x3D; (huangzihan_e +&#x3D; huangzihan_f));
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="运行结果-22"><a href="#运行结果-22" class="headerlink" title="运行结果"></a>运行结果</h3><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">6

6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><center><img src="/2021/07/03/%E8%BF%90%E7%AE%97%E7%AC%A6/运算符优先级.png" width="80%" height="80%"> 运算符优先级</center><!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]--><audio id="audio" loop preload="auto" controls data-autoplay="true"><source type="audio/mpeg" src=""></audio><ul id="audio-list" style="display:none"><li title="0" data-url="https://link.hhtjim.com/163/4989670.mp3"></li><li title="1" data-url="https://link.hhtjim.com/163/214374.mp3"></li><li title="2" data-url="https://link.hhtjim.com/163/443794.mp3"></li><li title="3" data-url="https://link.hhtjim.com/163/28188450.mp3"></li><li title="4" data-url="https://link.hhtjim.com/163/29816860.mp3"></li><li title="5" data-url="https://link.hhtjim.com/163/4940920.mp3"></li><li title="6" data-url="https://link.hhtjim.com/163/443860.mp3"></li><li title="7" data-url="https://link.hhtjim.com/163/4940920.mp3"></li><li title="8" data-url="https://link.hhtjim.com/163/1825230064.mp3"></li><li title="9" data-url="https://link.hhtjim.com/163/27570832.mp3"></li><li title="10" data-url="https://link.hhtjim.com/163/28285777.mp3"></li><li title="11" data-url="https://link.hhtjim.com/163/68622.mp3"></li><li title="12" data-url="https://link.hhtjim.com/163/4968365.mp3"></li><li title="13" data-url="https://link.hhtjim.com/163/4968352.mp3"></li><li title="14" data-url="https://link.hhtjim.com/163/28378263.mp3"></li><li title="15" data-url="https://link.hhtjim.com/163/1461262038.mp3"></li><li title="16" data-url="https://link.hhtjim.com/163/1821680008.mp3"></li><li title="17" data-url="https://link.hhtjim.com/163/1404997257.mp3"></li></ul></div></div><div class="side"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.</span> <span class="toc-text">运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.1.</span> <span class="toc-text">算术运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97"><span class="toc-number">1.1.1.</span> <span class="toc-text">四则运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">运行结果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E9%99%A40"><span class="toc-number">1.1.2.</span> <span class="toc-text">整数除0</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-1"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">运行结果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E8%A2%AB0%E9%99%A4"><span class="toc-number">1.1.3.</span> <span class="toc-text">浮点数被0除</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-2"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-2"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">运行结果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-number">1.1.4.</span> <span class="toc-text">注释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0%E4%B8%8E%E5%B8%B8%E9%87%8F"><span class="toc-number">1.2.</span> <span class="toc-text">数学函数与常量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sqrt%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.1.</span> <span class="toc-text">sqrt方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-3"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-3"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">运行结果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A-1"><span class="toc-number">1.2.2.</span> <span class="toc-text">注释</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">静态方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%82%E8%BF%90%E7%AE%97"><span class="toc-number">1.2.3.</span> <span class="toc-text">幂运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-4"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-4"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">运行结果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#floorMod%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.4.</span> <span class="toc-text">floorMod方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Math%E7%B1%BB"><span class="toc-number">1.2.5.</span> <span class="toc-text">Math类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA"><span class="toc-number">1.2.6.</span> <span class="toc-text">提示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-5"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-5"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">运行结果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A-2"><span class="toc-number">1.2.7.</span> <span class="toc-text">注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A-3"><span class="toc-number">1.2.8.</span> <span class="toc-text">注释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.3.</span> <span class="toc-text">数值类型之间的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%90%88%E6%B3%95%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.3.1.</span> <span class="toc-text">数值类型之间的合法转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-6"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-6"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">运行结果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%E8%BF%9E%E6%8E%A5%E4%B8%A4%E4%B8%AA%E5%80%BC"><span class="toc-number">1.3.2.</span> <span class="toc-text">二元运算符连接两个值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-7"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-7"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">运行结果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.4.</span> <span class="toc-text">强制类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">1.4.1.</span> <span class="toc-text">强制类型转换的例子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-8"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-8"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">运行结果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E8%88%8D%E5%85%A5%E8%BF%90%E7%AE%97"><span class="toc-number">1.4.2.</span> <span class="toc-text">浮点数舍入运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-9"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-9"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">运行结果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AD%A6%E5%91%8A"><span class="toc-number">1.4.3.</span> <span class="toc-text">警告</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-10"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-10"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">运行结果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E5%90%88%E8%B5%8B%E5%80%BC%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.5.</span> <span class="toc-text">结合赋值和运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-11"><span class="toc-number">1.5.1.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-11"><span class="toc-number">1.5.2.</span> <span class="toc-text">运行结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A-4"><span class="toc-number">1.5.3.</span> <span class="toc-text">注释</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-12"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-12"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">运行结果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%A2%9E%E4%B8%8E%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.6.</span> <span class="toc-text">自增与自减运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-13"><span class="toc-number">1.6.1.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-13"><span class="toc-number">1.6.2.</span> <span class="toc-text">运行结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E5%90%8E%E7%BC%80%E5%BD%A2%E5%BC%8F"><span class="toc-number">1.6.3.</span> <span class="toc-text">前后缀形式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-14"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-14"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">运行结果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E5%92%8Cboolean%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.7.</span> <span class="toc-text">关系和boolean运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E7%9B%B8%E7%AD%89%E6%80%A7"><span class="toc-number">1.7.1.</span> <span class="toc-text">检测相等性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-15"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-15"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">运行结果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#amp-amp-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.7.2.</span> <span class="toc-text">&amp;&amp;运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-16"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-16"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">运行结果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%85%83%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.7.3.</span> <span class="toc-text">三元操作符?:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-17"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-17"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">运行结果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.8.</span> <span class="toc-text">位运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A9%E7%A0%81%E6%8A%80%E6%9C%AF"><span class="toc-number">1.8.1.</span> <span class="toc-text">掩码技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-18"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-18"><span class="toc-number">1.8.1.2.</span> <span class="toc-text">运行结果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A-5"><span class="toc-number">1.8.2.</span> <span class="toc-text">注释</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A6%E7%A7%BB%E5%8F%B3%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">左移右移运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-19"><span class="toc-number">1.8.2.1.1.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-19"><span class="toc-number">1.8.2.1.2.</span> <span class="toc-text">运行结果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AD%A6%E5%91%8A-1"><span class="toc-number">1.8.3.</span> <span class="toc-text">警告</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-20"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-20"><span class="toc-number">1.8.3.2.</span> <span class="toc-text">运行结果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%AC%E5%8F%B7%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6%E7%BA%A7%E5%88%AB"><span class="toc-number">1.9.</span> <span class="toc-text">括号与运算符级别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-21"><span class="toc-number">1.9.1.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-21"><span class="toc-number">1.9.2.</span> <span class="toc-text">运行结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-22"><span class="toc-number">1.9.3.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-22"><span class="toc-number">1.9.4.</span> <span class="toc-text">运行结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.9.5.</span> <span class="toc-text">运算符优先级</span></a></li></ol></li></ol></li></ol></div></div></div></div></body><script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script><script src="/js/plugin.js"></script><script src="/js/typed.js"></script><script src="/js/diaspora.js"></script><link rel="stylesheet" href="/photoswipe/photoswipe.css"><link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css"><script src="/photoswipe/photoswipe.min.js"></script><script src="/photoswipe/photoswipe-ui-default.min.js"></script><div class="pswp" tabindex="-1" role="dialog" aria-hidden="true"><div class="pswp__bg"></div><div class="pswp__scroll-wrap"><div class="pswp__container"><div class="pswp__item"></div><div class="pswp__item"></div><div class="pswp__item"></div></div><div class="pswp__ui pswp__ui--hidden"><div class="pswp__top-bar"><div class="pswp__counter"></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button> <button class="pswp__button pswp__button--share" title="Share"></button> <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button> <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class="pswp__preloader"><div class="pswp__preloader__icn"><div class="pswp__preloader__cut"><div class="pswp__preloader__donut"></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class="pswp__share-tooltip"></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button> <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class="pswp__caption"><div class="pswp__caption__center"></div></div></div></div></div></html><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6af129e1f4dfb540b30b7969d7e7fc32";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script>