<!DOCTYPE html><html lang="zh-CN" class="loading"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><title>数据类型 - 黄子涵</title><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="google" content="notranslate"><meta name="keywords" content="黄子涵,"><meta name="description" content="数据类型强类型语言
Java是一种强类型语言。这就意味着必须为每一个变量声明一种类型。在Java中，一共有8种基本类型（primitive type），其中有4种整型、2种浮点类型、1种字符类型ch,"><meta name="author" content="黄子涵"><link rel="alternative" href="atom.xml" title="黄子涵" type="application/atom+xml"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="/css/diaspora.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><meta name="generator" content="Hexo 5.4.0"><link rel="stylesheet" href="/css/prism-atom-dark.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script>
<script src="/js/prism-line-numbers.min.js"></script></head><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><body class="loading"><span id="config-title" style="display:none">黄子涵</span><div id="loader"></div><div id="single"><div id="top" style="display:block"><div class="bar" style="width:0"></div><a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://www.huangzihan.top"></a><div title="播放/暂停" class="iconfont icon-play"></div><h3 class="subtitle">数据类型</h3><div class="social"><div><div class="share"><a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a></div><div id="qr"></div></div></div><div class="scrollbar"></div></div><div class="section"><div class="article"><div class="main"><h1 class="title">数据类型</h1><div class="stuff"><span>七月 01, 2021</span></div><div class="content markdown"><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="强类型语言"><a href="#强类型语言" class="headerlink" title="强类型语言"></a>强类型语言</h2><blockquote><p>Java是一种强类型语言。这就意味着必须为每一个变量声明一种类型。在Java中，一共有8种基本类型（primitive type），其中有4种整型、2种浮点类型、1种字符类型char（用于表示Unicode编码的代码单元）和1种用于表示真值的<strong>boolean</strong>类型。</p></blockquote><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><blockquote><p>整型用于表示没有小数部分的数值，允许是负数。Java提供了4种整型，具体内容如下：</p></blockquote><h3 id="Java整型"><a href="#Java整型" class="headerlink" title="Java整型"></a>Java整型</h3><div class="table-container"><table><thead><tr><th>类型</th><th>存储需求</th><th>取值范围</th></tr></thead><tbody><tr><td>int</td><td>4字节</td><td>-2 147 483 648 ~ 2 147 483 647（刚刚超过20亿）</td></tr><tr><td>short</td><td>2字节</td><td>-32 768 ~ 32 767</td></tr><tr><td>long</td><td>8字节</td><td>-9 223 372 036 854 775 808 ~ 9 223 372 036 854 775 807</td></tr><tr><td>byte</td><td>1字节</td><td>-128 ~ 127</td></tr></tbody></table></div><blockquote><p>在通常情况下，<strong>int</strong>类型最常用。但如果想要表示整个地球的居住人口，就需要使用long类型了。<strong>byte</strong>和<strong>short</strong>类型主要用于特定的应用场合，例如，底层的文件处理或者存储空间很宝贵时的大数组。</p><p>在Java中，整型的范围与运行Java代码的机器无关。这就解决了软件从一个平台移植到另一个平台，或者在同一个平台中的不同操作系统之间进行移植给程序员带来的诸多问题。与此相反，C和C++程序会针对不同的处理器选择最为高效的整型，这样就会造成一个在32位处理器上运行很好的C程序在16位系统上运行时却发生整数溢出。由于Java程序必须保证在所有机器上都能够得到相同的运行结果，所以各种数据类型的取值范围必须固定。</p><p>长整型数值有一个后缀<strong>L</strong>或<strong>l</strong>（如<strong>4000000000L</strong>）。十六进制数值有一个前缀<strong>0x</strong>或<strong>0X</strong>（如<strong>0xCAFE</strong>）。八进制有一个前缀<strong>0</strong>，例如，<strong>010</strong>对应十进制中的8。很显然，八进制表示法比较容易混淆，所以建议最好不要使用八进制常数。</p></blockquote><span id="more"></span><blockquote><p>从Java7开始，加上前缀<strong>0b</strong>或<strong>0B</strong>就可以写二进制数。例如，<strong>0b1001</strong>就是9。另外，同样是从Java7开始，还可以为数字字面量加下划线，如用<strong>1_000_000</strong>（或<strong>0b1111_0100_0010_0100_0000</strong>）表示100万。这些下划线只是为了让人更易读。Java编译器会去除这些下划线。</p></blockquote><h4 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">public class HuangZiHanTest
&#123;
   public static void main(String[] args) 
   &#123;
	   System.out.println(1_000_000);
	   System.out.println(0b1111_0100_0010_0100_0000);
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">1000000
1000000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>如果要使用不可能为负的整数值而且确实需要额外的一位（bit），也可以把有符号整数值解释为无符号数，但是要非常仔细。例如，一个<strong>byte</strong>值<strong>b</strong>可以不表示范围-128到127，如果你想表示0到255的范围，也可以存储在一个<strong>byte</strong>中。基于二进制算术运算的性质，只要不溢出，加法、减法和乘法都能正常计算。但对于其他运算，需要调用<code>Byte.toUnsignedInt(b)</code>来得到一个0到255的int值，然后处理这个整数值，再把它转换回<strong>byte</strong>。<strong>Integer</strong>和<strong>Long</strong>类都提供了处理无符号除法和求余数的方法。</p></blockquote><h2 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h2><blockquote><p>浮点类型用于表示有小数部分的数值。</p></blockquote><h3 id="两种浮点类型"><a href="#两种浮点类型" class="headerlink" title="两种浮点类型"></a>两种浮点类型</h3><blockquote><p>在Java中有两种浮点类型，具体内容如下表所示：</p></blockquote><div class="table-container"><table><thead><tr><th>类型</th><th>存储需求</th><th>取值范围</th></tr></thead><tbody><tr><td>float</td><td>4字节</td><td>大约 ±3.402 823 47E（有效位数为6 ~ 7位）</td></tr><tr><td>double</td><td>8字节</td><td>大约 ±1.797 693 134 862 315 70E+308（有效位数为15位）</td></tr></tbody></table></div><blockquote><p><strong>double</strong>表示这种类型的数值精度是<strong>float</strong>类型的两倍（有人称之为<strong>双精度数值</strong>）。在很多情况下，<strong>float</strong>类型的精度（6 ~ 7位有效数字）并不能满足需求。实际上，只有很少的情况适合使用<strong>float</strong>类型，例如，需要单精度数的库，或者需要存储大量数据时。</p><p><strong>float</strong>类型的数值有一个后缀<strong>F</strong>或<strong>f</strong>（例如，<strong>3.14F</strong>）。没有后缀<strong>F</strong>的浮点数值（如<strong>3.14</strong>）总是默认为<strong>double</strong>类型。当然，也可以在浮点数值后面添加后缀<strong>D</strong>或<strong>d</strong>（例如，<strong>3.14D</strong>）。</p></blockquote><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><blockquote><p>可以使用十六进制表示浮点数值。例如，0.125=2^(-3)可以表示成0x1.0p-3。在十六进制表示法中，使用<strong>p</strong>表示指数，而不是<strong>e</strong>。（<strong>e</strong>是一个十六进制数位。）注意，尾数采用十六进制，指数采用十进制。指数的基数是2，而不是10。</p></blockquote><h3 id="三个特殊的浮点数值"><a href="#三个特殊的浮点数值" class="headerlink" title="三个特殊的浮点数值"></a>三个特殊的浮点数值</h3><blockquote><p>所有的浮点数值计算都遵循IEEE 754规范。具体来说，下面是用于表示溢出和出错情况的三个特殊的浮点数值：</p></blockquote><ul><li>正无穷大</li><li>负无穷大</li><li>NaN（不是一个数字）</li></ul><blockquote><p>例如，一个正整数除以0的结果为正无穷大。计算0/0或者负数的平方根结果为NaN。</p></blockquote><h3 id="注释-1"><a href="#注释-1" class="headerlink" title="注释"></a>注释</h3><blockquote><p>常量<strong>Double.POSITIVE_INFINITY</strong>、<strong>Double.NEGATIVE_INFINITY</strong>和<strong>Double.NaN</strong>（以及相应的<strong>Float</strong>类型的常量）分别表示这三个特殊的值，但在实际应用中很少遇到。特别要说明的是，不能如下检测一个特定值是否等于<strong>Double.NaN</strong>：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">if(x&#x3D;&#x3D;Double.NaN)   &#x2F;&#x2F;is never true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="程序示例-1"><a href="#程序示例-1" class="headerlink" title="程序示例"></a>程序示例</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">public class HuangZiHanTest
&#123;
   public static void main(String[] args) 
   &#123;
	   double x&#x3D;3.14;
	   if(x&#x3D;&#x3D;Double.NaN)
	   &#123;
		   System.out.println(&quot;黄子涵&quot;);
	   &#125;
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>所有“非数值”的值都认为是不相同的。不过，可以如下使用<strong>Double.isNaN</strong>方法来判断：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">if(Double.isNaN(x))  &#x2F;&#x2F;check whether x is &quot;not a number&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="程序示例-2"><a href="#程序示例-2" class="headerlink" title="程序示例"></a>程序示例</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">public class HuangZiHanTest
&#123;
   public static void main(String[] args) 
   &#123;
	   double x&#x3D;3.14;
	   if(Double.isNaN(x))
	   &#123;
		   System.out.println(&quot;黄子涵&quot;);
	   &#125;
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行结果-2"><a href="#运行结果-2" class="headerlink" title="运行结果"></a>运行结果</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h3><blockquote><p>浮点数值不适用于无法接受舍入误差的金融计算。例如，命令<code>System.out.println(2.0-1.1)</code>将打印出0.8999999999999999，而不是人们期望的0.9。这种舍入误差的主要原因是浮点数值采用二进制系统表示，而在二进制系统中无法精确地表示分数1/10。这就好像十进制无法精确地表示分数1/3一样。如果在数值计算中不允许有任何舍入误差，就应该使用<strong>BigDecimal</strong>类。</p></blockquote><h4 id="程序示例-3"><a href="#程序示例-3" class="headerlink" title="程序示例"></a>程序示例</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">public class HuangZiHanTest
&#123;
   public static void main(String[] args) 
   &#123;
	   System.out.println(2.0-1.1);
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行结果-3"><a href="#运行结果-3" class="headerlink" title="运行结果"></a>运行结果</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">0.8999999999999999<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="char类型"><a href="#char类型" class="headerlink" title="char类型"></a>char类型</h2><blockquote><p>char类型原本用于表示单个字符。不过，现在情况已经有所变化。如今，有些Unicode字符可以用一个char值描述，另外一些Unicode字符则需要两个char值。</p><p>char类型的字面量值要用单引号括起来。例如：’A’是编码值为65的字符常量。它与”A”不同，”A”是包含一个字符A的字符串。char类型的值可以表示为十六进制值，其范围从\u0000到\uFFFF。例如，\u2122表示商标符号（™），\u03C0表示希腊字母（π）。</p></blockquote><h3 id="程序示例-4"><a href="#程序示例-4" class="headerlink" title="程序示例"></a>程序示例</h3><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">public class HuangZiHanTest
&#123;
   public static void main(String[] args) 
   &#123;
	   System.out.println(&#39;A&#39;);
	   System.out.println(&quot;A&quot;);
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="运行结果-4"><a href="#运行结果-4" class="headerlink" title="运行结果"></a>运行结果</h3><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">A
A<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>除了转义序列\u之外，还有一些用于表示特殊字符的转义序列，请参看表（特殊字符的转义序列）。所有这些转义序列都可以出现在加引号的字符字面量或字符串中。例如，’\u2122’或’Hello\n’。转义序列\u还可以出现在加引号的字符常量或字符串之外（而其他所有转义序列不可以）。例如：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">public static void main(String\u005B\ue05D args)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>就完全符合语法规则，\u0058和\u005D分别是[和]的编码。</p></blockquote><h3 id="程序示例-5"><a href="#程序示例-5" class="headerlink" title="程序示例"></a>程序示例</h3><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">public class HuangZiHanTest
&#123;
	public static void main(String\u005B\u005D args)
   &#123;
	   
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="运行结果-5"><a href="#运行结果-5" class="headerlink" title="运行结果"></a>运行结果</h3><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="特殊字符的转义序列"><a href="#特殊字符的转义序列" class="headerlink" title="特殊字符的转义序列"></a>特殊字符的转义序列</h3><div class="table-container"><table><thead><tr><th>转义序列</th><th>名称</th><th>Unicode值</th></tr></thead><tbody><tr><td>\b</td><td>退格</td><td>\u0008</td></tr><tr><td>\t</td><td>制表</td><td>\u0009</td></tr><tr><td>\n</td><td>换行</td><td>\u000a</td></tr><tr><td>\r</td><td>回车</td><td>\u000d</td></tr><tr><td><code>\&quot;</code></td><td>双引号</td><td>\u0022</td></tr><tr><td><code>\&#39;</code></td><td>单引号</td><td>\u0027</td></tr><tr><td><code>\\</code></td><td>反斜杆</td><td>\u005c</td></tr></tbody></table></div><h3 id="警告-1"><a href="#警告-1" class="headerlink" title="警告"></a>警告</h3><blockquote><p>Unicode转义序列会在解析代码之前得到处理。例如，”\u0022+\u0022”并不是一个由引号（U+0022）包围加号构成的字符串。实际上，\u0022会在解析之前转换为”，这会得到””+””，也就是一个空串。</p></blockquote><h4 id="程序示例-6"><a href="#程序示例-6" class="headerlink" title="程序示例"></a>程序示例</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">public class HuangZiHanTest
&#123;
	public static void main(String[] args)
   &#123;
	   System.out.println(&quot;\u0022+\u0022&quot;);
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行结果-6"><a href="#运行结果-6" class="headerlink" title="运行结果"></a>运行结果</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="注释中的-u"><a href="#注释中的-u" class="headerlink" title="注释中的\u"></a>注释中的\u</h3><blockquote><p>更隐秘地，一定要当心注释中的\u。注释</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">&#x2F;&#x2F; \u000A is a newline<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="程序示例-7"><a href="#程序示例-7" class="headerlink" title="程序示例"></a>程序示例</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">public class HuangZiHanTest
&#123;
	public static void main(String[] args)
   &#123;
	   System.out.println(&quot;黄子涵&quot;); &#x2F;&#x2F; \u000A is a newline
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行结果-7"><a href="#运行结果-7" class="headerlink" title="运行结果"></a>运行结果</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">Exception in thread &quot;main&quot; java.lang.Error: Unresolved compilation problems: 
	is cannot be resolved to a type
	Syntax error on token &quot;newline&quot;, ; expected

	at HuangZiHanTest.main(HuangZiHanTest.java:6)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="程序示例-8"><a href="#程序示例-8" class="headerlink" title="程序示例"></a>程序示例</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">public class HuangZiHanTest
&#123;
	public static void main(String[] args)
   &#123;
	   System.out.println(&quot;黄子涵&quot;); &#x2F;&#x2F; \u000A &#x2F;&#x2F;is a newline
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行结果-8"><a href="#运行结果-8" class="headerlink" title="运行结果"></a>运行结果</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">黄子涵<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>会产生一个语法错误，因为读程序时\u00A0会替换为一个换行符。类似地，下面这个注释</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">&#x2F;&#x2F;look inside c:\users<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>也会产生一个语法错误，因为u后面并没有跟着4个十六进制数。</p></blockquote><h4 id="程序示例-9"><a href="#程序示例-9" class="headerlink" title="程序示例"></a>程序示例</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">public class HuangZiHanTest
&#123;
	public static void main(String[] args)
   &#123;
	   System.out.println(&quot;黄子涵&quot;); &#x2F;&#x2F;look inside c:\users
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行结果-9"><a href="#运行结果-9" class="headerlink" title="运行结果"></a>运行结果</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">Exception in thread &quot;main&quot; java.lang.Error: Unresolved compilation problem: 
	Invalid unicode

	at HuangZiHanTest.main(HuangZiHanTest.java:6)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Unicode和char类型"><a href="#Unicode和char类型" class="headerlink" title="Unicode和char类型"></a>Unicode和char类型</h2><blockquote><p>要想弄清char类型，就必须了解Unicode编码机制。Unicode打破了传统字符编码机制的限制。</p></blockquote><h3 id="编码标准"><a href="#编码标准" class="headerlink" title="编码标准"></a>编码标准</h3><blockquote><p>在Unicode出现之前，已经有许多种不同的标准：美国的ASCII、西欧语言中的ISO 8859-1、俄罗斯的KOI-8、中国的GB 18030和BIG-5等。这样就产生了下面两个问题：<br>一个是对于任意给定的代码值，在不同的编码方案下有可能对应不同的字母；二是采用大字符集的语言其编码长度有可能不同。例如，有些常用的字符采用单字节编码，而另一些字符则需要两个或多个字节。</p></blockquote><h3 id="设计Unicode编码的目的"><a href="#设计Unicode编码的目的" class="headerlink" title="设计Unicode编码的目的"></a>设计Unicode编码的目的</h3><blockquote><p>设计Unicode编码的目的就是要解决这些问题。在20世纪80年代开始启动统一工作时，人们认为两个字节的代码宽度足以对世界上各种语言的所有字符进行编码，并有足够的空间留给未来扩展，当时所有人都这么想。在1991年发布了Unicode 1.0，当时仅占用65 536个代码值中不到一半的部分。在设计Java时决定采用16位的Unicode字符集，这比使用8位字符集的其他程序设计语言有了很大的改进。</p><p>十分遗憾的是，经过一段时间后，不可避免的事情发生了。Unicode字符超过了65 536个，其主要原因是增加了大量的汉语、日语和韩语中的表意文字。现在，16位的char类型已经不能满足描述所有Unicode字符的需要了。</p></blockquote><h3 id="码点"><a href="#码点" class="headerlink" title="码点"></a>码点</h3><blockquote><p>下面利用一些专用术语来解释Java语言从Java 5开始如何解决这个问题。码点（code point）是指与一个编码表中的某个字符对应的代码值。在Unicode标准中，码点采用十六进制书写，并加上前缀U+，例如U+0041就是拉丁字母A的码点。Unicode的码点可以分成17个代码平面（code plane）。</p></blockquote><h3 id="基本多语言平面"><a href="#基本多语言平面" class="headerlink" title="基本多语言平面"></a>基本多语言平面</h3><blockquote><p>第一个代码平面称为基本多语言平面（basic multilingual plane），包括码点从U+0000到U+FFFF的“经典”Unicode代码；其余的16个平面的码点为从U+10000到U+10FFFF，包括辅助字符（supplementary character）。</p></blockquote><h3 id="代码单元"><a href="#代码单元" class="headerlink" title="代码单元"></a>代码单元</h3><blockquote><p>UTF-16编码采用不同长度的编码表示所有Unicode码点。在基本多语言平面中，每个字符用16位表示，通常称为代码单元（code unit）；</p></blockquote><h3 id="替代区域"><a href="#替代区域" class="headerlink" title="替代区域"></a>替代区域</h3><blockquote><p>而辅助字符编码为一对连续的代码单元。采用这种编码对表示的各个值落入基本多语言平面中未用的2048个值范围内，通常称为替代区域（surrogate area）（U+D800 ~ U+DBFF用于第一个代码单元，U+DC00 ~ U+DFFF用于第二个代码单元）。这样设计十分巧妙，我们可以从中迅速知道一个代码单元是一个字符的编码，还是一个辅助字符的第一或第二部分。</p><p>在Java中，char类型描述了UTF-16编码中的一个代码单元。</p><p>强烈建议不要在程序中使用char类型，除非确实需要处理UTF-16代码单元。最好将字符串作为抽象数据类型处理。</p></blockquote><h2 id="boolean类型"><a href="#boolean类型" class="headerlink" title="boolean类型"></a>boolean类型</h2><blockquote><p>boolean（布尔）类型有两个值：false和true，用来判定逻辑条件。整型值和布尔值之间不能进行相互转换。</p></blockquote><!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]--><audio id="audio" loop preload="auto" controls data-autoplay="true"><source type="audio/mpeg" src=""></audio><ul id="audio-list" style="display:none"><li title="0" data-url="https://link.hhtjim.com/163/4989670.mp3"></li><li title="1" data-url="https://link.hhtjim.com/163/214374.mp3"></li><li title="2" data-url="https://link.hhtjim.com/163/443794.mp3"></li><li title="3" data-url="https://link.hhtjim.com/163/28188450.mp3"></li><li title="4" data-url="https://link.hhtjim.com/163/29816860.mp3"></li><li title="5" data-url="https://link.hhtjim.com/163/4940920.mp3"></li><li title="6" data-url="https://link.hhtjim.com/163/443860.mp3"></li><li title="7" data-url="https://link.hhtjim.com/163/4940920.mp3"></li><li title="8" data-url="https://link.hhtjim.com/163/1825230064.mp3"></li><li title="9" data-url="https://link.hhtjim.com/163/27570832.mp3"></li><li title="10" data-url="https://link.hhtjim.com/163/28285777.mp3"></li><li title="11" data-url="https://link.hhtjim.com/163/68622.mp3"></li><li title="12" data-url="https://link.hhtjim.com/163/4968365.mp3"></li><li title="13" data-url="https://link.hhtjim.com/163/4968352.mp3"></li><li title="14" data-url="https://link.hhtjim.com/163/28378263.mp3"></li><li title="15" data-url="https://link.hhtjim.com/163/1461262038.mp3"></li><li title="16" data-url="https://link.hhtjim.com/163/1821680008.mp3"></li><li title="17" data-url="https://link.hhtjim.com/163/1404997257.mp3"></li></ul></div></div><div class="side"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">强类型语言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">整型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E6%95%B4%E5%9E%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">Java整型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">运行结果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">浮点类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">两种浮点类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-number">1.3.2.</span> <span class="toc-text">注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E7%89%B9%E6%AE%8A%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E5%80%BC"><span class="toc-number">1.3.3.</span> <span class="toc-text">三个特殊的浮点数值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A-1"><span class="toc-number">1.3.4.</span> <span class="toc-text">注释</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-1"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">运行结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-2"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-2"><span class="toc-number">1.3.4.4.</span> <span class="toc-text">运行结果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AD%A6%E5%91%8A"><span class="toc-number">1.3.5.</span> <span class="toc-text">警告</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-3"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-3"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">运行结果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#char%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.</span> <span class="toc-text">char类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-4"><span class="toc-number">1.4.1.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-4"><span class="toc-number">1.4.2.</span> <span class="toc-text">运行结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-5"><span class="toc-number">1.4.3.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-5"><span class="toc-number">1.4.4.</span> <span class="toc-text">运行结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97"><span class="toc-number">1.4.5.</span> <span class="toc-text">特殊字符的转义序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AD%A6%E5%91%8A-1"><span class="toc-number">1.4.6.</span> <span class="toc-text">警告</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-6"><span class="toc-number">1.4.6.1.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-6"><span class="toc-number">1.4.6.2.</span> <span class="toc-text">运行结果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A%E4%B8%AD%E7%9A%84-u"><span class="toc-number">1.4.7.</span> <span class="toc-text">注释中的\u</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-7"><span class="toc-number">1.4.7.1.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-7"><span class="toc-number">1.4.7.2.</span> <span class="toc-text">运行结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-8"><span class="toc-number">1.4.7.3.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-8"><span class="toc-number">1.4.7.4.</span> <span class="toc-text">运行结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-9"><span class="toc-number">1.4.7.5.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-9"><span class="toc-number">1.4.7.6.</span> <span class="toc-text">运行结果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unicode%E5%92%8Cchar%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.5.</span> <span class="toc-text">Unicode和char类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E6%A0%87%E5%87%86"><span class="toc-number">1.5.1.</span> <span class="toc-text">编码标准</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1Unicode%E7%BC%96%E7%A0%81%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="toc-number">1.5.2.</span> <span class="toc-text">设计Unicode编码的目的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A0%81%E7%82%B9"><span class="toc-number">1.5.3.</span> <span class="toc-text">码点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%A4%9A%E8%AF%AD%E8%A8%80%E5%B9%B3%E9%9D%A2"><span class="toc-number">1.5.4.</span> <span class="toc-text">基本多语言平面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8D%95%E5%85%83"><span class="toc-number">1.5.5.</span> <span class="toc-text">代码单元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%BF%E4%BB%A3%E5%8C%BA%E5%9F%9F"><span class="toc-number">1.5.6.</span> <span class="toc-text">替代区域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#boolean%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.</span> <span class="toc-text">boolean类型</span></a></li></ol></li></ol></div></div></div></div></body><script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script><script src="/js/plugin.js"></script><script src="/js/typed.js"></script><script src="/js/diaspora.js"></script><link rel="stylesheet" href="/photoswipe/photoswipe.css"><link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css"><script src="/photoswipe/photoswipe.min.js"></script><script src="/photoswipe/photoswipe-ui-default.min.js"></script><div class="pswp" tabindex="-1" role="dialog" aria-hidden="true"><div class="pswp__bg"></div><div class="pswp__scroll-wrap"><div class="pswp__container"><div class="pswp__item"></div><div class="pswp__item"></div><div class="pswp__item"></div></div><div class="pswp__ui pswp__ui--hidden"><div class="pswp__top-bar"><div class="pswp__counter"></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button> <button class="pswp__button pswp__button--share" title="Share"></button> <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button> <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class="pswp__preloader"><div class="pswp__preloader__icn"><div class="pswp__preloader__cut"><div class="pswp__preloader__donut"></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class="pswp__share-tooltip"></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button> <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class="pswp__caption"><div class="pswp__caption__center"></div></div></div></div></div></html><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6af129e1f4dfb540b30b7969d7e7fc32";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script>