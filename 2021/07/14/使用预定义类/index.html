<!DOCTYPE html><html lang="zh-CN" class="loading"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><title>使用预定义类 - 黄子涵</title><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="google" content="notranslate"><meta name="keywords" content="黄子涵,"><meta name="description" content="使用预定义类
在Java中，没有类就无法做任何事情。然而，并不是所有的类都表现出面向对象的典型特征。例如，Math类，可以直接使用Math类的方法，如Math.random，而不必了解它具体是如何实,"><meta name="author" content="黄子涵"><link rel="alternative" href="atom.xml" title="黄子涵" type="application/atom+xml"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="/css/diaspora.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><meta name="generator" content="Hexo 5.4.0"><link rel="stylesheet" href="/css/prism-atom-dark.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script>
<script src="/js/prism-line-numbers.min.js"></script></head><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><body class="loading"><span id="config-title" style="display:none">黄子涵</span><div id="loader"></div><div id="single"><div id="top" style="display:block"><div class="bar" style="width:0"></div><a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://www.huangzihan.top"></a><div title="播放/暂停" class="iconfont icon-play"></div><h3 class="subtitle">使用预定义类</h3><div class="social"><div><div class="share"><a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a></div><div id="qr"></div></div></div><div class="scrollbar"></div></div><div class="section"><div class="article"><div class="main"><h1 class="title">使用预定义类</h1><div class="stuff"><span>七月 14, 2021</span></div><div class="content markdown"><h1 id="使用预定义类"><a href="#使用预定义类" class="headerlink" title="使用预定义类"></a>使用预定义类</h1><blockquote><p>在Java中，没有类就无法做任何事情。然而，并不是所有的类都表现出面向对象的典型特征。例如，<strong>Math</strong>类，可以直接使用<strong>Math</strong>类的方法，如<strong>Math.random</strong>，而不必了解它具体是如何实现的，你只需要知道方法名和参数（如果有的话）。这正是封装的关键所在，当然所有类都是这样。但<strong>Math</strong>类<strong>只</strong>封装了功能，它不需要也不必隐藏数据。由于没有数据，因此也不必考虑创建对象和初始化它们的实例字段，因为根本没有实例字段！</p></blockquote><h2 id="对象与对象变量"><a href="#对象与对象变量" class="headerlink" title="对象与对象变量"></a>对象与对象变量</h2><h3 id="构造器（constructor，或称构造函数）"><a href="#构造器（constructor，或称构造函数）" class="headerlink" title="构造器（constructor，或称构造函数）"></a>构造器（constructor，或称构造函数）</h3><blockquote><p>要想使用对象，首先必须构造对象，并指定其初始状态。然后对对象应用方法。</p><p>在Java程序设计语言中，要使用<strong>构造器</strong>（constructor，或称<strong>构造函数</strong>）构造新实例。构造器是一种特殊的方法，用来构造并初始化对象。下面看一个例子。在标准Java库中包含一个<strong>Date</strong>类。它的对象可以描述一个时间点，例如，“December 31,1999,23:59:59 GMT”。</p></blockquote><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><blockquote><p>你可能会感到奇怪：为什么用类描述时间，而不像其他语言那样用一个内置的（built-in）类型？例如，在Visual Basic中有一个内置的<strong>date</strong>类型，程序员可以采用#6/1/1995#的格式指定日期。从表面上看这似乎很方便，因为程序员只需要使用内置的<strong>date</strong>类型，而不必为设计类而操心。但实际上，Visual Basic这样设计的适应性如何呢？在有些地区，日期表示为月/日/年，而另一些地区则表示为日/月/年。语言设计者是否能够预见这些问题呢？如果没有处理好这类问题，语言就有可能陷入混乱，对此感到不满的程序员也会丧失使用这种语言的热情。如果使用类，这些设计任务就交给了类库的设计者。如果类设计得不完善，其他的程序员可以很容易地编写自己的类，以便增强或替代（replace）系统提供的类（作为印证：Java的日期类库开始时有些混乱，现在已经重新设计了两次）。</p></blockquote><h4 id="构造器的名字与类名相同"><a href="#构造器的名字与类名相同" class="headerlink" title="构造器的名字与类名相同"></a>构造器的名字与类名相同</h4><blockquote><p>构造器的名字应该与类名相同。因此<strong>Date</strong>类的构造器名为<strong>Date</strong>。要想构造一个<strong>Date</strong>对象，需要在构造器前面加上<strong>new</strong>操作符，如下所示：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">new Date()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>这个表达式构造了一个新对象。这个对象被初始化为当前的日期和时间。</p><p>如果需要的话，也可以将这个对象传递给一个方法：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">System.out.println(new Date());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><span id="more"></span><h5 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h5><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">public class HuangZiHanTest
&#123;  
   public static void main(String[] args)
   &#123;
	   new Date();
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h5><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">Exception in thread &quot;main&quot; java.lang.Error: Unresolved compilation problem: 
	Date cannot be resolved to a type

	at HuangZiHanTest.main(HuangZiHanTest.java:7)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="程序示例-1"><a href="#程序示例-1" class="headerlink" title="程序示例"></a>程序示例</h5><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">public class HuangZiHanTest
&#123;  
   public static void main(String[] args)
   &#123;
	   new HuangZiHanTest();
	   System.out.println(new HuangZiHanTest());
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h5><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">HuangZiHanTest@24d46ca6<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h3><blockquote><p>或者，也可以对刚刚创建的对象应用一个方法。<strong>Date</strong>类中有一个<strong>toString</strong>方法。这个方法将返回日期的字符串描述。下面的语句可以说明如何对新构造的<strong>Date</strong>对象应用<strong>toString</strong>方法。</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">String s&#x3D;new Date().toString();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="对象变量"><a href="#对象变量" class="headerlink" title="对象变量"></a>对象变量</h3><blockquote><p>在这两个例子中，构造的对象仅使用了一次。通常，你会希望构造的对象可以多次使用，因此，需要将对象存放在一个变量中：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">Date birthday&#x3D;new Date();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="创建一个新对象"><a href="#创建一个新对象" class="headerlink" title="创建一个新对象"></a>创建一个新对象</h4><blockquote><p>图（创建一个新对象）显示了对象变量<strong>birthday</strong>，它引用了新构造的对象。</p></blockquote><center><img src="/2021/07/14/%E4%BD%BF%E7%94%A8%E9%A2%84%E5%AE%9A%E4%B9%89%E7%B1%BB/创建一个新对象.png" width="50%" height="50%"> 创建一个新对象</center><h5 id="程序示例-2"><a href="#程序示例-2" class="headerlink" title="程序示例"></a>程序示例</h5><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">public class HuangZiHanTest
&#123;  
   public static void main(String[] args)
   &#123;
	   new HuangZiHanTest();
	   System.out.println(new HuangZiHanTest());
	   System.out.println();
	   
	   String huangzihan&#x3D;new HuangZiHanTest().toString();
	   System.out.println(huangzihan);
	   System.out.println();
	   
	   HuangZiHanTest Huangzihan&#x3D;new HuangZiHanTest();
	   System.out.println(Huangzihan);
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="运行结果-2"><a href="#运行结果-2" class="headerlink" title="运行结果"></a>运行结果</h5><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">HuangZiHanTest@24d46ca6

HuangZiHanTest@4517d9a3

HuangZiHanTest@372f7a8d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="对象与对象变量-1"><a href="#对象与对象变量-1" class="headerlink" title="对象与对象变量"></a>对象与对象变量</h4><blockquote><p>在对象与对象变量之间存在着一个重要的区别。例如，以下语句</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">Date deadline;    &#x2F;&#x2F;deadline doesn&#39;t refer to any object<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>定义了一个对象变量<strong>deadline</strong>，它可以引用<strong>Date</strong>类型的对象。但是，一定要认识到：变量<strong>deadline不是一个对象</strong>，而且实际上它也没有引用任何对象。此时还不能在这个变量上使用任何<strong>Date</strong>方法。下面的语句</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">s &#x3D; deadline.toString();    &#x2F;&#x2F;not yet<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>将产生编译错误。</p></blockquote><h5 id="程序示例-3"><a href="#程序示例-3" class="headerlink" title="程序示例"></a>程序示例</h5><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">public class HuangZiHanTest
&#123;  
   public static void main(String[] args)
   &#123;
	   HuangZiHanTest shuai_ge;
	   huangzihan &#x3D; shuai_ge.toString();
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="运行结果-3"><a href="#运行结果-3" class="headerlink" title="运行结果"></a>运行结果</h5><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">Exception in thread &quot;main&quot; java.lang.Error: Unresolved compilation problem: 
	huangzihan cannot be resolved to a variable

	at HuangZiHanTest.main(HuangZiHanTest.java:8)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>必须首先初始化变量<strong>deadline</strong>，这里有两个选择。当然，可以初始化这个变量，让它引用一个新构造的对象：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">deadline &#x3D; new Date();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>也可以设置这个变量，让它引用一个已有的对象：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">deadline &#x3D; birthday;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="程序示例-4"><a href="#程序示例-4" class="headerlink" title="程序示例"></a>程序示例</h5><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">public class HuangZiHanTest
&#123;  
   public static void main(String[] args)
   &#123;
	   HuangZiHanTest shuai_ge;
	   HuangZiHanTest Huangzihan&#x3D;new HuangZiHanTest();
	   shuai_ge&#x3D;new HuangZiHanTest();
	   String huangzihan &#x3D; shuai_ge.toString();
	   System.out.println(huangzihan);
	   System.out.println();
       System.out.println(Huangzihan);
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="运行结果-4"><a href="#运行结果-4" class="headerlink" title="运行结果"></a>运行结果</h5><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">HuangZiHanTest@24d46ca6

HuangZiHanTest@4517d9a3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="引用同一个对象的对象变量"><a href="#引用同一个对象的对象变量" class="headerlink" title="引用同一个对象的对象变量"></a>引用同一个对象的对象变量</h4><blockquote><p>现在，这两个变量都引用<strong>同一</strong>个对象（请参见图（引用同一个对象的对象变量））。</p></blockquote><center><img src="/2021/07/14/%E4%BD%BF%E7%94%A8%E9%A2%84%E5%AE%9A%E4%B9%89%E7%B1%BB/引用同一个对象的对象变量.png" width="50%" height="50%"> 引用同一个对象的对象变量</center><blockquote><p>要认识到重要的一点：对象变量并没有实际包含一个对象，它只是<strong>引用</strong>一个对象。</p><p>在Java中，任何对象变量的值都是对存储在另外一个地方的某个对象的引用。<strong>new</strong>操作符的返回值也是一个引用。下面的语句：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">Date deadline &#x3D; new Date();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>有两个部分。表达式<code>new Date()</code>构造了一个<strong>Date</strong>类型的对象，它的值是对新创建对象的一个引用。这个引用存储在变量<strong>deadline</strong>中。</p></blockquote><h5 id="程序示例-5"><a href="#程序示例-5" class="headerlink" title="程序示例"></a>程序示例</h5><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">public class HuangZiHanTest
&#123;  
   public static void main(String[] args)
   &#123;
	   HuangZiHanTest shuai_ge&#x3D;new HuangZiHanTest();
	   HuangZiHanTest huangzihan&#x3D;new HuangZiHanTest();
	   System.out.println(shuai_ge);
	   System.out.println(huangzihan);
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="运行结果-5"><a href="#运行结果-5" class="headerlink" title="运行结果"></a>运行结果</h5><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">HuangZiHanTest@24d46ca6
HuangZiHanTest@4517d9a3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="对象变量设置为null"><a href="#对象变量设置为null" class="headerlink" title="对象变量设置为null"></a>对象变量设置为null</h4><blockquote><p>可以显式地将对象变量设置为<strong>null</strong>，指示这个对象变量目前没有引用任何对象。</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">deadline &#x3D; null;
. . .
if(deadline !&#x3D; null)
   System.out.println(deadline);
&#96;&#96;&#96;   

##### 程序示例

&#96;&#96;&#96;C&#x2F;C++
public class HuangZiHanTest
&#123;  
   public static void main(String[] args)
   &#123;
	   HuangZiHanTest shuai_ge&#x3D;new HuangZiHanTest();
	   HuangZiHanTest huangzihan&#x3D;new HuangZiHanTest();
	   System.out.println(shuai_ge);
	   System.out.println(huangzihan);
	   
	   System.out.println();
	   
	   shuai_ge&#x3D;null;
	   huangzihan&#x3D;null;
	   System.out.println(shuai_ge);
	   System.out.println(huangzihan);
	   
	   System.out.println();
	   
	   if(shuai_ge&#x3D;&#x3D;null)
	   &#123;
		   System.out.println(&quot;黄子涵是帅哥！&quot;);
	   &#125;
	   	   
	   if(huangzihan&#x3D;&#x3D;null)
	   &#123;
		   System.out.println(&quot;黄子涵是帅哥！&quot;);
	   &#125;	   
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="运行结果-6"><a href="#运行结果-6" class="headerlink" title="运行结果"></a>运行结果</h5><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">HuangZiHanTest@24d46ca6
HuangZiHanTest@4517d9a3

null
null

黄子涵是帅哥！
黄子涵是帅哥！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Java类库中的LocalDate类"><a href="#Java类库中的LocalDate类" class="headerlink" title="Java类库中的LocalDate类"></a>Java类库中的LocalDate类</h2><blockquote><p>在前面的例子中，已经使用了Java标准类库中的<strong>Date</strong>类。<strong>Date</strong>类的实例有一个状态，即<strong>特定的时间点</strong>。</p></blockquote><h3 id="纪元"><a href="#纪元" class="headerlink" title="纪元"></a>纪元</h3><blockquote><p>尽管在使用Date类时不必知道这一点，但时间是用距离一个固定时间点的毫秒数（可正可负）表示的，这个时间点就是所谓的<strong>纪元</strong>（epoch），它是UTC时间1970年1月1日00:00:00。UTC就是Coordinated Universal<br>Time（国际协调时间），与大家熟悉的GMT（即Greenwich Mean Time，格林尼治时间）一样，是一种实用的科学标准时间。</p><p>但是，<strong>Date</strong>类对于处理人类记录日期的日历信息并不是很有用，如“December 31，1999”。这种特定的日期描述遵循了世界上大多数地区使用的Gregorian阳历。但是，同样的这个时间点采用中国或希伯来的阴历来描述就很不一样了，倘若我们有来自火星的顾客，基于他们使用的火星历来描述这个时间点就更不一样了。</p><p>类库设计者决定将保存时间与给时间点命名分开。所以标准Java类库分别包含了两个类：一个是用来表示时间点的<strong>Date</strong>类；另一个是用大家熟悉的日历表示法表示日期的<strong>LocalDate</strong>类。</p><p>将时间度量与日历分开是一种很好的面向对象设计。通常，最好使用不同的类表示不同的概念。</p></blockquote><h3 id="静态工厂方法（factory-method）"><a href="#静态工厂方法（factory-method）" class="headerlink" title="静态工厂方法（factory method）"></a>静态工厂方法（factory method）</h3><blockquote><p>不要使用构造器来构造<strong>LocalDate</strong>类的对象。实际上，应当使用静态<strong>工厂方法</strong>（factory method），它会代表你调用构造器。下面的表达式：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">LocalDate.now()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>会构造一个新对象，表示构造这个对象时的日期。</p><p>可以提供年、月和日来构造对应一个特定日期的对象：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">LocalDate.of(1999,12,31)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>当然，通常我们都希望将构造的对象保存在一个对象变量中：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">LocalDate newYearsEve &#x3D; LocalDate.of(1999,12,31);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>一旦有了一个<strong>LocalDate</strong>对象，可以用方法<strong>getYear</strong>、<strong>getMonthValue</strong>和<strong>getDayOfMonth</strong>得到年、月和日：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">int year &#x3D; newYearsEve.getYear();          &#x2F;&#x2F;1999
int month &#x3D; newYearsEve.getMonthValue();   &#x2F;&#x2F;12
int day &#x3D; newYearsEve.getDayOfMonth();     &#x2F;&#x2F;31<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>看起来这似乎没有多大的意义，因为这正是构造对象时使用的那些值。不过，有时可能有一个计算得到的日期，然后你希望调用这些方法来了解它的更多信息。例如，<strong>plusDays</strong>方法会得到一个新的<strong>LocalDate</strong>，如果把应用这个方法的对象称为当前对象，这个新日期对象则是距当前对象指定天数的一个新日期：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">LocalDate aThousandDaysLater &#x3D; newYearsEve.plusDays(1000);
year &#x3D; aThousandDaysLater.getYear();          &#x2F;&#x2F;2002
month &#x3D; aThousandDaysLater.getMonthValue();   &#x2F;&#x2F;09
day &#x3D; aThousandDaysLater.getDayOfMonth();     &#x2F;&#x2F;26<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>LocalDate</strong>类封装了实例字段来维护所设置的日期。如果不查看源代码，就不可能知道类内部的日期表示。当然，封装的意义就在于内部表示并不重要，重要的是类对外提供的方法。</p></blockquote><h4 id="程序示例-6"><a href="#程序示例-6" class="headerlink" title="程序示例"></a>程序示例</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">import java.time.LocalDate;

public class HuangZiHanTest
&#123;  
   public static void main(String[] args)
   &#123;
	   LocalDate.now();
	   System.out.println(LocalDate.now());
	   System.out.println();
	   
	   LocalDate.of(1949, 10, 01);
	   System.out.println(LocalDate.of(1949, 10, 01));
	   System.out.println();
	   
	   LocalDate huangzihan_NationalDay&#x3D;LocalDate.of(2021, 10, 01);
	   System.out.println(huangzihan_NationalDay);
	   System.out.println();
	   
	   int huangzihan_year &#x3D; huangzihan_NationalDay.getYear();
	   int huangzihan_month &#x3D; huangzihan_NationalDay.getMonthValue();
	   int huangzihan_day &#x3D; huangzihan_NationalDay.getDayOfMonth();
	   System.out.println(huangzihan_year);
	   System.out.println(huangzihan_month);
	   System.out.println(huangzihan_day);
	   System.out.println();
	   
	   LocalDate aThousandDaysLater &#x3D; huangzihan_NationalDay.plusDays(1000);
	   int Huangzihan_year &#x3D; aThousandDaysLater.getYear();          
	   int Huangzihan_month &#x3D; aThousandDaysLater.getMonthValue();   
	   int Huangzihan_day &#x3D; aThousandDaysLater.getDayOfMonth();
	   System.out.println(Huangzihan_year);
	   System.out.println(Huangzihan_month);
	   System.out.println(Huangzihan_day);
	   System.out.println();
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行结果-7"><a href="#运行结果-7" class="headerlink" title="运行结果"></a>运行结果</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">2021-07-05

1949-10-01

2021-10-01

2021
10
1

2024
6
27<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="注释-1"><a href="#注释-1" class="headerlink" title="注释"></a>注释</h3><blockquote><p>实际上，<strong>Date</strong>类也有得到日、月、年的方法，分别是<strong>getDay</strong>、<strong>getMonth</strong>以及<strong>getYear</strong>，不过这些方法<strong>已经废弃</strong>。当类库设计者意识到某个方法最初就不该引入时，就把它标记为废弃，不鼓励使用。</p><p>类库设计者意识到应当单独提供类来处理日历，不过在此之前这些方法已经是<strong>Date</strong>类的一部分了。Java 1.1中引入较早的一组日历类时，<strong>Date</strong>方法被标为废弃不用。虽然仍然可以在程序中使用这些方法，不过如果这样做，编译时会出现警告。最好还是不要使用这些废弃的方法，因为将来的某个类库版本很有可能会将它们完全删除。</p></blockquote><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><blockquote><p>JDK提供了<strong>jdeprscan</strong>工具来检查你的代码中是否使用了Java API已经废弃的特性。有关说明参见<strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/9/tools/jdeprscan.htm">https://docs.oracle.com/javase/9/tools/jdeprscan.htm</a></strong>。</p></blockquote><h2 id="更改器方法与访问器方法"><a href="#更改器方法与访问器方法" class="headerlink" title="更改器方法与访问器方法"></a>更改器方法与访问器方法</h2><blockquote><p>再来看上一节中的<strong>plusDays</strong>方法调用：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">LocalDate aThousandDaysLater &#x3D; newYearsEve.plusDays(1000);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>这个调用之后<strong>newYearsEve</strong>会有什么变化？它会改为1000天之后的日期吗？事实上，并没有。<strong>plusDays</strong>方法会生成一个新的<strong>LocalDate</strong>对象，然后把这个新对象赋给<strong>aThousandDaysLater</strong>变量。原来的对象不做任何改动。我们说<strong>plusDays</strong>方法没有<strong>更改</strong>调用这个方法的对象。（这类似于<strong>String</strong>类的<strong>toUpperCase</strong>方法。在一个字符串上调用<strong>toUpperCase</strong>时，这个字符串仍保持不变，会返回一个将字符大写的新字符串。）</p></blockquote><h3 id="程序示例-7"><a href="#程序示例-7" class="headerlink" title="程序示例"></a>程序示例</h3><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">import java.time.LocalDate;

public class HuangZiHanTest
&#123;  
   public static void main(String[] args)
   &#123;
	   LocalDate.now();
	   System.out.println(LocalDate.now());
	   System.out.println();
	   
	   LocalDate.of(1949, 10, 01);
	   System.out.println(LocalDate.of(1949, 10, 01));
	   System.out.println();
	   
	   LocalDate huangzihan_NationalDay&#x3D;LocalDate.of(2021, 10, 01);
	   System.out.println(huangzihan_NationalDay);
	   System.out.println();
	   
	   int huangzihan_year &#x3D; huangzihan_NationalDay.getYear();
	   int huangzihan_month &#x3D; huangzihan_NationalDay.getMonthValue();
	   int huangzihan_day &#x3D; huangzihan_NationalDay.getDayOfMonth();
	   System.out.println(huangzihan_year);
	   System.out.println(huangzihan_month);
	   System.out.println(huangzihan_day);
	   System.out.println();
	   
	   LocalDate aThousandDaysLater &#x3D; huangzihan_NationalDay.plusDays(1000);
	   int Huangzihan_year &#x3D; aThousandDaysLater.getYear();          
	   int Huangzihan_month &#x3D; aThousandDaysLater.getMonthValue();   
	   int Huangzihan_day &#x3D; aThousandDaysLater.getDayOfMonth();
	   System.out.println(Huangzihan_year);
	   System.out.println(Huangzihan_month);
	   System.out.println(Huangzihan_day);
	   System.out.println(huangzihan_NationalDay);
	   System.out.println(aThousandDaysLater);
	   System.out.println();
   &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="运行结果-8"><a href="#运行结果-8" class="headerlink" title="运行结果"></a>运行结果</h3><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">2021-07-05

1949-10-01

2021-10-01

2021
10
1

2024
6
27

2021-10-01
2024-06-27<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="GregorianCalendar"><a href="#GregorianCalendar" class="headerlink" title="GregorianCalendar"></a>GregorianCalendar</h3><blockquote><p>Java库的一个较早版本曾经有另一个处理日历的类，名为<strong>GregorianCalendar</strong>。可以如下为这个类表示的一个日期增加1000天：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">GregorianCalendar someDay &#x3D; new GregorianCalendar(1999,11,31);
  &#x2F;&#x2F;odd feature of that class:month numbers go from 0 to 11
someDay.add(Calendar.DAY_OF_MONTH,1000);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>与<strong>LocalDate.plusDays</strong>方法不同，<strong>GregorianCalendar.add</strong>方法是一个<strong>更改器方法</strong>（mutator method）。调用这个方法后，<strong>someDay</strong>对象的状态会改变。可以如下查看新状态：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">year &#x3D; someDay.get(Calendar.YEAR);         &#x2F;&#x2F;2002
month &#x3D; someDay.get(Calendar.MONTH)+1;     &#x2F;&#x2F;09
day &#x3D; someDay.get(Calendar.DAY_OF_MONTH);  &#x2F;&#x2F;26<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>正是因为这个原因，我们将变量命名为<strong>someDay</strong>而不是<strong>newYearsEve</strong>——调用这个更改器方法之后，它不再是新年前夜。</p></blockquote><h4 id="程序示例-8"><a href="#程序示例-8" class="headerlink" title="程序示例"></a>程序示例</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">import java.util.Calendar;
import java.util.GregorianCalendar;

public class HuangZiHanTest
&#123;  
   public static void main(String[] args)
   &#123;
	   GregorianCalendar huangzihanDay &#x3D; new GregorianCalendar(2021,07,05);
	   huangzihanDay.add(Calendar.DAY_OF_MONTH,1000);
	   
	   int huangzihan_year &#x3D; huangzihanDay.get(Calendar.YEAR);         
	   int huangzihan_month &#x3D; huangzihanDay.get(Calendar.MONTH)+1;     
	   int huangzihan_day &#x3D; huangzihanDay.get(Calendar.DAY_OF_MONTH);  
	   
	   System.out.println(huangzihan_year);
	   System.out.println(huangzihan_month);
	   System.out.println(huangzihan_day);
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行结果-9"><a href="#运行结果-9" class="headerlink" title="运行结果"></a>运行结果</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">2024
5
1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="访问器方法（accessor-method）"><a href="#访问器方法（accessor-method）" class="headerlink" title="访问器方法（accessor method）"></a>访问器方法（accessor method）</h3><blockquote><p>相反，只访问对象而不修改对象的方法有时称为<strong>访问器方法</strong>（accessor method）。例如，<strong>LocalDate.getYear</strong>和<strong>GregorianCalendar.get</strong>就是访问器方法。</p><p>下面用一个应用<strong>LocalDate</strong>类的程序来结束本节内容的介绍。这个程序将显示当前月的日历，其格式为：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">Mon Tue Wed Thu Fri Sat Sun
                        1 
2   3   4   5   6   7   8
9   10  11  12  13  14  15
16  17  18  19  20  21  22 
23  24  25  26* 27  28  29
30<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>当前日期用一个*号标记。可以看到，这个程序需要知道如何计算某月份的天数以及一个给定日期相应是星期几。</p><p>下面看一下这个程序的关键步骤。首先构造一个对象，并用当前的日期初始化。</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">LocalDate date&#x3D;LocalDate.now();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>下面获得当前的月份和日期。</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">int month &#x3D; date. getMonthValue();
int today &#x3D; date.getDayOfMonth();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>然后，将<strong>date</strong>设置为这个月的第一天，并得到这一天为星期几。</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">date &#x3D; date.minusDays(today - 1);   &#x2F;&#x2F;set to start of month 
DayOfWeek weekday &#x3D; date.getDayOfweek();
int value &#x3D; weekday.getValue();  &#x2F;&#x2F; 1 &#x3D; Monday, . . ., 7 &#x3D; Sunday<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>变量<strong>weekday</strong>设置为<strong>DayOfWeek</strong>类型的对象。我们调用这个对象的<strong>getValue</strong>方法来得到星期几的一个数值。这会得到一个整数，这里遵循国际惯例，即周末是一周的末尾，星期一就返回1，星期二返回2，依此类推。星期日则返回7。</p><p>注意，日历的第一行是缩进的，这样可使月份的第一天指向相应的星期几。下面的代码会打印表头和第一行的缩进：</p></blockquote><center><img src="/2021/07/14/%E4%BD%BF%E7%94%A8%E9%A2%84%E5%AE%9A%E4%B9%89%E7%B1%BB/访问器方法程序示例一.png" width="50%" height="50%"> 访问器方法程序示例一</center><blockquote><p>现在我们来打印日历的主体。进入一个循环，其中<strong>date</strong>遍历一个月中的每一天。</p><p>每次迭代时，打印日期值。如果<strong>date</strong>是当前日期，这个日期则用一个 <em>标记。接下来，把<em>*date</em></em>推进到下一天。如果到达新的一周的第一天，则换行打印：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">while(date.getMonthValue() &#x3D;&#x3D; month)
&#123;
    System.out.printf(&quot;%3d&quot;,date.getDayOfMonth());
    if(date.getDayOfMonth() &#x3D;&#x3D; today)
        System.out.print(“*&quot;);
    else 
        System.out.print(&quot; &quot;);
        date &#x3D; date.plusDays(1);
        if(date.getDayOfWeek().getValue() &#x3D;&#x3D; 1)System.out.println();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>什么时候结束呢？我们不知道这个月有几天，是31天、30天、29天还是28天。实际上，只要<strong>date</strong>还在当月就要继续迭代。</p><p>可以看到，利用<strong>LocalDate</strong>类可以编写一个日历程序，能处理星期几以及各月天数不同等复杂问题。你并不需要知道<strong>LocalDate</strong>类<strong>如何</strong>计算月和星期几。只需要使用这个类的<strong>接口</strong>，如<strong>plusDays</strong>和<strong>getDayOfWeek</strong>等方法。<br>。</p></blockquote><h4 id="程序示例-9"><a href="#程序示例-9" class="headerlink" title="程序示例"></a>程序示例</h4><center><img src="/2021/07/14/%E4%BD%BF%E7%94%A8%E9%A2%84%E5%AE%9A%E4%B9%89%E7%B1%BB/访问器方法程序示例二.png" width="90%" height="90%"> 访问器方法程序示例二</center><h4 id="运行结果-10"><a href="#运行结果-10" class="headerlink" title="运行结果"></a>运行结果</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">huangzihanDate&#x3D;2021-07-14（当前日期）

huangzihanDate&#x3D;2021-07-01（当前日期本月的第一天）

huangzihanMonth&#x3D;7（当前日期的月份）

huangzihanToday&#x3D;14（当前日期的号数）

huangzihanWeekDay&#x3D;THURSDAY（当前日期的星期）

huangzihanValue&#x3D;4（当前日期的星期值）

Mon Tue Wed Thu Fri Sat Sun
              1   2   3   4 
  5   6   7   8   9  10  11 
 12  13  14* 15  16  17  18 
 19  20  21  22  23  24  25 
 26  27  28  29  30  31 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]--><audio id="audio" loop preload="auto" controls data-autoplay="true"><source type="audio/mpeg" src=""></audio><ul id="audio-list" style="display:none"><li title="0" data-url="https://link.hhtjim.com/163/4989670.mp3"></li><li title="1" data-url="https://link.hhtjim.com/163/214374.mp3"></li><li title="2" data-url="https://link.hhtjim.com/163/443794.mp3"></li><li title="3" data-url="https://link.hhtjim.com/163/28188450.mp3"></li><li title="4" data-url="https://link.hhtjim.com/163/29816860.mp3"></li><li title="5" data-url="https://link.hhtjim.com/163/4940920.mp3"></li><li title="6" data-url="https://link.hhtjim.com/163/443860.mp3"></li><li title="7" data-url="https://link.hhtjim.com/163/4940920.mp3"></li><li title="8" data-url="https://link.hhtjim.com/163/1825230064.mp3"></li><li title="9" data-url="https://link.hhtjim.com/163/27570832.mp3"></li><li title="10" data-url="https://link.hhtjim.com/163/28285777.mp3"></li><li title="11" data-url="https://link.hhtjim.com/163/68622.mp3"></li><li title="12" data-url="https://link.hhtjim.com/163/4968365.mp3"></li><li title="13" data-url="https://link.hhtjim.com/163/4968352.mp3"></li><li title="14" data-url="https://link.hhtjim.com/163/28378263.mp3"></li><li title="15" data-url="https://link.hhtjim.com/163/1461262038.mp3"></li><li title="16" data-url="https://link.hhtjim.com/163/1821680008.mp3"></li><li title="17" data-url="https://link.hhtjim.com/163/1404997257.mp3"></li></ul></div></div><div class="side"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%A2%84%E5%AE%9A%E4%B9%89%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">使用预定义类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%8F%98%E9%87%8F"><span class="toc-number">1.1.</span> <span class="toc-text">对象与对象变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%EF%BC%88constructor%EF%BC%8C%E6%88%96%E7%A7%B0%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-number">1.1.1.</span> <span class="toc-text">构造器（constructor，或称构造函数）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-number">1.1.2.</span> <span class="toc-text">注释</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E5%90%8D%E5%AD%97%E4%B8%8E%E7%B1%BB%E5%90%8D%E7%9B%B8%E5%90%8C"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">构造器的名字与类名相同</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.1.2.1.1.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C"><span class="toc-number">1.1.2.1.2.</span> <span class="toc-text">运行结果</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">1.1.2.1.3.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-1"><span class="toc-number">1.1.2.1.4.</span> <span class="toc-text">运行结果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#toString%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.3.</span> <span class="toc-text">toString方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%8F%98%E9%87%8F"><span class="toc-number">1.1.4.</span> <span class="toc-text">对象变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">创建一个新对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-2"><span class="toc-number">1.1.4.1.1.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-2"><span class="toc-number">1.1.4.1.2.</span> <span class="toc-text">运行结果</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%8F%98%E9%87%8F-1"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">对象与对象变量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-3"><span class="toc-number">1.1.4.2.1.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-3"><span class="toc-number">1.1.4.2.2.</span> <span class="toc-text">运行结果</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-4"><span class="toc-number">1.1.4.2.3.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-4"><span class="toc-number">1.1.4.2.4.</span> <span class="toc-text">运行结果</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%8F%98%E9%87%8F"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">引用同一个对象的对象变量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-5"><span class="toc-number">1.1.4.3.1.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-5"><span class="toc-number">1.1.4.3.2.</span> <span class="toc-text">运行结果</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE%E4%B8%BAnull"><span class="toc-number">1.1.4.4.</span> <span class="toc-text">对象变量设置为null</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-6"><span class="toc-number">1.1.4.4.1.</span> <span class="toc-text">运行结果</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E7%B1%BB%E5%BA%93%E4%B8%AD%E7%9A%84LocalDate%E7%B1%BB"><span class="toc-number">1.2.</span> <span class="toc-text">Java类库中的LocalDate类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%AA%E5%85%83"><span class="toc-number">1.2.1.</span> <span class="toc-text">纪元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%EF%BC%88factory-method%EF%BC%89"><span class="toc-number">1.2.2.</span> <span class="toc-text">静态工厂方法（factory method）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-6"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-7"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">运行结果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A-1"><span class="toc-number">1.2.3.</span> <span class="toc-text">注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA"><span class="toc-number">1.2.4.</span> <span class="toc-text">提示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E6%94%B9%E5%99%A8%E6%96%B9%E6%B3%95%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%99%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">更改器方法与访问器方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-7"><span class="toc-number">1.3.1.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-8"><span class="toc-number">1.3.2.</span> <span class="toc-text">运行结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GregorianCalendar"><span class="toc-number">1.3.3.</span> <span class="toc-text">GregorianCalendar</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-8"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-9"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">运行结果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%99%A8%E6%96%B9%E6%B3%95%EF%BC%88accessor-method%EF%BC%89"><span class="toc-number">1.3.4.</span> <span class="toc-text">访问器方法（accessor method）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-9"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-10"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">运行结果</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></body><script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script><script src="/js/plugin.js"></script><script src="/js/typed.js"></script><script src="/js/diaspora.js"></script><link rel="stylesheet" href="/photoswipe/photoswipe.css"><link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css"><script src="/photoswipe/photoswipe.min.js"></script><script src="/photoswipe/photoswipe-ui-default.min.js"></script><div class="pswp" tabindex="-1" role="dialog" aria-hidden="true"><div class="pswp__bg"></div><div class="pswp__scroll-wrap"><div class="pswp__container"><div class="pswp__item"></div><div class="pswp__item"></div><div class="pswp__item"></div></div><div class="pswp__ui pswp__ui--hidden"><div class="pswp__top-bar"><div class="pswp__counter"></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button> <button class="pswp__button pswp__button--share" title="Share"></button> <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button> <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class="pswp__preloader"><div class="pswp__preloader__icn"><div class="pswp__preloader__cut"><div class="pswp__preloader__donut"></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class="pswp__share-tooltip"></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button> <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class="pswp__caption"><div class="pswp__caption__center"></div></div></div></div></div></html><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6af129e1f4dfb540b30b7969d7e7fc32";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script>