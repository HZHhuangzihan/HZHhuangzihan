<!DOCTYPE html><html lang="zh-CN" class="loading"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><title>面向对象程序设计概述 - 黄子涵</title><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="google" content="notranslate"><meta name="keywords" content="黄子涵,"><meta name="description" content="面向对象程序设计概述
面向对象程序设计（object-oriented programming，OOP）是当今主流的程序设计范型，它取代了20世纪70年代的“结构化”或过程式编程技术。由于Java是,"><meta name="author" content="黄子涵"><link rel="alternative" href="atom.xml" title="黄子涵" type="application/atom+xml"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="/css/diaspora.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><meta name="generator" content="Hexo 5.4.0"><link rel="stylesheet" href="/css/prism-atom-dark.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script>
<script src="/js/prism-line-numbers.min.js"></script></head><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><body class="loading"><span id="config-title" style="display:none">黄子涵</span><div id="loader"></div><div id="single"><div id="top" style="display:block"><div class="bar" style="width:0"></div><a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://www.huangzihan.top"></a><div title="播放/暂停" class="iconfont icon-play"></div><h3 class="subtitle">面向对象程序设计概述</h3><div class="social"><div><div class="share"><a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a></div><div id="qr"></div></div></div><div class="scrollbar"></div></div><div class="section"><div class="article"><div class="main"><h1 class="title">面向对象程序设计概述</h1><div class="stuff"><span>七月 02, 2021</span></div><div class="content markdown"><h1 id="面向对象程序设计概述"><a href="#面向对象程序设计概述" class="headerlink" title="面向对象程序设计概述"></a>面向对象程序设计概述</h1><blockquote><p>面向对象程序设计（object-oriented programming，OOP）是当今主流的程序设计范型，它取代了20世纪70年代的“结构化”或过程式编程技术。由于Java是面向对象的，所以你必须熟悉OOP才能够很好地使用Java。</p></blockquote><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><blockquote><p>面向对象的程序是由对象组成的，每个对象包含对用户公开的特定功能部分和隐藏的实现部分。程序中的很多对象来自标准库，还有一些是自定义的。究竟是自己构造对象，还是从外界购买对象完全取决于开发项目的预算和时间。但是，从根本上说，只要对象能够满足要求，就不必关心其功能到底是如何实现的。</p></blockquote><h2 id="结构化程序设计"><a href="#结构化程序设计" class="headerlink" title="结构化程序设计"></a>结构化程序设计</h2><blockquote><p>传统的结构化程序设计通过设计一系列的过程（即<strong>算法</strong>）来求解问题。一旦确定了这些过程，就要开始考虑存储数据的适当方式。这就是Pascal语言的设计者Niklaus Wirth将其著作命名为《算法+数据结构=程序》（Algorithms+Data<br>Structures=Programs，Prentice Hall，<br>1975）的原因。需要注意的是，在Wirth的这个书名中，算法是第一位的，数据结构第二位的，这就明确地表述了程序员的工作方式。首先要确定如何操作数据，然何组织数据的结构，以便于操作数据。而OOP却调换了这个次序，将数据放在第一位，然后再考虑操作数据的算法。</p></blockquote><h2 id="面对过程与面向对象的程序设计对比"><a href="#面对过程与面向对象的程序设计对比" class="headerlink" title="面对过程与面向对象的程序设计对比"></a>面对过程与面向对象的程序设计对比</h2><blockquote><p>对于一些规模较小的问题，将其分解为过程的开发方式比较理想。面向对象更加<br>适合解决规模较大的问题。要想实现一个简单的Web浏览器可能需要大约2000个过过程程，这些过程可能需要对一组全局数据进行操作。采用面向对象的设计风格，可能只据需要大约100个类，每个类平均包含20个方法（如图（面对过程与面向对象的程序设计对比）所示）。后者更易于程序员掌握，也容易找到bug。假设给定对象的数据出错了，在访问这个数据项的20个方法中查找错误要比在2000个过程中查找容易得多。</p></blockquote><center><img src="/2021/07/02/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0/面对过程与面向对象的程序设计对比.png" width="70%" height="70%"> 面对过程与面向对象的程序设计对比</center><span id="more"></span><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="类的实例"><a href="#类的实例" class="headerlink" title="类的实例"></a>类的实例</h3><blockquote><p>类（class）是构造对象的模板或蓝图。我们可以将类想象成制作小甜饼的模具，将对象想象为小甜饼。由类<strong>构造</strong>（construct）对象的过程称为创建类的<strong>实例</strong>（instance）。</p><p>正如前面所看到的，用Java编写的所有代码都位于某个类里面。标准Java库提供了几千个类，可用于各种目的，如用户界面设计、日期、日历和网络编程。尽管如此，在Java中还是需要创建一些自己的类，以便描述你的应用程序所对应的问题领域中的对象。</p></blockquote><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><blockquote><p>封装（encapsulation，有时称为<strong>数据隐藏</strong>）是处理对象的一个重要概念。从形式上看，封装就是将数据和行为组合在一个包中，并对对象的使用者隐藏具体的实现方式。</p></blockquote><h4 id="实例字段和方法"><a href="#实例字段和方法" class="headerlink" title="实例字段和方法"></a>实例字段和方法</h4><blockquote><p>对象中的数据称为<strong>实例字段</strong>（instance<br>field），操作数据的过程称为<strong>方法</strong>（method）。作为一个类的实例，特定对象都有一组特定的实例字段值。这些值的集合就是这个对象的当前<strong>状态</strong>（state）。无论何时，只要在对象上调用一个方法，它的状态就有可能发生改变。</p><p>实现封装的关键在于，绝对<strong>不能</strong>让类中的方法直接访问其他类的实例字段。程序<strong>只能</strong>通过对象的方法与对象数据进行交互。封装给对象赋予了“黑盒”特征，这是提高重用性和可靠性的关键。这意味着一个类可以完全改变存储数据的方式，只要仍旧使用同样的方法操作数据，其他对象就不会知道也不用关心这个类所发生的变化。</p></blockquote><h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><blockquote><p>OOP的另一个原则会让用户自定义Java类变得更为容易，这就是：可以通过<strong>扩展</strong>其他类来构建新类。事实上，在Java中，所有的类都源自一个“神通广大的超类”，它就是0bject。所有其他类都扩展自这个<strong>Object</strong>类。</p></blockquote><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><blockquote><p>在扩展一个已有的类时，这个扩展后的新类具有被扩展的类的全部属性和方法。你只需要在新类中提供适用于这个新类的新方法和数据字段就可以了。通过扩展一个类来建立另外一个类的过程称为继承（inheritance）。</p></blockquote><h2 id="对象-1"><a href="#对象-1" class="headerlink" title="对象"></a>对象</h2><h3 id="对象的三个主要特性"><a href="#对象的三个主要特性" class="headerlink" title="对象的三个主要特性"></a>对象的三个主要特性</h3><blockquote><p>要想使用OOP，一定要清楚对象的三个主要特性：</p></blockquote><ul><li>对象的<strong>行为</strong>（behavior）——可以对对象完成哪些操作，或者可以对对象应用哪些方法？</li><li>对象的<strong>状态</strong>（state）——当调用那些方法时，对象会如何响应？</li><li>对象的<strong>标识</strong>（identity）——如何区分具有相同行为与状态的不同对象？</li></ul><blockquote><p>同一个类的所有对象实例，由于支持相同的<strong>行为</strong>而具有家族式的相似性。对象的行为是用可调用的方法来定义的。</p><p>此外，每个对象都保存着描述当前状况的信息。这就是对象的<strong>状态</strong>。对象的状态可能会随着时间而发生改变，但这种改变不会是自发的。对象状态的改变必须通过调用方法实现（如果不经过方法调用就可以改变对象状态，只能说明破坏了封装性）。</p><p>但是，对象的状态并不能完全描述一个对象。每个对象都有一个唯一的<strong>标识</strong>（identity，或称身份）。例如，在一个订单处理系统中，任何两个订单都存在着不同之处，即使所订购的货物完全相同，它们也是不同的订单。需要注意，作为同一个类的实例，每个对象的标识总是<strong>不同</strong>的，状态也<strong>往往</strong>存在着差异。</p><p>对象的这些关键特性会彼此相互影响。例如，对象的状态影响它的行为（如果一个订单“已送货”或“已付款”，就应该拒绝调用要求增删订单中商品的方法。反过来，如果订单是“空的”，即还没有预订任何商品，这个订单就不应该“送货”）。</p></blockquote><h2 id="识别类"><a href="#识别类" class="headerlink" title="识别类"></a>识别类</h2><blockquote><p>传统的过程式程序中，必须从顶部的<strong>main</strong>函数开始编写程序。在面向对象程序设计时没有所谓的“顶部”。学习OOP的初学者因而常常会感觉无从下手。答案是：首先从识别类开始，然后再为各个类添加方法。</p><p>识别类的一个简单经验是在分析问题的过程中寻找名词，而方法对应着动词。</p><p>例如，在订单处理系统中，有这样一些名词：</p></blockquote><ul><li>商品（Item）；</li><li>订单（Order）；</li><li>送货地址（Shipping address）；</li><li>付款（Payment）；</li><li>账户（Account）。</li></ul><blockquote><p>从这些名词就可以得到类Item、Order等。</p><p>接下来查看动词。商品被<strong>添加</strong>到订单中，订单会<strong>发货</strong>或<strong>取消</strong>，另外可以对订单<strong>完成付款</strong>。对于每一个动词，如“添加”“发货”“取消”以及“完成付款”，都要识别出负责完成相应动作的对象。例如，当一个新的商品添加到订单中时，那个订单对象就是负责的对象，因为它知道如何存储商品以及如何对商品进行排序。也就是说，<strong>add</strong>应该是<strong>Order</strong>类的一个方法，它要取一个<strong>Item</strong>对象作为参数。</p><p>当然，这种“名词与动词”原则只是一种经验，在创建类的时候，只有经验才能帮助你确定哪些名词和动词重要。</p></blockquote><h2 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h2><h3 id="类的三种关系"><a href="#类的三种关系" class="headerlink" title="类的三种关系"></a>类的三种关系</h3><blockquote><p>在类之间，最常见的关系有</p></blockquote><ul><li>依赖（“uses-a”）；</li><li>聚合（“has-a”）；</li><li>继承（“is-a”）。</li></ul><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><blockquote><p>依赖（dependence），即“uses-a”关系，是一种最明显的、最常见的关系。例如，<strong>Order</strong>类使用<strong>Account</strong>类是因为<strong>Order</strong>对象需要访问<strong>Account</strong>对象查看信用状态。但是<strong>Item</strong>类不依赖于<strong>Account</strong>类，因为<strong>Item</strong>对象不需要考虑客户账户。因此，如果一个类的方法使用或操纵另一个类的对象，我们就说一个类依赖于另一个类。</p><p>应该尽可能地将相互依赖的类减至最少。这里的关键是，如果类A不知道B的存在，它就不会关心B的任何改变（这意味着B的改变不会导致A产生任何bug）。用软件工程的术语来说，就是尽可能减少类之间的<strong>耦合</strong>。</p></blockquote><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><blockquote><p>聚合（aggregation），即“has-a”关系，很容易理解，因为这种关系很具体。例如，一个<strong>Order</strong>对象包含一些<strong>Item</strong>对象。包容关系意味着类A的对象包含类B的对象。</p></blockquote><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><blockquote><p>有些方法学家不喜欢聚合这个概念，而更加喜欢使用更一般的“关联”关系。<br>从建模的角度看，这是可以理解的。但对于程序员来说，“has-a”关系更加形象。我们喜欢使用聚合还有另一个原因：关联的标准记法不是很清楚，请参看表（表达类关系的UML符号）。</p></blockquote><center><img src="/2021/07/02/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0/表达类关系的UML符号.png" width="90%" height="90%"> 表达类关系的UML符号</center><h3 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h3><blockquote><p>继承（inheritance），即“is-a”关系，表示一个更特殊的类与一个更一般的类之间的关系。例如，<strong>Rushorder</strong>类由<strong>Order</strong>类继承而来。在更特殊的<strong>RushOrder</strong>类中包含了一些用于优先处理的特殊方法，还提供了一个计算运费的不同方法；而其他的方法，如添加商品、生成账单等都是从<strong>Order</strong>类继承来的。一般而言，如果类A扩展类B，类A不但包含从类B继承的方法，还会有一些额外的功能。</p></blockquote><h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><blockquote><p>很多程序员采用UML（Unified Modeling<br>Language，统一建模语言）绘制类图，用来描述类之间的关系。图（类图）就是这样一个例子。类用矩形表示，类之间的关系用带有各种修饰的箭头表示。表（表达类关系的UML符号）给出了UML中最常见的箭头样式。</p></blockquote><center><img src="/2021/07/02/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0/类图.png" width="70%" height="70%"> 类图</center><!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]--><audio id="audio" loop preload="auto" controls data-autoplay="true"><source type="audio/mpeg" src=""></audio><ul id="audio-list" style="display:none"><li title="0" data-url="https://link.hhtjim.com/163/4989670.mp3"></li><li title="1" data-url="https://link.hhtjim.com/163/214374.mp3"></li><li title="2" data-url="https://link.hhtjim.com/163/443794.mp3"></li><li title="3" data-url="https://link.hhtjim.com/163/28188450.mp3"></li><li title="4" data-url="https://link.hhtjim.com/163/29816860.mp3"></li><li title="5" data-url="https://link.hhtjim.com/163/4940920.mp3"></li><li title="6" data-url="https://link.hhtjim.com/163/443860.mp3"></li><li title="7" data-url="https://link.hhtjim.com/163/4940920.mp3"></li><li title="8" data-url="https://link.hhtjim.com/163/1825230064.mp3"></li><li title="9" data-url="https://link.hhtjim.com/163/27570832.mp3"></li><li title="10" data-url="https://link.hhtjim.com/163/28285777.mp3"></li><li title="11" data-url="https://link.hhtjim.com/163/68622.mp3"></li><li title="12" data-url="https://link.hhtjim.com/163/4968365.mp3"></li><li title="13" data-url="https://link.hhtjim.com/163/4968352.mp3"></li><li title="14" data-url="https://link.hhtjim.com/163/28378263.mp3"></li><li title="15" data-url="https://link.hhtjim.com/163/1461262038.mp3"></li><li title="16" data-url="https://link.hhtjim.com/163/1821680008.mp3"></li><li title="17" data-url="https://link.hhtjim.com/163/1404997257.mp3"></li></ul></div></div><div class="side"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">面向对象程序设计概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.</span> <span class="toc-text">对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.2.</span> <span class="toc-text">结构化程序设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%AF%B9%E8%BF%87%E7%A8%8B%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AF%B9%E6%AF%94"><span class="toc-number">1.3.</span> <span class="toc-text">面对过程与面向对象的程序设计对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">1.4.</span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.4.1.</span> <span class="toc-text">类的实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">1.4.2.</span> <span class="toc-text">封装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%AD%97%E6%AE%B5%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">实例字段和方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object%E7%B1%BB"><span class="toc-number">1.4.3.</span> <span class="toc-text">Object类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">1.4.4.</span> <span class="toc-text">继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1-1"><span class="toc-number">1.5.</span> <span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E4%B8%AA%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7"><span class="toc-number">1.5.1.</span> <span class="toc-text">对象的三个主要特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%86%E5%88%AB%E7%B1%BB"><span class="toc-number">1.6.</span> <span class="toc-text">识别类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.7.</span> <span class="toc-text">类之间的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E4%B8%89%E7%A7%8D%E5%85%B3%E7%B3%BB"><span class="toc-number">1.7.1.</span> <span class="toc-text">类的三种关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96"><span class="toc-number">1.7.2.</span> <span class="toc-text">依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E5%90%88"><span class="toc-number">1.7.3.</span> <span class="toc-text">聚合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">注释</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF-1"><span class="toc-number">1.7.4.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UML"><span class="toc-number">1.7.5.</span> <span class="toc-text">UML</span></a></li></ol></li></ol></li></ol></div></div></div></div></body><script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script><script src="/js/plugin.js"></script><script src="/js/typed.js"></script><script src="/js/diaspora.js"></script><link rel="stylesheet" href="/photoswipe/photoswipe.css"><link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css"><script src="/photoswipe/photoswipe.min.js"></script><script src="/photoswipe/photoswipe-ui-default.min.js"></script><div class="pswp" tabindex="-1" role="dialog" aria-hidden="true"><div class="pswp__bg"></div><div class="pswp__scroll-wrap"><div class="pswp__container"><div class="pswp__item"></div><div class="pswp__item"></div><div class="pswp__item"></div></div><div class="pswp__ui pswp__ui--hidden"><div class="pswp__top-bar"><div class="pswp__counter"></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button> <button class="pswp__button pswp__button--share" title="Share"></button> <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button> <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class="pswp__preloader"><div class="pswp__preloader__icn"><div class="pswp__preloader__cut"><div class="pswp__preloader__donut"></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class="pswp__share-tooltip"></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button> <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class="pswp__caption"><div class="pswp__caption__center"></div></div></div></div></div></html><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6af129e1f4dfb540b30b7969d7e7fc32";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script>