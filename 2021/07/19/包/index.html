<!DOCTYPE html><html lang="zh-CN" class="loading"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><title>包 - 黄子涵</title><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="google" content="notranslate"><meta name="keywords" content="黄子涵,"><meta name="description" content="包
Java允许使用包（package）将类组织在一个集合中。借助包可以方便地组织自己的代码，并将自己的代码与别人提供的代码库分开管理。下面我们将介绍如何使用和创建包。

包名
使用包的主要原因是确,"><meta name="author" content="黄子涵"><link rel="alternative" href="atom.xml" title="黄子涵" type="application/atom+xml"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="/css/diaspora.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><meta name="generator" content="Hexo 5.4.0"><link rel="stylesheet" href="/css/prism-atom-dark.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script>
<script src="/js/prism-line-numbers.min.js"></script></head><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><body class="loading"><span id="config-title" style="display:none">黄子涵</span><div id="loader"></div><div id="single"><div id="top" style="display:block"><div class="bar" style="width:0"></div><a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://www.huangzihan.top"></a><div title="播放/暂停" class="iconfont icon-play"></div><h3 class="subtitle">包</h3><div class="social"><div><div class="share"><a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a></div><div id="qr"></div></div></div><div class="scrollbar"></div></div><div class="section"><div class="article"><div class="main"><h1 class="title">包</h1><div class="stuff"><span>七月 19, 2021</span></div><div class="content markdown"><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><blockquote><p>Java允许使用<strong>包</strong>（package）将类组织在一个集合中。借助包可以方便地组织自己的代码，并将自己的代码与别人提供的代码库分开管理。下面我们将介绍如何使用和创建包。</p></blockquote><h2 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h2><blockquote><p>使用包的主要原因是确保类名的唯一性。假如两个程序员不约而同地建立了Employee类。只要将这些类放置在不同的包中，就不会产生冲突。事实上，为了保证包名的绝对唯一性，要用一个因特网域名（这显然是唯一的）以逆序的形式作为包名，然后对于不同的工程使用不同的子包。例如，考虑域名<strong>horstmann.com</strong>。如果逆序来写，就得到了包名<strong>com.horstmann</strong>。然后可以追加一个工程名，如<strong>com.horstmann.corejava</strong>。如果再把<strong>Employee</strong>类放在这个包里，那么这个类的“完全限定”名就是<strong>com.horstmann.corejava.Employee</strong>。</p></blockquote><center><img src="/2021/07/19/%E5%8C%85/包名.png" width="50%" height="50%"> 包名</center><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><blockquote><p>从编译器的角度来看，嵌套的包之间没有任何关系。例如，<strong>java.util</strong>包与<strong>java.util.jar</strong>包毫无关系。每一个包都是独立的类集合。</p></blockquote><center><img src="/2021/07/19/%E5%8C%85/注释.png" width="50%" height="50%"> 注释</center><span id="more"></span><h2 id="类的导入"><a href="#类的导入" class="headerlink" title="类的导入"></a>类的导入</h2><blockquote><p>一个类可以使用所属包中的所有类，以及其他包中的<strong>公共类</strong>（public class）。</p><p>我们可以采用两种方式访问另一个包中的公共类。第一种方式就是使用<strong>完全限定名</strong>（fully qualified name）；就是包名后面跟着类名。例如：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">java.time.LocalDate today &#x3D; java.time.LocalDate.now();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h3><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">public class HuangZiHanTest
&#123;  
   public static void main(String[] huangzihan_args)
   &#123;
	   java.time.LocalDate huangzihan_today &#x3D; java.time.LocalDate.now();
	   System.out.println(huangzihan_today);
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">2021-07-19<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="import语句"><a href="#import语句" class="headerlink" title="import语句"></a>import语句</h3><blockquote><p>这显然很烦琐。更简单且更常用的方式是使用<strong>import</strong>语句。<strong>import</strong>语句是一种引用包中各个类的简捷方式。一旦使用了import语句，在使用类时，就不必写出类的全名了。</p><p>可以使用<strong>import</strong>语句导入一个特定的类或者整个包。<strong>import</strong>语句应该位于源文件的顶部（但位于<strong>package</strong>语句的后面）。例如，可以使用下面这条语句导入<strong>java.util</strong>包中的所有类。</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">import java.time.*;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>然后，就可以使用</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">LocalDate today &#x3D; LocalDate.now();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>而无须在前面加上包前缀。还可以导入一个包中的特定类：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">import java.time.LocalDate;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><code>java.time.*</code>的语法比较简单，对代码的规模也没有任何负面影响。不过，如果能够明确地指出所导入的类，代码的读者就能更加准确地知道你使用了哪些类。</p></blockquote><h4 id="程序示例一"><a href="#程序示例一" class="headerlink" title="程序示例一"></a>程序示例一</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">import java.time.LocalDate;

public class HuangZiHanTest
&#123;  
   public static void main(String[] huangzihan_args)
   &#123;
	   LocalDate huangzihan_today &#x3D; LocalDate.now();
	   System.out.println(huangzihan_today);
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行结果一"><a href="#运行结果一" class="headerlink" title="运行结果一"></a>运行结果一</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">2021-07-19<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="程序示例二"><a href="#程序示例二" class="headerlink" title="程序示例二"></a>程序示例二</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">import java.time.*;

public class HuangZiHanTest
&#123;  
   public static void main(String[] huangzihan_args)
   &#123;
	   LocalDate huangzihan_today &#x3D; LocalDate.now();
	   System.out.println(huangzihan_today);
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行结果二"><a href="#运行结果二" class="headerlink" title="运行结果二"></a>运行结果二</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">2021-07-19<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><blockquote><p>在Eclipse中，可以使用莱单选项Source——&gt;Organize Imports。诸如<code>import java.util.*;</code>等包语句将会自动扩展为一组特定的导入语句，如：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">import java.util.Arraylist;
import java.util.Date;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><center><img src="/2021/07/19/%E5%8C%85/提示.png" width="50%" height="50%"> 提示</center><blockquote><p>这是一个十分便捷的特性。</p><p>但是，需要注意的是，只能使用星号（<em>）导入一个包，而不能使用`import java.</em><code>或</code>import java.<em>.</em>`导入以java为前缀的所有包。</p></blockquote><h3 id="包的命名冲突"><a href="#包的命名冲突" class="headerlink" title="包的命名冲突"></a>包的命名冲突</h3><blockquote><p>在大多数情况下，可以只导入你需要的包，并不必过多地考虑它们。但在发生命名冲突的时候，就要注意包了。例如，<strong>java.util</strong>和<strong>java.sql</strong>包都有<strong>Date</strong>类。如果在程序中导入了这两个包：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">import java.util.*;
import java.sql.*;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>在程序中使用<strong>Date</strong>类的时候，就会出现一个编译错误：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">Date today;   &#x2F;&#x2F; ERROR--java.util.Date or java.sql.Date？<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="程序示例一-1"><a href="#程序示例一-1" class="headerlink" title="程序示例一"></a>程序示例一</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">import java.util.*;
import java.sql.*;

public class HuangZiHanTest
&#123;  
   public static void main(String[] huangzihan_args)
   &#123;
	   Date huangzihan_today;
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行结果一-1"><a href="#运行结果一-1" class="headerlink" title="运行结果一"></a>运行结果一</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">Exception in thread &quot;main&quot; java.lang.Error: Unresolved compilation problem: 
	The type Date is ambiguous

	at HuangZiHanTest.main(HuangZiHanTest.java:8)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>此时编译器无法确定你想使用的是哪一个<strong>Date</strong>类。可以增加一个特定的<strong>import</strong>语句来解决这个问题：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">import java.util.*;
import java.sql.*;
import java.util.Date;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="程序示例二-1"><a href="#程序示例二-1" class="headerlink" title="程序示例二"></a>程序示例二</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">import java.util.*;
import java.sql.*;
import java.util.Date;

public class HuangZiHanTest
&#123;  
   public static void main(String[] huangzihan_args)
   &#123;
	   Date huangzihan_today;
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行结果二-1"><a href="#运行结果二-1" class="headerlink" title="运行结果二"></a>运行结果二</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>如果这两个<strong>Date</strong>类都需要使用，又该怎么办呢？答案是，在每个类名的前面加上完整的包名。</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">var deadline &#x3D; new java.util.Date();
var today &#x3D; new java.sql.Date(...);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>在包中定位类是<strong>编译器</strong>（compiler）的工作。类文件中的字节码总是使用完整的包名引用其他类。</p></blockquote><h4 id="程序示例三"><a href="#程序示例三" class="headerlink" title="程序示例三"></a>程序示例三</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">import java.util.*;
import java.sql.*;
import java.util.Date;

public class HuangZiHanTest
&#123;  
   public static void main(String[] huangzihan_args)
   &#123;
	   var huangzihan_deadline &#x3D; new java.util.Date();
	   var huangzihan_today &#x3D; new java.sql.Date(0);
	   
	   System.out.println(huangzihan_deadline);
	   System.out.println(huangzihan_today);
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行结果三"><a href="#运行结果三" class="headerlink" title="运行结果三"></a>运行结果三</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">Mon Jul 19 10:33:53 CST 2021
1970-01-01<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="静态导入"><a href="#静态导入" class="headerlink" title="静态导入"></a>静态导入</h2><blockquote><p>有一种<strong>import</strong>语句允许导入静态方法和静态字段，而不只是类。</p><p>例如，如果在源文件顶部，添加一条指令：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">import static java.lang.System.*;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>就可以使用System类的静态方法和静态字段，而不必加类名前缀：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">out.println(&quot;Goodbye, World!&quot;);    &#x2F;&#x2F; i.e., System.out 
exit(0);   &#x2F;&#x2F; i.e., System.exit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="程序示例-1"><a href="#程序示例-1" class="headerlink" title="程序示例"></a>程序示例</h3><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">import static java.lang.System.*;

public class HuangZiHanTest
&#123;  
   public static void main(String[] huangzihan_args)
   &#123;
	   out.println(&quot;黄子涵&quot;);
	   exit(0);
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h3><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">黄子涵<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>另外，还可以导入特定的方法或字段：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">import static java.lang.System.out;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>实际上，是否有很多程序员想要用简写<strong>System.out</strong>或<strong>System.exit</strong>，这一点很让人怀疑。这样写出的代码看起来不太清晰。不过，</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">sqrt(pow(x, 2) + pow(y, 2))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>看起来比</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>清晰得多。</p></blockquote><h2 id="在包中增加类"><a href="#在包中增加类" class="headerlink" title="在包中增加类"></a>在包中增加类</h2><blockquote><p>要想将类放入包中，就必须将包的名字放在源文件的开头，即放在定义这个包中各个类的代码<strong>之前</strong>。例如，下面程序的文件Employee.java开头是这样的：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">package com.horstmann.corejava;

public class Employee
&#123;
    . . .
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>如果没有在源文件中放置<strong>package</strong>语句，这个源文件中的类就属于<strong>无名包</strong>（unnamed package）。无名包没有包名。到目前为止，我们定义的所有类都在这个无名包中。</p><p>将源文件放到与完整包名匹配的子目录中。例如，<strong>com.horstmann.corejava</strong>包中的所有源文件应该放置在子目录<strong>com/horstmann/corejava</strong>中（Windows中则是<strong>com\horstmann\corejava</strong>）。编译器将类文件也放在相同的目录结构中。</p><p>下面的程序分放在两个包中：<strong>PackageTest</strong>类属于无名包；<strong>Employee</strong>类属于<strong>com.horstmann.corejava</strong>包。因此，<strong>Employee.java</strong>文件必须包含在子目录<strong>com/horstmann/corejava</strong>中。换句话说，目录结构如下所示：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">. (base directory)
  |__ PackageText.java
  |__ PackageText.class
  |__ com&#x2F;
      |__ horstmann&#x2F;
          |__ corejava&#x2F;
              |__ Employee.java
              |__ Employee.class
&#96;&#96;&#96;             
             
&gt; 要想编译这个程序，只需切换到基目录，并运行命令

&#96;&#96;&#96;C&#x2F;C++
javac PackageTest.java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>编译器就会自动地查找文件<strong>com/horstmann/corejava/Employee.java</strong>并进行编译。</p><p>下面看一个更加实际的例子。在这里不使用无名包，而是将类分别放在不同的包中（<strong>com.horstmann.corejava</strong>和<strong>com.mycompany</strong>）。</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">. (base directory)
 |__ com&#x2F;
     |__ horstmann&#x2F;
     |   |__ corejava&#x2F;
     |       |__ Employee.java
     |       |__ Employee.class
     |__ mycompany&#x2F;
     |__ PayrollApp.java
     |__ PayrollApp.class
&#96;&#96;&#96;     
     
&gt; 在这种情况下，仍然要从基目录编译和运行类，即包含**com**目录的目录：

&#96;&#96;&#96;C&#x2F;C++
javac com&#x2F;mycompany&#x2F;PayrollApp.java 
java com.mycompany.PayrolLApp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>需要注意，编译器处理<strong>文件</strong>（带有文件分隔符和扩展名.java的文件），而Java解释器加载类（带有.分隔符）。</p></blockquote><h3 id="程序示例-2"><a href="#程序示例-2" class="headerlink" title="程序示例"></a>程序示例</h3><h4 id="JavaCore-src-Huangizhan-PackageTest"><a href="#JavaCore-src-Huangizhan-PackageTest" class="headerlink" title="/JavaCore/src/Huangizhan_PackageTest"></a>/JavaCore/src/Huangizhan_PackageTest</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">package Huangizhan_PackageTest;

import com.huangzihan.corejava.*;

&#x2F;&#x2F;Employee 类在该包中定义

import static java.lang.System.*;

&#x2F;*
 * @功能：该程序演示了包的使用。
 * @版本：1.11
 * @时间：2021-07-19
 * @作者：黄子涵
 * 
 *&#x2F;

public class Huangizhan_PackageTest
&#123;
	public static void main(String[] huangzihan_args) 
	&#123;
		&#x2F;&#x2F;由于导入语句，我们不必使用
		&#x2F;&#x2F;com.huangzihan.corejava
		
		var huangzihan &#x3D; new Huangzihan_Employee(&quot;黄子涵&quot;, 50000, 1989, 10, 1);
		
		huangzihan.huangzihan_raiseSalary(5);
		
		&#x2F;&#x2F;由于静态导入语句，我们不必使用 System.在这里
		out.println(&quot;名字&#x3D;&quot; + huangzihan.huangzihan_getName() + &quot;,工资&#x3D;&quot; + huangzihan.huangzihan_getSalary());
	&#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="JavaCore-src-com-huangzihan-corejava"><a href="#JavaCore-src-com-huangzihan-corejava" class="headerlink" title="/JavaCore/src/com/huangzihan/corejava"></a>/JavaCore/src/com/huangzihan/corejava</h4><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">package com.huangzihan.corejava;

&#x2F;&#x2F;这个文件中的类是这个包的一部分

import java.time.*;

&#x2F;&#x2F;导入语句在包语句之后

&#x2F;*
 * @版本：1.11
 * @时间：2015-05-08
 * @作者：黄子涵
 * 
 *&#x2F;

public class Huangzihan_Employee
&#123;
	private String huangzihan_name;
	private double huangzihan_salary;
	private LocalDate huangzihan_hireDay;
	
	public Huangzihan_Employee(String huangzihan_name, double huangzihan_salary, int huangzihan_year, int huangzihan_month, int huangzihan_day) 
	&#123;
		this.huangzihan_name &#x3D; huangzihan_name;
		this.huangzihan_salary &#x3D; huangzihan_salary;
		huangzihan_hireDay &#x3D; LocalDate.of(huangzihan_year, huangzihan_month, huangzihan_day);
	&#125;
	
	public String huangzihan_getName() 
	&#123;
		return huangzihan_name;
	&#125;
	
	public double huangzihan_getSalary() 
	&#123;
		return huangzihan_salary;
	&#125;
	
	public LocalDate huangzihan_getHireDay() 
	&#123;
		return huangzihan_hireDay;
	&#125;
	
	public void huangzihan_raiseSalary(double huangzihan_byPercent) 
	&#123;
		double huangzihan_raise &#x3D; huangzihan_salary * huangzihan_byPercent &#x2F; 100;
		huangzihan_salary +&#x3D; huangzihan_raise;
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="运行结果-2"><a href="#运行结果-2" class="headerlink" title="运行结果"></a>运行结果</h3><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">名字&#x3D;黄子涵,工资&#x3D;52500.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h3><blockquote><p>编译器在编译源文件的时候<strong>不</strong>检查目录结构。例如，假定一个源文件开头有以下指令：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">package com.mycompany;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>即使这个源文件不在子目录<strong>com/mycompany</strong>下，也可以进行编译。<strong>如果它不依赖于其他包</strong>，就可以通过编译而不会出现编译错误。但是，最终的程序将无法运行，除非先将所有类文件移到正确的位置上。如果包与目录不匹配，<strong>虚拟机</strong>就找不到类。</p></blockquote><h2 id="包访问"><a href="#包访问" class="headerlink" title="包访问"></a>包访问</h2><blockquote><p>前面已经接触过访问修饰符<strong>public</strong>和<strong>private</strong>。标记为<strong>public</strong>的部分可以由任意类使用；标记为<strong>private</strong>的部分只能由定义它们的类使用。如果没有指定<strong>public</strong>或<strong>private</strong>，这个部分（类、方法或变量）可以被同一个<strong>包</strong>中的所有方法访问。</p><p>如果我们没有将<strong>Employee</strong>类定义为公共类，因此只有在同一个包（在此是无名的包）中的其他类可以访问，例如<strong>EmployeeTest</strong>。对于类来说，这种默认方式是合乎情理的。但是，对于变量来说就有些不适宜了，变量必须显式地标记为<strong>private</strong>，不然的话将默认为包可访问。显然，这样做会破坏封装性。问题是人们经常忘记键入关键字<strong>private</strong>。<strong>java.awt</strong>包中的<strong>Window</strong>类就是一个典型的示例。<strong>java.awt</strong>包是JDK提供的部分源代码：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">public class Window extends Container 
&#123;
    String warningString;
    . . .
&#125;    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>请注意，这里的<strong>warningString</strong>变量不是<strong>private</strong>！这意味着<strong>java.awt</strong>包中的所有类的方法都可以访问该变量，并将它设置为任意值（例如，“<strong>Trust me!</strong>“）。实际上，只有<strong>Window</strong>类的方法访问这个变量，因此本应该将它设置为私有变量才合适。可能是程序员敲代码时匆忙之中忘记<strong>private</strong>修饰符了？也可能是没有人关心这个问题？已经20多年了，这个变量仍然不是私有变量。不仅如此，这个类还陆续增加了一些新的字段，而其中大约有一半也不是私有的。</p><p>这可能会成为一个问题。在默认情况下，包不是封闭的实体。也就是说，任何人都可以向包中添加更多的类。当然，有恶意或低水平的程序员很可能利用包的可见性添加一些能修改变量的代码。例如，在Java程序设计语言的早期版本中，只需要将以下这条语句放在类文件的开头，就可以很容易地在<strong>java.awt</strong>包中混入其他类：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">package java.awt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>然后，把得到的类文件放置在类路径上某处的<strong>java/awt</strong>子目录下，这样就可以访问<strong>java.awt</strong>包的内部了。使用这一手段，完全可以设置警告字符串。</p><p>从1.2版开始，JDK的实现者修改了类加载器，明确地禁止加载包名以“java.”开头的用户自定义的类！当然，用户自定义的类无法从这种保护中受益。另一种机制是让JAR文件声明包为<strong>密封的</strong>（sealed），以防止第三方修改，但这种机制已经过时。现在应当使用模块封装包。</p></blockquote><h2 id="类路径"><a href="#类路径" class="headerlink" title="类路径"></a>类路径</h2><blockquote><p>在前面已经看到，类存储在文件系统的子目录中。类的路径必须与包名匹配。</p><p>另外，类文件也可以存储在JAR（Java归档）文件中。在一个JAR文件中，可以包含多个压缩形式的类文件和子目录，这样既可以节省空间又可以改善性能。在程序中用到第三方的库文件时，你通常要得到一个或多个需要包含的JAR文件。</p></blockquote><h3 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h3><blockquote><p>JAR文件使用ZIP格式组织文件和子目录。可以使用任何ZIP工具查看JAR文件。</p></blockquote><h3 id="类能够被多个程序共享"><a href="#类能够被多个程序共享" class="headerlink" title="类能够被多个程序共享"></a>类能够被多个程序共享</h3><blockquote><p>为了使类能够被多个程序共享，需要做到下面几点：</p></blockquote><ol><li>把类文件放到一个目录中，例如<strong>/home/user/classdir</strong>。需要注意，这个目录是包树状结构的<strong>基</strong>目录。如果希望增加<strong>com.horstmann.corejava.Employee</strong>类，那么<strong>Employee.class</strong>类文件就必须位于子目录<br><strong>/home/user/classdir/com/horstmann/corejava</strong>中。</li><li>将JAR文件放在一个目录中，例如：<strong>/home/user/archives</strong>。</li><li>设置<strong>类路径</strong>（class path）。类路径是所有包含类文件的路径的集合。</li></ol><blockquote><p>在UNIX环境中，类路径中的各项之间用冒号（:）分隔：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">&#x2F;home&#x2F;user&#x2F;classdir:.:&#x2F;home&#x2F;user&#x2F;archives&#x2F;archive.jar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>而在Windows环境中，则以分号（;）分隔：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">c:\classdir;.;c:\archives\archive.jar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>不论是UNIX还是Windows，都用句点（.）表示当前目录。</p><p>类路径包括：</p></blockquote><ul><li>基目录<code>/home/user/classdir</code>或<code>c:\classes;</code></li><li>当前目录（.）；</li><li>JAR文件<code>/home/user/archives/archive.jar</code>或<code>c:\archives\archive.jar</code>。</li></ul><blockquote><p>从Java 6开始，可以在JAR文件目录中指定通配符，如下：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">&#x2F;home&#x2F;user&#x2F;classdir:.:&#x2F;home&#x2F;user&#x2F;archives&#x2F;&#39;*&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>或者</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">C:\classdir；.；c:\archives\*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>在UNIX中，*必须转义以防止shell扩展。</p><p><strong>archives</strong>目录中的所有JAR文件（但不包括<code>.class</code>文件）都包含在这个类路径中。</p><p>由于总是会搜索Java API的类，所以不必显式地包含在类路径中。</p></blockquote><h3 id="警告-1"><a href="#警告-1" class="headerlink" title="警告"></a>警告</h3><blockquote><p><strong>javac</strong>编译器总是在当前的目录中查找文件，但<strong>java</strong>虚拟机仅在类路径中包含“.”目录的时候才查看当前目录。如果没有设置类路径，那么没有什么问题，因为默认的类路径会包含“.”目录。但是如果你设置了类路径却忘记包含“.”目录，那么尽管你的程序可以没有错误地通过编译，但不能运行。</p><p>类路径所列出的目录和归档文件是搜寻类的<strong>起始点</strong>。下面看一个类路径示例：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">&#x2F;home&#x2F;user&#x2F;classdir:.:&#x2F;home&#x2F;user&#x2F;archives&#x2F;archive.jar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>假定虚拟机要搜寻<strong>com.horstmann.corejava.Employee</strong>类的类文件。它首先要查看Java API类。显然，在那里找不到相应的类文件，所以转而查看类路径。然后查找以下文件：</p></blockquote><ul><li>/home/user/classdir/com/horstmann/corejava/Employee.class</li><li>com/horstmann/corejava/Employee.class（从当前目录开始）</li><li>com/horstmann/corejava/Employee.class（/home/user/archives/archive.jar中）</li></ul><blockquote><p>编译器查找文件要比虚拟机复杂得多。如果引用了一个类，而没有指定这个类的包，那么编译器将首先查找包含这个类的包。它会查看所有的<strong>import</strong>指令，确定其中是否包含这个类。例如，假定源文件包含指令：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">import java.util.*;
import com.horstmann.corejava.*;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>并且源代码引用了<strong>Employee</strong>类。编译器将尝试查找<strong>java.lang.Employee</strong>（因为<strong>java.lang</strong>包总是会默认导入）、<strong>java.util.Employee</strong>、<strong>com.horstmann.corejava.Employee</strong>和当前包中的<strong>Employee</strong>。它会在类路径所有位置中搜索以上<strong>各个类</strong>。如果找到了一个以上的类，就会产生编译时错误（因为完全限定类名必须是唯一的，所以<strong>import</strong>语句的次序并不重要）。</p><p>编译器的任务不止这些，它还要查看<strong>源文件</strong>是否比类文件新。如果是这样的话，那么源文件就被自动地重新编译。在前面已经知道，只可以导入其他包中的公共类。一个源文件只能包含一个公共类，并且文件名与公共类名必须匹配。因此，编译器很容易找到公共类的源文件。不过，还可以从当前包中导入非公共类。这些类有可能在与类名不同的源文件中定义。如果从当前包中导入一个类，编译器就要搜索当前包中的所有源文件，查看哪个源文件定义了这个类。</p></blockquote><h2 id="设置类路径"><a href="#设置类路径" class="headerlink" title="设置类路径"></a>设置类路径</h2><blockquote><p>最好使用<code>-classpath</code>（或<code>-cp</code>，或者Java 9中的<code>--class-path</code>）选项指定类路径：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">java -classpath &#x2F;home&#x2F;user&#x2F;classdir:.:&#x2F;home&#x2F;user&#x2F;archives&#x2F;archive.jar
MyProg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>或者</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">java -classpath c:\classdir;.;c:\archives\archive.jar MyProg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>整个指令必须写在一行中。将这样一个很长的命令行放在一个shell脚本或一个批处理文件中是个不错的主意。</p><p>利用<code>-classpath</code>选项设置类路径是首选的方法，也可以通过设置<strong>CLASSPATH</strong>环境变量来指定。具体细节依赖于所使用的shell。在Bourne Again shell（bash）中，命令如下：</p></blockquote><pre class="line-numbers language-none"><code class="language-none">export CLASSPATH&#x3D;&#x2F;home&#x2F;user&#x2F;classdir:.：&#x2F;home&#x2F;user&#x2F;archives&#x2F;archive.jar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>在Windows shell，命令如下：</p></blockquote><pre class="line-numbers language-none"><code class="language-none">set CLASSPATH&#x3D;C:\classdir；.；c:\archives\archive.jar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>直到退出shell为止，类路径设置均有效。</p></blockquote><h3 id="警告-2"><a href="#警告-2" class="headerlink" title="警告"></a>警告</h3><blockquote><p>有人建议将<strong>CLASSPATH</strong>环境变量设置为永久不变的值。一般来说这是一个糟糕的想法。人们有可能会忘记全局设置，因此，当他们的类没有正确地加载时，就会感到很奇怪。一个应该受到谴责的示例是Windows中Apple的QuickTime安装程序。很多年来，它都将<strong>CLASSPATH</strong>全局设置为指向它需要的一个JAR文件，而没有在类路径中包含当前路径。因此，当程序编译后却不能运行时，无数Java程序员不得不花费很多精力去解决这个问题。</p></blockquote><h3 id="警告-3"><a href="#警告-3" class="headerlink" title="警告"></a>警告</h3><blockquote><p>过去，有人建议完全绕开类路径，将所有的文件都放在<strong>jre/lib/ext</strong>目录中。这种机制在Java 9中已经过时，不过不管怎样这都是一个不好的建议。很可能会从扩展目录加载一些已经遗忘很久的类，这会让人非常困惑。</p></blockquote><h3 id="注释-1"><a href="#注释-1" class="headerlink" title="注释"></a>注释</h3><blockquote><p>在Java9中，还可以从<strong>模块路径</strong>加载类。</p></blockquote><!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]--><audio id="audio" loop preload="auto" controls data-autoplay="true"><source type="audio/mpeg" src=""></audio><ul id="audio-list" style="display:none"><li title="0" data-url="https://link.hhtjim.com/163/4989670.mp3"></li><li title="1" data-url="https://link.hhtjim.com/163/214374.mp3"></li><li title="2" data-url="https://link.hhtjim.com/163/443794.mp3"></li><li title="3" data-url="https://link.hhtjim.com/163/28188450.mp3"></li><li title="4" data-url="https://link.hhtjim.com/163/29816860.mp3"></li><li title="5" data-url="https://link.hhtjim.com/163/4940920.mp3"></li><li title="6" data-url="https://link.hhtjim.com/163/443860.mp3"></li><li title="7" data-url="https://link.hhtjim.com/163/4940920.mp3"></li><li title="8" data-url="https://link.hhtjim.com/163/1825230064.mp3"></li><li title="9" data-url="https://link.hhtjim.com/163/27570832.mp3"></li><li title="10" data-url="https://link.hhtjim.com/163/28285777.mp3"></li><li title="11" data-url="https://link.hhtjim.com/163/68622.mp3"></li><li title="12" data-url="https://link.hhtjim.com/163/4968365.mp3"></li><li title="13" data-url="https://link.hhtjim.com/163/4968352.mp3"></li><li title="14" data-url="https://link.hhtjim.com/163/28378263.mp3"></li><li title="15" data-url="https://link.hhtjim.com/163/1461262038.mp3"></li><li title="16" data-url="https://link.hhtjim.com/163/1821680008.mp3"></li><li title="17" data-url="https://link.hhtjim.com/163/1404997257.mp3"></li></ul></div></div><div class="side"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%85"><span class="toc-number">1.</span> <span class="toc-text">包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E5%90%8D"><span class="toc-number">1.1.</span> <span class="toc-text">包名</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-number">1.1.1.</span> <span class="toc-text">注释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%AF%BC%E5%85%A5"><span class="toc-number">1.2.</span> <span class="toc-text">类的导入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C"><span class="toc-number">1.2.2.</span> <span class="toc-text">运行结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#import%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.2.3.</span> <span class="toc-text">import语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B%E4%B8%80"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">程序示例一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E4%B8%80"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">运行结果一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B%E4%BA%8C"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">程序示例二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E4%BA%8C"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">运行结果二</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA"><span class="toc-number">1.2.4.</span> <span class="toc-text">提示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E7%9A%84%E5%91%BD%E5%90%8D%E5%86%B2%E7%AA%81"><span class="toc-number">1.2.5.</span> <span class="toc-text">包的命名冲突</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B%E4%B8%80-1"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">程序示例一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E4%B8%80-1"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">运行结果一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B%E4%BA%8C-1"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">程序示例二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E4%BA%8C-1"><span class="toc-number">1.2.5.4.</span> <span class="toc-text">运行结果二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B%E4%B8%89"><span class="toc-number">1.2.5.5.</span> <span class="toc-text">程序示例三</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E4%B8%89"><span class="toc-number">1.2.5.6.</span> <span class="toc-text">运行结果三</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%AF%BC%E5%85%A5"><span class="toc-number">1.3.</span> <span class="toc-text">静态导入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">1.3.1.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-1"><span class="toc-number">1.3.2.</span> <span class="toc-text">运行结果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E5%8C%85%E4%B8%AD%E5%A2%9E%E5%8A%A0%E7%B1%BB"><span class="toc-number">1.4.</span> <span class="toc-text">在包中增加类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-2"><span class="toc-number">1.4.1.</span> <span class="toc-text">程序示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JavaCore-src-Huangizhan-PackageTest"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">&#x2F;JavaCore&#x2F;src&#x2F;Huangizhan_PackageTest</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JavaCore-src-com-huangzihan-corejava"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">&#x2F;JavaCore&#x2F;src&#x2F;com&#x2F;huangzihan&#x2F;corejava</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-2"><span class="toc-number">1.4.2.</span> <span class="toc-text">运行结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AD%A6%E5%91%8A"><span class="toc-number">1.4.3.</span> <span class="toc-text">警告</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E8%AE%BF%E9%97%AE"><span class="toc-number">1.5.</span> <span class="toc-text">包访问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E8%B7%AF%E5%BE%84"><span class="toc-number">1.6.</span> <span class="toc-text">类路径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA-1"><span class="toc-number">1.6.1.</span> <span class="toc-text">提示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E8%83%BD%E5%A4%9F%E8%A2%AB%E5%A4%9A%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%85%B1%E4%BA%AB"><span class="toc-number">1.6.2.</span> <span class="toc-text">类能够被多个程序共享</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AD%A6%E5%91%8A-1"><span class="toc-number">1.6.3.</span> <span class="toc-text">警告</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E7%B1%BB%E8%B7%AF%E5%BE%84"><span class="toc-number">1.7.</span> <span class="toc-text">设置类路径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AD%A6%E5%91%8A-2"><span class="toc-number">1.7.1.</span> <span class="toc-text">警告</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AD%A6%E5%91%8A-3"><span class="toc-number">1.7.2.</span> <span class="toc-text">警告</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A-1"><span class="toc-number">1.7.3.</span> <span class="toc-text">注释</span></a></li></ol></li></ol></li></ol></div></div></div></div></body><script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script><script src="/js/plugin.js"></script><script src="/js/typed.js"></script><script src="/js/diaspora.js"></script><link rel="stylesheet" href="/photoswipe/photoswipe.css"><link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css"><script src="/photoswipe/photoswipe.min.js"></script><script src="/photoswipe/photoswipe-ui-default.min.js"></script><div class="pswp" tabindex="-1" role="dialog" aria-hidden="true"><div class="pswp__bg"></div><div class="pswp__scroll-wrap"><div class="pswp__container"><div class="pswp__item"></div><div class="pswp__item"></div><div class="pswp__item"></div></div><div class="pswp__ui pswp__ui--hidden"><div class="pswp__top-bar"><div class="pswp__counter"></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button> <button class="pswp__button pswp__button--share" title="Share"></button> <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button> <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class="pswp__preloader"><div class="pswp__preloader__icn"><div class="pswp__preloader__cut"><div class="pswp__preloader__donut"></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class="pswp__share-tooltip"></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button> <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class="pswp__caption"><div class="pswp__caption__center"></div></div></div></div></div></html><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6af129e1f4dfb540b30b7969d7e7fc32";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script>