<!DOCTYPE html><html lang="zh-CN" class="loading"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><title>存储器 - 黄子涵</title><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="google" content="notranslate"><meta name="keywords" content="黄子涵,"><meta name="description" content="存储器8086系统的主存及其分段模式
计算机的存储器包括主存（也称内存）和辅存（也称外存，如硬盘存储器）。因为CPU只能直接访问计算机的主存，所以，CPU所执行的程序和处理的数据都是存在主存中的， ,"><meta name="author" content="黄子涵"><link rel="alternative" href="atom.xml" title="黄子涵" type="application/atom+xml"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="/css/diaspora.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><meta name="generator" content="Hexo 5.4.0"><link rel="stylesheet" href="/css/prism-atom-dark.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script>
<script src="/js/prism-line-numbers.min.js"></script></head><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><body class="loading"><span id="config-title" style="display:none">黄子涵</span><div id="loader"></div><div id="single"><div id="top" style="display:block"><div class="bar" style="width:0"></div><a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://www.huangzihan.top"></a><div title="播放/暂停" class="iconfont icon-play"></div><h3 class="subtitle">存储器</h3><div class="social"><div><div class="share"><a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a></div><div id="qr"></div></div></div><div class="scrollbar"></div></div><div class="section"><div class="article"><div class="main"><h1 class="title">存储器</h1><div class="stuff"><span>五月 18, 2021</span></div><div class="content markdown"><h1 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h1><h2 id="8086系统的主存及其分段模式"><a href="#8086系统的主存及其分段模式" class="headerlink" title="8086系统的主存及其分段模式"></a>8086系统的主存及其分段模式</h2><blockquote><p>计算机的存储器包括主存（也称内存）和辅存（也称外存，如硬盘存储器）。因为CPU只能直接访问计算机的主存，所以，CPU所执行的程序和处理的数据都是存在主存中的， 程序员编程时只需与主存打交道即可。</p><p>主存需要有较大的容量，才能使计算机高效地工作。主存容量是以存储单元的数量来计算的。现在，大多数计算机以1字节（8位二进制）的大小来定义一个存储单元，即一个存储单元可以存储一个8位二进制数，并常用以下符号表示存储容量的量级：KB（2^10 字节）、MB （2^20 字节）、GB（2^30 字节）以及TB（2^40 字节）。</p><p>为了准确描述数据在主存中的存储位置，计算机系统对主存的每个存储单元（字节）从0开始连续编号，并以此编号来确定存储单元的位置。存储单元编号也称为存储单元的地址，无论是向主存存数据（也称写数据），还是从主存取数据（也称读数据），都必须指出存储单元的地址才行。</p><p>地址是存储单元的编号，地址（编号）的位数决定了主存可以拥有的最大存储单元数。一般而言，如果计算机系统的地址位数为n位（二进制位），则其主存的最大容量可以达到2^n字节。例如，8086系统的主存地址位数是20位，其主存容量最大为2^20字节=1MB；80486系统的主存地址位数是32位，其主存容量最大可达2^32字节=4GB。</p><p>地址是在CPU对主存做读/写操作时，由CPU向主存发出的。所以，地址是在CPU中形成的。对8086系统，CPU要形成20位的主存地址，但是，CPU内部用于存放地址信息的寄存器均为16位寄存器（如前所述），无法存放一个完整的主存地址，为此，8086系 统对主存的使用采取了分段模式。</p></blockquote><span id="more"></span><blockquote><p>分段模式下，一个段的最大容量被限制在64KB，即2^16字节，因此，在一个段的范围内，只需16位地址就可以准确指出每个存储单元，16位的地址也可以用16位寄存器来存放了。但是，这个16位地址只是相对于一个段的内部来定义的，称为段内地址（或段内偏移地址），并不是20位的主存实际地址（也称主存物理地址），并不能直接用来访问主存。图（段内偏移地址与物理地址的关系）所示为段内偏移地址与主存物理地址的关系。</p></blockquote><center><img src="/2021/05/18/%E5%AD%98%E5%82%A8%E5%99%A8/段内偏移地址与物理地址的关系.png" width="50%" height="50%"> 段内偏移地址与物理地址的关系</center><blockquote><p>图（段内偏移地址与物理地址的关系）中，从物理地址处开始，定义了一个段，物理地址i称为该段的段首地址，简称段地址。显然，段内一个存储单元的物理地址是该存储单元的段内偏移地址与该段的段地址之和。由此可见，要得到段内一个存储单元的物理地址，除了需要该存储单元的段内偏移地址，还必须有该段的段地址。也就是说，在8086系统的主存分段模式下，一个存储单元的地址要用段地址和段内偏移地址两部分表示，这样表示的地址也称为逻辑地址，是汇编语言程序设计时所用的地址表示形式。</p><p>由于段地址本身是一个20位的物理地址，而CPU中用来存放段地址的段寄存器均为16位寄存器，如何解决这个矛盾呢？为此，8086系统规定，只有能被16整除的物理地址才能作为段地址；这样的物理地址其二进制表示形式有如下特征：</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">xxxxxxxxxxxxxxxx0000<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>其中，X表示0或1。由于段地址的最低4位必为0，所以，CPU中的段寄存器实际只存放了段地址的高16位，这就解决了段地址在CPU中的表示问题。而CPU中专设的地址加法器，会在将逻辑地址转换成物理地址时，自动在16位段地址低位部分添加4个0，然后再与段内偏移地址相加。</p></blockquote><h3 id="8086系统中，逻辑地址通常表示为"><a href="#8086系统中，逻辑地址通常表示为" class="headerlink" title="8086系统中，逻辑地址通常表示为"></a>8086系统中，逻辑地址通常表示为</h3><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">段地址：段内偏移地址<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>的格式。设某存储单元的逻辑地址用十六进制表示为138D：0200，求该存储单元的物理地址。</p><p>解：首先在段地址低位添0（对十六进制，只需添一个0），得到实际的段首地址138D0H，然后再与段内偏移地址0200H相加</p></blockquote><pre class="line-numbers language-C/C++" data-language="C/C++"><code class="language-C/C++">138D0H + 0200H &#x3D; 13AD0H<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>所以，该存储单元的物理地址为13AD0H（二进制表示为00010011101011010000）。</p></blockquote><h2 id="数据在主存中的存储方式"><a href="#数据在主存中的存储方式" class="headerlink" title="数据在主存中的存储方式"></a>数据在主存中的存储方式</h2><blockquote><p>8086系统中，根据数据的位数不同，定义了以下几种数据类型。</p><ol><li>字节类型：数据位数为8位（1字节），在主存中存储时占用1个存储单元。</li><li>字类型：数据位数为16位（2字节），在主存中存储时占用2个存储单元。</li><li>双字类型：数据位数为32位（4字节），在主存中存储时占用4个存储单元。</li><li>四字类型：数据位数为64位（8字节），在主存中存储时占用8个存储单元。</li><li>十字节类型：数据位数为80位（10字节），在主存中存储时占用10个存储单元。</li></ol><p>可见，数据位数均为字节的整数倍；位数多于1字节的，称为多字节数据。一个多字节数据在主存中存储时，需要占用地址连续的多个存储单元，数的低位字节存储在地址较低的存储单元，而该多字节数所占用的最低地址，就作为该数的地址。图（多字节数存储示例）所示为双字数据3A625C89H在主存中的存储情况，该数的地址为21004H。</p></blockquote><center><img src="/2021/05/18/%E5%AD%98%E5%82%A8%E5%99%A8/段内偏移地址与物理地址的关系.png" width="50%" height="50%"> 段内偏移地址与物理地址的关系</center><!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]--><audio id="audio" loop preload="auto" controls data-autoplay="true"><source type="audio/mpeg" src=""></audio><ul id="audio-list" style="display:none"><li title="0" data-url="https://link.hhtjim.com/163/4989670.mp3"></li><li title="1" data-url="https://link.hhtjim.com/163/214374.mp3"></li><li title="2" data-url="https://link.hhtjim.com/163/443794.mp3"></li><li title="3" data-url="https://link.hhtjim.com/163/28188450.mp3"></li><li title="4" data-url="https://link.hhtjim.com/163/29816860.mp3"></li><li title="5" data-url="https://link.hhtjim.com/163/4940920.mp3"></li><li title="6" data-url="https://link.hhtjim.com/163/443860.mp3"></li><li title="7" data-url="https://link.hhtjim.com/163/4940920.mp3"></li><li title="8" data-url="https://link.hhtjim.com/163/1825230064.mp3"></li><li title="9" data-url="https://link.hhtjim.com/163/27570832.mp3"></li><li title="10" data-url="https://link.hhtjim.com/163/28285777.mp3"></li><li title="11" data-url="https://link.hhtjim.com/163/68622.mp3"></li><li title="12" data-url="https://link.hhtjim.com/163/4968365.mp3"></li><li title="13" data-url="https://link.hhtjim.com/163/4968352.mp3"></li><li title="14" data-url="https://link.hhtjim.com/163/28378263.mp3"></li><li title="15" data-url="https://link.hhtjim.com/163/1461262038.mp3"></li><li title="16" data-url="https://link.hhtjim.com/163/1821680008.mp3"></li><li title="17" data-url="https://link.hhtjim.com/163/1404997257.mp3"></li></ul></div></div><div class="side"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.</span> <span class="toc-text">存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8086%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%BB%E5%AD%98%E5%8F%8A%E5%85%B6%E5%88%86%E6%AE%B5%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">8086系统的主存及其分段模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8086%E7%B3%BB%E7%BB%9F%E4%B8%AD%EF%BC%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E9%80%9A%E5%B8%B8%E8%A1%A8%E7%A4%BA%E4%B8%BA"><span class="toc-number">1.1.1.</span> <span class="toc-text">8086系统中，逻辑地址通常表示为</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%9C%A8%E4%B8%BB%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text">数据在主存中的存储方式</span></a></li></ol></li></ol></div></div></div></div></body><script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script><script src="/js/plugin.js"></script><script src="/js/typed.js"></script><script src="/js/diaspora.js"></script><link rel="stylesheet" href="/photoswipe/photoswipe.css"><link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css"><script src="/photoswipe/photoswipe.min.js"></script><script src="/photoswipe/photoswipe-ui-default.min.js"></script><div class="pswp" tabindex="-1" role="dialog" aria-hidden="true"><div class="pswp__bg"></div><div class="pswp__scroll-wrap"><div class="pswp__container"><div class="pswp__item"></div><div class="pswp__item"></div><div class="pswp__item"></div></div><div class="pswp__ui pswp__ui--hidden"><div class="pswp__top-bar"><div class="pswp__counter"></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button> <button class="pswp__button pswp__button--share" title="Share"></button> <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button> <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class="pswp__preloader"><div class="pswp__preloader__icn"><div class="pswp__preloader__cut"><div class="pswp__preloader__donut"></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class="pswp__share-tooltip"></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button> <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class="pswp__caption"><div class="pswp__caption__center"></div></div></div></div></div></html><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6af129e1f4dfb540b30b7969d7e7fc32";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script>