{"meta":{"title":"黄子涵","subtitle":"MDZG-JEG.4","description":"","author":"黄子涵","url":"http://www.huangzihan.top","root":"/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"08-17","excerpt":""},{"title":"子涵酱","text":"基本资料 姓名：黄子涵 籍贯：广东湛江 毕业院校：五邑大学 专业：电子信息工程 联系电话：19124896017","path":"about/index.html","date":"04-04","excerpt":""},{"title":"分类","text":"","path":"categories/index.html","date":"04-07","excerpt":""},{"title":"搜索","text":"","path":"search/index.html","date":"04-07","excerpt":""},{"title":"标签","text":"","path":"tags/index.html","date":"04-07","excerpt":""}],"posts":[{"title":"HTML5背景知识","text":"HTML5背景知识 HTML（Hypertext MarkupLanguage，超文本标记语言）诞生于20世纪90年代初。1993年或1994年，那时浏览器只有NCSA Mosaic这一种，Web服务器的种类也屈指可数。 HTML的历史JavaScript出场 JavaScript语言（虽然取了这么一个名字，但是它跟Java程序设计语言基本上没有什么关系）出自一家名为网景的公司。它的出现标志着内嵌在Web浏览器中的客户端脚本程序控制功能的发端。原本是一种静态内容载体的HTML因此变得有点丰富起来。之所以说“有点丰富”，是因为现在我们在浏览器中见到的这种复杂交互方式是经过一段时间的发展之后才形成的。 JavaScript并非HTML规范核心的组成部分，然而Web浏览器、HTML和JavaScript之间是如此紧密，以至于根本无法将它们分开讨论。HTML5规范假定可以使用JavaScript，而且要想使用HTML5中新增的一些最为引人注目的特性也需要用到JavaScript。 出自一家名为网景的公司。它的出现标志着内嵌在Web浏览器中的客户端脚本程序控制功能的发端。原本是一种静态内容载体的HTML因此变得有点丰富起来。之所以说“有点丰富”，是因为现在我们在浏览器中见到的这种复杂交互方式是经过一段时间的发展之后才形成的。JavaScript并非HTML规范核心的组成部分，然而Web浏览器、HTML和JavaScript之间的关系是如此紧密，以至于根本无法将它们分开讨论。HTML5规范假定可以使用JavaScript，而且要想使用HTML5中新增的一些最为引人注目的特性也需要用到JavaScript。 浏览器战争的结束 浏览器市场也有过激烈的竞争。主要的角逐者是微软和网景，它们都把在自己的浏览器中添加一些独有的特性当做竞争手段。其如意算盘是这样打的：诱人的专有特性会诱使开发人员制作出只能在特定浏览器上使用的内容，而诱人的内容又会诱使用户对能提供这种内容的浏览器青睐有加，由此市场霸业可成。 可惜人算不如天算。这样做的结果是Web开发人员要么只使用那些所有浏览器都有的特性，要么煞费苦心地想些变通办法来使用各款浏览器中勉强相当的那些特性。这不啻为一种煎熬，而且其后遗症直到现在仍然在影响Web开发。 微软用免费提供IE来与网景收费的Navigator抢生意，这一招儿后来被认定违反垄断法。很多人指责微软是网景垮台的罪魁祸首。这一指控或许不无道理，不过在我这个曾在那段时期为网景做过大约18个月顾问的人看来，我从没见过像它那样一根筋地自残的公司。有些公司注定要成为别人的前车之鉴，网景就是其中之一。 浏览器战争以网景倒台及微软受到惩处结束，为基于标准的网络浏览奠定了基础。HTML规范有了改进，遵从这个规范成了准则。现在的浏览器需要凭遵守标准的程度来竞争。这是一次天翻地覆的转折，开发人员和用户均受益于此。 插件称雄 插件是Web世界的“益虫”。它们可以提供一些单用HTML很难实现的高级特性和丰富内容。有些插件特性如此丰富、部署如此普遍，以至于不少网站只提供用于这种插件的内容。Adobe公司的Flash正是这样一个典型。我经常见到完全用Flash实现的网站。按说这也没什么不妥，不过这就意味着浏览器和HTML除了Flash容器一职外再无他用。 浏览器开发商看插件不顺眼，因为它把控制权转移到了插件开发商手中。HTML5的一大改进就是着力于让浏览器直接处理那些原来要使用Flash的富内容（rich content）。苹果和微软是疏远Flash的两个急先锋。前者的iOS不支持Flash，后者则在Windows8附带的Metro风格的IE正中禁用了Flash。 语义HTML浮出水面 HTML标准的早期版本不太关心将内容的意义与其呈现方式分开。想表示一段文字的重要性，使用一个让文字显示为粗体的HTML元素就是了。把粗体内容与重要内容关联起来是用户的事。这对人类用户来说很容易，却会让自动化工具犯难。自HTML初次亮相以来，对内容进行自动处理日趋重要，人们也越来越致力于分开HTL元素的意义与内容在浏览器中的呈现方式。 发展态势：HTML标准滞后于其使用 制定标准一般都是一个长期过程，像HTML这种应用广泛的技术更是如此。参与方众多，每家都想把新标准往符合自己利益或观点的方向引。而标准并不是法律，标准制定机构害怕分裂甚于一切。因此对于未来的特性和改进该当如何，各方经常陷入旷日持久的讨价还价。 负责制定HTML标准的是W3C（World Wide Web Consortium，万维网联盟）。这是一项棘手的任务。一条提案要花不少时间才能成为标准。而对HTML核心规范的修改则需经过很长时间才会得到批准。 冗长的标准制定过程带来的结果就是W3C总是要多绕一些路，总是在将已经被大家接受的实际做法追认为标准。HTML规范反映的只是几年前关于Web内容的前沿思考。这削弱了HTML标准的重要性，因为真正的革新并非来自W3C，而是来自浏览器和插件。 HTML5简介 HTML5不仅仅是HTML规范的最新版本，它还是一系列用来制作现代富Web内容的总称。最重要的三项技术是HTML5核心规范、CSS(Cascading Style Sheets，层叠样式表）和JavaScript。 HTML5核心规范定义用以标记内容的元素，并明确其含义。CSS可用于控制标记现在用户面前的外貌。JavaScript则可以用来操纵HTML文档的内容以及响应用户的操作，此外想使用HTML5新增元素的一些为编程目的设计的特性也需要用到JavaScript。 有些人（那些挑剔、执拗、爱钻牛角尖的人）会说HTML5所指的只是HTML元素。别管他们。这些人看不出Web内容的本质所发生的根本性变化。用于网页的各种技术之间的关联已经变得如此紧密，以致于需要通晓这些技术才能制作Web内容。如果只使用HTML元素，不用CSS，这样制作出来的内容会让用户觉得不便阅读。如果用了HTML和CSS，但不用JavaScript，那就无法为用户的操作提供即时反馈，也无法使用HTML5中的一些高级特性。 新标准 为了应对漫长的标准化过程以及标准落后于常见用法的情况，HTML5及其相关技术是作为一系列小型标准而制定的。其中有些标准只有区区几页，涉及的只是某项特性中一个高度细化的方面。当然，其他一些标准仍然有密密麻麻的几百页，涵盖了相关功能的所有方面。 这样做的目的是让较小的团体可以合作设计和将对他们较为重要的特性标准化，争议较少的特性可以先标准化，不必受围绕其他特性发生的争论的拖累。 这个办法有利也有弊。好处是可以加快标准制定步伐。主要的弊端在于难以全面掌握制定中的各个标准的情况以及这些标准之间的关系。技术规范的质量也有所下降。有些标准中存在着一些歧义，致使浏览器中的实现出现了不一致的情况。 最大的不足之处大概要算没有一条可用来评估HTML5达标情况的基准线。我们现在还处于初始阶段，但是不能指望用户可能用到的所有浏览器都实现了要用的特性。因此采用HTML5中的特性是件复杂的事情，需要仔细评估相关标准得到支持的情况。W3C公布过一个正式的HTML5徽标，但是它并不代表对HTML5标准及相关技术的全面支持。 引入原生多媒体支持 HTML5的一大改进就是支持在浏览器中直接播放视频和音频文件（也就是说不借助于插件）。这是W3C对插件风靡现象的一种反应。原生（native）多媒体支持再结合其他HTML特性可望大有作为。 引入可编程内容 HTML5最大的变化之一是添加了canvas元素。这个元素是对插件现象的另一反应，它提供了一个通用的绘图平面，开发人员可以用它完成一些通常用AdobeFlash来完成的任务。 这个特性之所以重要，部分原因在于要使用canvas元素就必须用到JavaScript。编程从而成了HTML文档中第一层次的事情，这是一个重大转变。 引入语义Wvb HTML5引入了一些用来分开元素的含义和内容呈现方式的特性和规则。这是HTML5中的一个重要概念，它标志着HTML在走向成熟的道路上又迈上了一个新台阶，反映出制作和使用HTML内容的方式的多样性。这个变化（它逐步体现在之前的HTML版本中）稍稍增加了Web开发者的负担，这是因为开发者需要先标记内容然后再定义其呈现方式。不过有些实用的新改进可以减轻这种负担。 HTML5现况 HTML5的核心标准目前仍在制定过程中，一时完成不了。不过，标准正式出炉还得等上好些年，而最终版本与目前版本可能出入不大。 浏览器对HTML5的支持情况 最流行的那些浏览器都已经实现了许多HTML特性。然而，不是每款浏览器都支持所有的特性。在把某个特性用到实际项目之前，应该先核查一下浏览器是否支持这个特性。有些浏览器（例如Chrome和Firefox）的升级近乎持续不断。考虑到HTML标准的分散本性，使用Modernizr（http://www.modernizr.com） 之类的JavaScript库检查特性是可行的。使用Modernizr，可以用编程的方式判断用户使用的浏览器是否支持关键的HTML特性，籍此可以决定在文档中应该使用哪些特性。 习惯未雨绸缪的读者可以参考一下When Can IUse？网站（http:/caniuse.com）。上面提供了浏览器的支持情况和采用率方面的详细信息，并且勤于修订。 网站对HTML5的支持情况 用到HTML5特性的网站日益增多。其中有些属于示范性网站，是用来演示HTML特性的。但是能利用浏览器对HTML5的支持的实用型网站也越来越多。YouTube就是一个典型，它现在已经提供让浏览器直接播放的视频——当然，它还为较老的浏览器提供Flash视频。","path":"2021/08/21/HTML5背景知识/","date":"08-21","excerpt":"","tags":[]},{"title":"绩效考核（暂行）","text":"绩效考核（暂行）考核内容 copy内容以及项目内容，自我答辩 copy（30%）+ 自我答辩（70%）= 等级 大考不考虑copy copycopy考核标准 copy 得分 得分系数 &lt;100k &lt;60 0.3 100k 60 ~ 64 0.75 150k 65 ~ 74 0.8 200k 75 ~ 79 0.85 250k 80 ~ 89 0.9 &gt;300k 100 ~ 90 1.05 copy数量 copy日期 copy数量 2021-07-22 254k row 2 col 1 row 2 col 2 答辩答辩内容 面试题+知识点 答辩考核标准 AT：答题时间 AAT：平均答题时间 TGA：答题时间大于平均答题时间 TLA：答题时间小于平均答题时间 AN：答题数量 ANA：平均答题数量 NGA：答题数量大于平均答题数量 GLA：答题数量小于平均答题数量 考核AT绩效考核 AT 得分 TGA C AAT B TLA A AN绩效考核 AN 得分 NGA A ANA B GLA C 绩效考核 等级 得分 得分系数 AA 100 ~ 90 1.05 AB 80 ~ 89 0.9 AC 75 ~ 79 0.85 BB 65 ~ 74 0.8 BC 60 ~ 64 0.75 CC &lt;60 0.3 答辩记录 答辩日期 答题时间 答题数量 . . . . . . 平均 考核频次 小考：Week/Per 大考：项目复盘 奖惩 等级 header 2 奖惩 S 75 ~ 100 ↑ 1 A 50 ~ 74 → B 25 ~ 49 ↓ 1 C 0 ~ 24 ↓ 2","path":"2021/07/23/绩效考核（暂行）/","date":"07-23","excerpt":"","tags":[]},{"title":"子涵集团移动端事业部MDZG职级体系","text":"","path":"2021/07/22/子涵集团移动端事业部MDZG职级体系/","date":"07-22","excerpt":"","tags":[]},{"title":"类、超类和子类","text":"类、超类和子类 假设你在某个公司工作，这个公司里经理的待遇与普通员工的待遇存在着一些差异。不过，他们之间也存在着很多相同的地方，例如，他们都领取薪水。只是普通员工在完成本职任务之后仅领取薪水，而经理在完成了预期的业绩之后还能得到奖金。这种情形就需要使用继承。为什么呢？因为需要为经理定义一个新类Manager，并增加一些新功能。但可以重用Employee类中已经编写的部分代码，并保留原来Employee类中的所有字段。从理论上讲，在Manager与Employee之间存在着明显的“is-a”（是）关系，每个经理都是一个员工：“is-a”关系是继承的一个明显特征。 注释 这一章中，我们使用了员工和经理的经典示例，不过必须提醒你的是对这个例子要有所保留。在真实世界里，员工也可能会成为经理，所以你建模时可能希望经理 也是员工，而不是员工的一个子类。不过，在我们的例子中，假设公司里只有两类人：一些人永远是员工，另一些人一直是经理。 定义子类 可以如下继承Employee类来定义Manager类，这里使用关键字extends表示继承。 public class Manager extends Employee &#123; added methods and fields &#125; 关键字extends 关键字extends表明正在构造的新类派生于一个已存在的类。这个已存在的类称为超类（superclass）、基类（base class）或父类（parent class）；新类称为子类（subclass）、派生类（derived class） 或孩子类（child class）。超类和子类是Java程序员最常用的两个术语，而了解 其他语言的程序员可能更加偏爱使用父类和孩子类，这也能很贴切地体现“继承”。 尽管Employee类是一个超类，但并不是因为它优于子类或者拥有比子类更多的功能。实际上恰恰相反，子类比超类拥有的功能更多。例如，看过Manager类的源代码之后就会发现，Manager类比超类Employee封装了更多的数据，拥有更多的功能。 注释 前缀“超“（super）和“子”（sub）来源于计算机科学与数学理论中集合语言的术语。所有员工组成的集合包含所有经理组成的集合。可以这样说，员工集合是经理集合的超集，也可以说，经理集合是员工集合的子集。 在Manager类中，增加了一个用于存储奖金信息的字段，以及一个用于设置这个字段的新方法： public class Manager extends Employee &#123; private double bonus; . . . public void setBonus(double bonus) &#123; this.bonus &#x3D; bonus; &#125; &#125; 这里定义的方法和字段并没有什么特别之处。如果有一个Manager对象，就可以使用setBonus方法。 Manager boss &#x3D; . . .; boss.setBonus(5000); 当然，由于setBonus方法不是在Employee类中定义的，所以属于Employee类的对象不能使用它。 然而，尽管在Manager类中没有显式地定义getName和getHireDay等方法，但是可以对Manager对象使用这些方法，这是因为Manager类自动地继承了超类Employee中的这些方法。 类似地，从超类中还继承了name、salary和hireDay这3个字段。这样一来，每个Manager对象就包含了4个字段：name、salary、hireDay和bonus。 通过扩展超类定义子类的时候，只需要指出子类与超类的不同之处。因此在设计类的时候，应该将最一般的方法放在超类中，而将更特殊的方法放在子类中，这种将通用功能抽取到超类的做法在面向对象程序设计中十分普遍。 覆盖方法 超类中的有些方法对子类Manager并不一定适用。具体来说，Manager类中的getSalary方法应该返回薪水和奖金的总和。为此，需要提供一个新的方法来覆盖（override）超类中的这个方法： public class Manager extends Employee &#123; . . . public double getSalary() &#123; . . . &#125; . . . &#125; 应该如何实现这个方法呢？乍看起来似乎很简单，只要返回salary和bonus字段的总和就可以了： public double getSalary() &#123; return salary + bonus; &#x2F;&#x2F; won&#39;t work &#125; 不过，这样做是不行的。回想一下，只有Employee方法能直接访问Employee类的私有字段。这意味着，Manager类的getSalary方法不能直接访问salary字段。如果Manager类的方法想要访问那些私有字段，就要像所有其他方法一样使用公共接口，在这里就是要使用Employee类中的公共方法getSalary。 现在，再试一下。你需要调用getSalary方法而不是直接访问salary字段： public double getSalary() &#123; double baseSalary &#x3D; getSalary(); &#x2F;&#x2F; still won&#39;t work return baseSalary + bonus; &#125; 上面这段代码仍然有问题。问题出现在调用getSalary的语句上，它只是在调用自身，这是因为Manager类也有一个getSalary方法（就是我们正在实现的这个方法），所以这条语句将会导致无限次地调用自己，直到整个程序最终崩溃。 关键字super 这里需要指出：我们希望调用超类Employee中的getSalary方法，而不是当前类的这个方法。为此，可以使用特殊的关键字super解决这个问题： super.getSalary() 这个语句调用的是Employee类中的getSalary方法。下面是Manager类中getSalary方法的正确版本： public double getSalary() &#123; double baseSalary &#x3D; super.getSalary(); return baseSalary + bonus; &#125; 注释 有些人认为super与this引用是类似的概念，实际上，这样比较并不太恰当。 这是因为super不是一个对象的引用，例如，不能将值super赋给另一个对象变量，它只是一个指示编译器调用超类方法的特殊关键字。 正像前面所看到的那样，在子类中可以增加字段、增加方法或覆盖超类的方法，不过，继承绝对不会删除任何字段或方法。 子类构造器 在例子的最后，我们来提供一个构造器。 public Manager(String name, double salary, int year, int month, int day) &#123; super(name, salary, year, month, day); bonus &#x3D; 0; &#125; 这里的关键字super具有不同的含义。语句 super(name, salary, year, month, day); 是“调用超类Employee中带有n、s、year、month和day参数的构造器”的简写形式。 由于Manager类的构造器不能访问Employee类的私有字段，所以必须通过一个构造器来初始化这些私有字段。可以利用特殊的super语法调用这个构造器。使用super调用构造器的语句必须是子类构造器的第一条语句。 如果子类的构造器没有显式地调用超类的构造器，将自动地调用超类的无参数构造器。如果超类没有无参数的构造器，并且在子类的构造器中又没有显式地调用超类的其他构造器，Java编译器就会报告一个错误。 注释关键字this和super的含义 回想一下，关键字this有两个含义：一是指示隐式参数的引用，二是调用该类的其他构造器。类似地，super关键字也有两个含义：一是调用超类的方法，二是调用超类的构造器。在调用构造器的时候，this和super这两个关键字紧密相关。调用构造器的语句只能作为另一个构造器的第一条语句出现。构造器参数可以传递给当前类（this）的另一个构造器，也可以传递给超类（super）的构造器。 重新定义Manager对象的getSalary方法之后，奖金就会自动地添加到经理的薪水中。 下面给出一个例子来说明这个类的使用。我们要创建一个新经理，并设置他的奖金： Manager boss &#x3D; new Manager(&quot;Carl Cracker&quot;, 80000, 1987, 12, 15); boss.setBonus(5000); 下面定义一个包含3个员工的数组： var staff &#x3D; new Employee[3]; 在数组中混合填入经理和员工： staff[0] &#x3D; boss; staff[l] &#x3D; new Employee(&quot;Harry Hacker&quot;, 50000, 1989, 10, 1); staff[2] &#x3D; new Employee(&quot;Tony Tester&quot;, 40000, 1990, 3, 15); 输出每个人的薪水： for (Employee e : staff) System.out.println(e.getName() + &quot; &quot; + e.getSalary()); 运行这条循环语句将会输出下列数据： Carl Cracker 85000.0 Harry Hacker 50000.0 Tommy Tester 40000.0 这里的staff[1]和staff[2]仅输出了基本薪水，这是因为它们是Employee对象，而staff[0] 是一个Manager对象，它的getSalary方法会将奖金与基本薪水相加。 需要提醒大家的是，以下调用 e.getSalary() 能够选出应该执行的正确getSalary方法。请注意，尽管这里将e声明为Employee类型，但实际上e既可以引用Employee类型的对象，也可以引用Manager类型的对象。 当e引用Employee对象时，e.getSalary()调用的是Employee类中的getSalary方法；当e引用Manager对象时，e.getSalary()调用的是Manager类中的getSalary方法。虚拟机知道e实际引用的对象类型，因此能够正确地调用相应的方法。 多态（polymorphism）和动态绑定（dynamic binding） 一个对象变量（例如，变量e）可以指示多种实际类型的现象称为多态（polymorphism）。在运行时能够自动地选择适当的方法，称为动态绑定（dynamic binding）。 下面的程序展示了Employee对象与Manager对象在薪水计算上的区别。 程序示例inheritance/Huangzihan_Employee.javapackage inheritance; import java.time.*; public class Huangzihan_Employee &#123; private String huangzihan_name; private double huangzihan_salary; private LocalDate huangzihan_hireDay; public Huangzihan_Employee(String huangzihan_name, double huangzihan_salary, int huangzihan_year, int huangzihan_month, int huangzihan_day) &#123; this.huangzihan_name &#x3D; huangzihan_name; this.huangzihan_salary &#x3D; huangzihan_salary; huangzihan_hireDay &#x3D; LocalDate.of(huangzihan_year, huangzihan_month, huangzihan_day); &#125; public String huangzihan_getName() &#123; return huangzihan_name; &#125; public double huangzihan_getSalary() &#123; return huangzihan_salary; &#125; public LocalDate huangzihan_getHireDay() &#123; return huangzihan_hireDay; &#125; public void huangzihan_raiseSalary(double huangzihan_byPercent) &#123; double huangzihan_raise &#x3D; huangzihan_salary * huangzihan_byPercent &#x2F; 100; huangzihan_salary +&#x3D; huangzihan_raise; &#125; &#125; inheritance/Huangzihan_Manager.javapackage inheritance; public class Huangzihan_Manager extends Huangzihan_Employee &#123; private double huangzihan_bonus; &#x2F;* * @param huangzihan_name 雇员的姓名 * @param huangzihan_salary 工资 * @param huangzihan_year 雇佣年份 * @param huangzihan_month 雇佣月份 * @param huangzihan_day 雇佣天数 * *&#x2F; public Huangzihan_Manager(String huangzihan_name, double huangzihan_salary, int huangzihan_year, int huangzihan_month, int huangzihan_day) &#123; super(huangzihan_name, huangzihan_salary, huangzihan_year, huangzihan_month, huangzihan_day); huangzihan_bonus &#x3D; 0; &#125; public double huangzihan_getSalary() &#123; double huangzihan_baseSalary &#x3D; super.huangzihan_getSalary(); return huangzihan_baseSalary + huangzihan_bonus; &#125; public void huangzihan_setBonus(double huangzihan_b) &#123; huangzihan_bonus &#x3D; huangzihan_b; &#125; &#125; inheritance/Huangzihan_ManagerTest.javapackage inheritance; &#x2F;* @功能：这个程序演示了继承。 * @版本：1.21 * @时间：2021-07-21 * @作者：黄子涵 * *&#x2F; public class Huangzihan_ManagerTest &#123; public static void main(String[] huangzihan_args) &#123; &#x2F;&#x2F; 构造一个Manager对象 Huangzihan_Manager huangzihan_boss &#x3D; new Huangzihan_Manager(&quot;huangzihan&quot;, 80000, 1987, 12, 15); huangzihan_boss.huangzihan_setBonus(5000); var huangzihan_staff &#x3D; new Huangzihan_Employee[3]; &#x2F;&#x2F; 用Manager和Employee对象填充人员数组 huangzihan_staff[0] &#x3D; huangzihan_boss; huangzihan_staff[1] &#x3D; new Huangzihan_Employee(&quot;Huangzihan&quot;, 50000, 1989, 10, 1); huangzihan_staff[2] &#x3D; new Huangzihan_Employee(&quot;huang_zihan&quot;, 40000, 1990, 3, 15); &#x2F;&#x2F; 打印出所有Employee对象的信息 for(Huangzihan_Employee huangzihan_e : huangzihan_staff) &#123; System.out.println(&quot;名字&#x3D;&quot; + huangzihan_e.huangzihan_getName() + &quot;，工资&#x3D;&quot; + huangzihan_e.huangzihan_getSalary()); &#125; &#125; &#125; 运行结果名字&#x3D;huangzihan，工资&#x3D;85000.0 名字&#x3D;Huangzihan，工资&#x3D;50000.0 名字&#x3D;huang_zihan，工资&#x3D;40000.0 继承层次继承链（inheritance chain） 继承并不仅限于一个层次。例如，可以由Manager类派生Executive类。由一个公共超类派生出来的所有类的集合称为继承层次（inheritancehierarchy），如图（Employee继承层次）所示。在继承层次中，从某个特定的类到其祖先的路径称为该类的继承链（inheritance chain）。 Employee继承层次 通常，一个祖先类可以有多个子孙链。例如，可以由Employee类派生出子类 Programmer和Secretary，它们与Manager类没有任何关系（它们彼此之间也没有任何关系）。必要的话，可以将这个过程一直延续下去。 多态 有一个简单规则可以用来判断是否应该将数据设计为继承关系，这就是“is-a”规则，它指出子类的每个对象也是超类的对象。例如，每个经理都是员工，因此，将Manager类设计为Employee类的子类是有道理的；反之则不然，并不是每一名员工都是经理。 替换原则（substitution principle） “is-a”规则的另一种表述是替换原则（substitutionprinciple）。它指出程序中岀现超类对象的任何地方都可以使用子类对象替换。 例如，可以将子类的对象赋给超类变量。 Employee e; e &#x3D; new Employee(. . .); &#x2F;&#x2F; Employee object expected e &#x3D; new Managerf(. . .)；&#x2F;&#x2F; OK, Manager can be used as well 在Java程序设计语言中，对象变量是多态的（polymorphic.）。一个Employee类型的变量既可以引用一个Employee类型的对象，也可以引用Employee类的任何一个子类的对象（例如，Manager、Executive、Secretary等)。 在程序（inheritance/Huangzihan_ManagerTest.java）中，我们就利用了这个替换原则： Manager boss &#x3D; new Manager(...); Employee[] staff &#x3D; new Employee[3]; staff[0] &#x3D; boss; 在这个例子中，变量staff[0]与boss引用同一个对象。但编译器只将staff[0]看成是一个Employee对象。这意味着，可以这样调用 boss.setBonus(5000); &#x2F;&#x2F; OK 但不能这样调用 staff[0].setBonus(5000); &#x2F;&#x2F; ERROR 这是因为staff[0]声明的类型是Employee，而setBonus不是Employee类的方法。 不过，不能将超类的引用赋给子类变量。例如，下面的赋值是非法的： Manager m &#x3D; staff[i]; &#x2F;&#x2F; ERROR 原因很清楚：不是所有的员工都是经理。如果赋值成功，m有可能引用了一个不是经理的Employee对象，而在后面有可能会调用m.setBonusf(…)，这就会发生运行时错误。 警告 在Java中，子类引用的数组可以转换成超类引用的数组，而不需要使用强制类 型转换。例如，下面是一个经理数组 Manager[] managers &#x3D; new Manager[10]; 将它转换成Employee[]数组完全是合法的： Employee[] staff &#x3D; managers; &#x2F;&#x2F; OK 这样做肯定不会有问题，请思考一下其中的缘由。毕竟，如果manager[i]是一个Manager，它也一定是一个Employee。不过，实际上将会发生一些令人惊讶的事情。要切记managers和staff引用的是同一个数组。现在看一下这条语句： staff[0] &#x3D; new Employee(&quot;Harry Hacker&quot;, . . .); 编译器竟然接纳了这个赋值操作。但在这里，staff[0]与manager[0]是相同的引用，似乎我们把一个普通员工擅自归入经理行列中了。这是一种很不好的情形，当调用managers[0].setBonus(1000)的时候，将会试图调用一个不存在的实例字段，进而搅乱相邻存储空间的内容。 为了确保不发生这类破坏，所有数组都要牢记创建时的元素类型，并负责监督仅 将类型兼容的引用存储到数组中。例如，使用new managers[10]创建的数组是一个经理数组。如果试图存储一个Employee类型的引用就会引发ArrayStoreException异常。 理解方法调用 准确地理解如何在对象上应用方法调用非常重要。下面假设要调用x.f(args)，隐式参数x声明为类C的一个对象。下面是调用过程的详细描述： 编译器查看对象的声明类型和方法名。需要注意的是：有可能存在多个名字为f但参数类型不一样的方法。例如，可能存在方法f(int)和方法f(String)。编译器将会一一列举C类中所有名为f的方法和其超类中所有名为f而且可访问的方法（超类的私有方法不可访问）。 至此，编译器已知道所有可能被调用的候选方法。 重载解析（overloading resolution） 接下来，编译器要确定方法调用中提供的参数类型。如果在所有名为f的方法中存在一个与所提供参数类型完全匹配的方法，就选择这个方法。这个过程称为重载解析（overloading resolution）。例如，对于调用x.f(“Hello”)，编译器将会挑选f(String)，而不是f(int)。由于允许类型转换（int可以转换成double， Manager以转换成Employee，等等)，所以情况可能会变得很复杂。如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，编译器就会报告一个错误。 至此，编译器已经知道需要调用的方法的名字和参数类型。 注释 前面曾经说过，方法的名字和参数列表称为方法的签名。例如，f(int)和f(String)是两个有相同名字、不同签名的方法。如果在子类中定义了一个与超类签名相同的方法，那么子类中的这个方法就会覆盖超类中这个相同签名的方法。 返回类型不是签名的一部分。不过在覆盖一个方法时，需要保证返回类型的兼容 性。允许子类将覆盖方法的返回类型改为原返回类型的子类型。例如，假设Employee类有以下方法： public Employee getBuddyf() &#123; . . . &#125; 经理不会想找这种底层员工作搭档。为了反映这一点，在子类Manager中，可以如下覆盖这个方法： public Manager getBuddyf() &#123; . . . &#125; &#x2F;&#x2F; OK to change return type 我们说，这两个getBuddy方法有可协变的返回类型。 静态绑定（static binding） 如果是private方法、static方法、final方法或者构造器，那么编译器将可以准确地知道应该调用哪个方法。这称为静态绑定（static binding）。与此对应的是，如果要调用的方法依赖于隐式参数的实际类型，那么必须在运行时使用动态绑定。编译器会利用动态绑定生成一个调用f(String)的指令。 程序运行并且采用动态绑定调用方法时，虚拟机必须调用与x所引用对象的实际类型对应的那个方法。假设x的实际类型是D，它是C类的子类。如果D类定义了方法f(String)，就会调用这个方法；否则，将在D类的超类中寻找f(String)，以此类推。 方法表（method table） 每次调用方法都要完成这个搜索，时间开销相当大。因此，虚拟机预先为每个类计算了一个方法表（method table），其中列岀了所有方法的签名和要调用的实际方法。这样一来，在真正调用方法的时候，虚拟机仅查找这个表就行了。在前面的例子中，虚拟机搜索D类的方法表，寻找与调用f(Sting)相匹配的方法。这个方法既有可能是D.f(String)，也有可能是X.f(String)，这里的X是D的某个超类。这里需要提醒一点，如果调用是super.f(param)，那么编译器将对隐式参数超类的方法表进行搜索。 现在来详细分析程序（inheritance/Huangzihan_ManagerTest.java）中调用e.getSalary()的过程。e声明为Employee类型。Employee类只有一个名叫getSalary的方法，这个方法没有参数。因此，在这里不必担心重载解析的问题。 由于getSalary不是private方法、static方法或final方法，所以将釆用动态绑定。虚拟机为Employee和Manager类生成方法表。在Employee的方法表中列出了这个Employee类本身定义的所有方法： Employee: getName() -&gt; Employee.getName() getSalary() -&gt; Employee.getSalary() getHireDay() -&gt; Employee.getHireDay() raiseSalary(double) -&gt; Employee.raiseSalary(double) &#96;&#96;&#96; &gt; 实际上，上面列出的方法并不完整，稍后会看到**Employee**类有一个超类**Object**，**Employee**类从这个超类中还继承了大量方法，在此，我们略去了**Object**方法。 &gt; **Manager**方法表稍微有些不同。其中有三个方法是继承而来的，一个方法是重新定义的，还有一个方法是新增加的。 &#96;&#96;&#96;C&#x2F;C++ Manager: getName() -&gt; Employee.getName() getSalary() -&gt; Manager.getSalary() getHireDay() -&gt; Employee.getHireDay() raiseSalary(double) -&gt; Employee.raiseSalary(double) setBonus(double) -&gt; Manager.setBonus(double) &#96;&#96;&#96; &gt; 在运行时，调用&#96;e.getSalary()&#96;的解析过程为： 1. 首先，虚拟机获取**e**的实际类型的方法表。这可能是**Employee**、**Manager**的方法表，也可能是**Employee**类的其他子类的方法表。 2. 接下来，虚拟机查找定义了&#96;getSalary()&#96;签名的类。此时，虚拟机已经知道应该调用哪个方法。 3. 最后，虚拟机调用这个方法。 &gt; 动态绑定有一个非常重要的特性：无须对现有的代码进行修改就可以对程序进行扩展。假设增加一个新类**Executive**，并且变量**e**有可能引用这个类的对象，我们不需要对包含调用&#96;e.getSalary()&#96;的代码重新进行编译。如果**e**恰好引用一个**Executive**类的对象，就会自动地调用&#96;Executive.getSalary()&#96;方法。 ### 警告 &gt; 在覆盖一个方法的时候，子类方法**不能低于**超类方法的**可见性**。特别是，如果超类方法是**public**，子类方法必须也要声明为**public**。经常会发生这类错误：即子类方法不小心遗漏了**public**修饰符。此时，编译器就会报错，指出你试图提供更严格的访问权限。 ## 阻止继承：final类和方法 &gt; 有时候，我们可能希望阻止人们利用某个类定义子类。不允许扩展的类被称为**final**类。如果在定义类的时候使用了**final**修饰符就表明这个类是**final**类。例如，假设希望阻止人们派生**Executive**类的子类，就可以在声明这个类的时候使用**final**修饰符。声明格式如下所示： &#96;&#96;&#96;C&#x2F;C++ public final class Executive extends Manager &#123; . . . &#125; 类中的某个特定方法也可以被声明为final。如果这样做，子类就不能覆盖这个方法（final类中的所有方法自动地成为final方法）。例如 public class Employee &#123; . . . public final String getName() &#123; return name; &#125; . . . &#125; 注释 前面曾经说过，字段也可以声明为final。对于final字段来说，构造对象之后就不允许改变它们的值了。不过，如果将一个类声明为final，只有其中的方法自动地成为final，而不包括字段。 将方法或类声明为final的主要原因是：确保它们不会在子类中改变语义。例如，Calendar类中的getTime和setTime方法都声明为final。这表明Calendar类的设计者负责实现Date类与日历状态之间的转换，而不允许子类来添乱。同样地，String类也是final类，这意味着不允许任何人定义String的子类。换言之，如果有一个String引用，它引用的一定是一个String对象，而不可能是其他类的对象。 有些程序员认为：除非有足够的理由使用多态性，否则应该将所有的方法都声明为final。事实上，在C++和C#中，如果没有特别地说明，所有的方法都不使用多态性。这两种做法可能都有些偏激。我们提倡在设计类层次时，要仔细地思考应该将哪些方法和类声明为final。 内联（inlining） 在早期的Java中，有些程序员为了避免动态绑定带来的系统开销而使用final关键字。如果一个方法没有被覆盖并且很短，编译器就能够对它进行优化处理，这个过程称为内联（inlining）。例如，内联调用e.getName()将被替换为访问字段e.name。这是一项很有意义的改进，CPU在处理当前指令时，分支会扰乱预取指令的策略，所以，CPU不喜欢分支。然而，如果getName在另外一个类中被覆盖，那么编译器就无法知道覆盖的代码将会做什么操作，因此也就不能对它进行内联处理了。 幸运的是，虚拟机中的即时编译器比传统编译器的处理能力强得多。这种编译器可以准确地知道类之间的继承关系，并能够检测出是否有类确实覆盖了给定的方法。如果方法很简短、被频繁调用而且确实没有被覆盖，那么即时编译器就会将这个方法进行内联处理。如果虚拟机加载了另外一个子类，而这个子类覆盖了一个内联方法，那么将会发生什么情况呢？优化器将取消对这个方法的内联。这个过程很慢，不过很少会发生这种情况。 强制类型转换 将一个类型强制转换成另外一个类型的过程称为强制类型转换。Java程序设计语言为强制类型转换提供了一种特殊的表示法。例如： double x &#x3D; 3.405; int nx &#x3D; (int) x; 将表达式x的值转换成整数类型，舍弃了小数部分。 程序示例public class HuangzihanTest &#123; public static void main(String[] huangzihan_args) &#123; double huangzihan_x &#x3D; 3.405; int huangzihan_nx &#x3D; (int) huangzihan_x; System.out.println(huangzihan_nx); &#125; &#125; 运行结果3 正像有时候需要将浮点数转换成整数一样，有时候也可能需要将某个类的对象引用转换成另外一个类的对象引用。要完成对象引用的强制类型转换，转换语法与数值表达式的强制类型转换类似，仅需要用一对圆括号将目标类名括起来，并放置在需要转换的对象引用之前就可以了。例如： Manager boss &#x3D; (Manager) staff[0]; 强制类型转换的唯一原因 进行强制类型转换的唯一原因是：要在暂时忽视对象的实际类型之后使用对象的全部功能。例如，在managerTest类中，由于某些元素是普通员工，所以staff数组必须是Employee对象的数组。我们需要将数组中引用经理的元素复原成Manager对象，以便能够访问新增加的所有变量（需要注意，在第一节的示例代码中，为了避免强制类型转换，我们做了一些特别的处理。将boss变量存入数组之前，先将它初始化为一个Manager对象。为了设置经理的奖金，必须使用正确的类型）。 大家知道，在Java中，每个对象变量都有一个类型。类型描述了这个变量所引用的以及能够引用的对象类型。例如，staff[i]引用一个Employee对象（因此它还可以引用Manager对象）。 将一个值存入变量时，编译器将检查你是否承诺过多。如果将一个子类的引用赋给一个超类变量，编译器是允许的。但将一个超类的引用赋给一个子类变量时，就承诺过多了。必须进行强制类型转换，这样才能够通过运行时的检查。 如果试图在继承链上进行向下的强制类型转换，并且“谎报”对象包含的内容，会发生什么情况呢？ Manager boss &#x3D; (Manager) staff[1]; &#x2F;&#x2F; ERROR 运行这个程序时，Java运行时系统将注意到你的承诺不符，并产生一个ClassCastException异常。如果没有捕获这个异常，那么程序就会终止。因此，应该养成这样一个良好的程序设计习惯：在进行强制类型转换之前，先查看是否能够成功地转换。为此只需要使用instanceof操作符就可以实现。例如： if (staff[1] instanceof Manager) &#123; boss &#x3D; (Manager) staff[1]; &#125; 最后，如果这个类型转换不可能成功，编译器就不会让你完成这个转换。例如，下面这个强制类型转换： String c &#x3D; (String) staff[1]; 将会产生编译错误，这是因为String不是Employee的子类。 综上所述： 只能在继承层次内进行强制类型转换。 在将超类强制转换成子类之前，应该使用instanceof进行检查。 注释 如果x为null，进行以下测试 x instanceof C 不会产生异常，只是返回false。之所以这样处理是因为null没有引用任何对象，当然也不会引用C类型的对象。 实际上，通过强制类型转换来转换对象的类型通常并不是一种好的做法。在我们的示例中，大多数情况并不需要将Employee对象强制转换成Manager对象，两个类的对象都能够正确地调用getSalary方法，这是因为实现多态性的动态绑定机制能够自动地找到正确的方法。 只有在使用Manager中特有的方法时才需要进行强制类型转换，例如，setBonus方法。如果岀于某种原因发现需要在Employee对象上调用setBonus方法，那么就应该自问超类的设计是否合理。可能需要重新设计超类，并添加setBonus方法，这才是更合适的选择。请记住，只要没有捕获ClassCastException异常，程序就会终止执行。一般情况下，最好尽量少用强制类型转换和instanceof运算符。 抽象类 如果自下而上在类的继承层次结构中上移，位于上层的类更具有一般性，可能更加抽象。从某种角度看，祖先类更有一般性，人们只将它作为派生其他类的基类，而不是用来构造你想使用的特定的实例。例如，考虑扩展Employee类层次结构。员工是一个人，学生也是一个人。下面扩展我们的类层次结构来加入类Person和类Student。图（Person及其子类的继承图）显示了这三个类之间的继承关系。 Person及其子类的继承图 为什么要那么麻烦提供这样一个高层次的抽象呢？每个人都有一些属性，如姓名。学生与员工都有姓名属性，因此通过引入一个公共的超类，我们就可以把getName方法放在继承层次结构中更高的一层。 现在，再增加一个getDescription方法，它可以返回对一个人的简短描述。例如： an employee with a salary of $50,000.00 a student majoring in computer science abstract关键字 在Employee类和Student类中实现这个方法很容易。但是在Person类中应该提供什么内容呢？除了姓名之外，Person类对这个人一无所知。当然，可以让Person.getDescription()返回一个空字符串。不过还有一个更好的方 法，就是使用abstract关键字，这样就完全不需要实现这个方法了。 public abstract String getDescription(); &#x2F;&#x2F; no implementation required 为了提高程序的清晰度，包含一个或多个抽象方法的类本身必须被声明为抽象的。 public abstract class Person &#123; . . . public abstract String getDescription(); &#125; 除了抽象方法之外，抽象类还可以包含字段和具体方法。例如，Person类还保存着一个人的姓名，另外有一个返回姓名的具体方法。 public abstract class Person &#123; private String name; public Person(String name) &#123; this.name &#x3D; name; &#125; public abstract String getDescription(); public String getName() &#123; return name; &#125; &#125; 提示 有些程序员认为，在抽象类中不能包含具体方法。建议尽量将通用的字段和方 法（不管是否是抽象的）放在超类（不管是否是抽象类）中。 抽象方法充当着占位方法的角色，它们在子类中具体实现。扩展抽象类可以有两种选择。一种是在子类中保留抽象类中的部分或所有抽象方法仍未定义，这样就必须将子类也标记为抽象类；另一种做法是定义全部方法，这样一来，子类就不是抽象的了。 例如，通过扩展抽象Person类，并实现getDescription方法来定义Student类。由于在Student类中不再含有抽象方法，所以不需要将这个类声明为抽象类。 即使不含抽象方法，也可以将类声明为抽象类。 抽象类不能实例化。也就是说，如果将一个类声明为abstract，就不能创建这个类的对象。例如，表达式 new Personf(&quot;Vince Vu&quot;) 是错误的，但可以创建一个具体子类的对象。 需要注意，可以定义一个抽象类的对象变量，但是这样一个变量只能引用非抽象子类的对象。例如， Person p &#x3D; new Student(&quot;Vince Vu&quot;, &quot;Economics&quot;); 这里的p是一个抽象类型Person的变量，它引用了一个非抽象子类Student的实例。 下面定义一个扩展抽象类Person的具体子类Student： public class Student extends Person &#123; private String major; public Student(String name, String major) &#123; super(name); this.major &#x3D; major; &#125; public String getDescription() &#123; return &quot;a student majoring in &quot; + major; &#125; &#125; Student类定义了getDescription方法。因此，在Student类中的全部方法都是具体的，这个类不再是抽象类。 （Huangzihan_abstractClasses/Huangzihan_PersonTest.java）的程序中定义了抽象超类Person（见程序Huangzihan_abstractClasses/Huangzihan_Person.java）和两个具体子类Employee（见程序Huangzihan_abstractClasses/Huangzihan_Employee.java）和Student（见程序Huangzihan_abstractClasses/Huangzihan_Student.java）。下面将员工和学生对象填充到一个Person引用数组。 var people &#x3D; new Person[2]; people[0] &#x3D; new Employee(. . .); people[1] &#x3D; new Student(. . .); 然后，输出这些对象的姓名和信息描述： for (Person p : people) System.out.println(p.getName() + &quot;, &quot; + p.getDescription()); 有些人可能对下面这个调用感到困惑： p.getDescription() 这不是调用了一个没有定义的方法吗？请牢记，由于不能构造抽象类Person的对象，所以变量P永远不会引用Person对象，而是引用诸如Employee或Student这样的具体子类的对象，而这些对象中都定义了getDescription方法。 是否可以干脆省略Person超类中的抽象方法，而仅在Employee和Student子类中定义getDescription方法呢？如果这样做，就不能在变量p上调用getDescription方法了。编译器只允许调用在类中声明的方法。 程序示例Huangzihan_abstractClasses/Huangzihan_Person.javapackage Huangzihan_abstractClasses; public abstract class Huangzihan_Person &#123; public abstract String huangzihan_getDescription(); private String huangzihan_name; public Huangzihan_Person(String huangzihan_name) &#123; this.huangzihan_name &#x3D; huangzihan_name; &#125; public String huangzihan_getName() &#123; return huangzihan_name; &#125; &#125; Huangzihan_abstractClasses/Huangzihan_Employee.javapackage Huangzihan_abstractClasses; import java.time.LocalDate; public class Huangzihan_Employee extends Huangzihan_Person &#123; private double huangzihan_salary; private LocalDate huangzihan_hireDay; public Huangzihan_Employee(String huangzihan_name, double huangzihan_salary, int huangzihan_year, int huangzihan_month, int huangzihan_day) &#123; super(huangzihan_name); this.huangzihan_salary &#x3D; huangzihan_salary; huangzihan_hireDay &#x3D; LocalDate.of(huangzihan_year, huangzihan_month, huangzihan_day); &#125; public double huangzihan_getSalary() &#123; return huangzihan_salary; &#125; public LocalDate huangzihan_getHireDay() &#123; return huangzihan_hireDay; &#125; public String huangzihan_getDescription() &#123; return String.format(&quot;员工的工资为$%.2f&quot;, huangzihan_salary); &#125; public void huangzihan_raiseSalary(double huangzihan_byPercent) &#123; double huangzihan_raise &#x3D; huangzihan_salary * huangzihan_byPercent &#x2F; 100; huangzihan_salary +&#x3D; huangzihan_raise; &#125; &#125; Huangzihan_abstractClasses/Huangzihan_Student.javapackage Huangzihan_abstractClasses; public class Huangzihan_Student extends Huangzihan_Person &#123; private String huangzihan_major; &#x2F;* * @param huangzihan_name 学生的名字 * @param huangzihan_major 学生的专业 * *&#x2F; public Huangzihan_Student(String huangzihan_name, String huangzihan_major) &#123; &#x2F;&#x2F; 将名称传递给超类构造函数 super(huangzihan_name); this.huangzihan_major &#x3D; huangzihan_major; &#125; public String huangzihan_getDescription() &#123; return &quot;学生正在主修&quot; + huangzihan_major + &quot;专业&quot;; &#125; &#125; Huangzihan_abstractClasses/Huangzihan_PersonTest.javapackage Huangzihan_abstractClasses; &#x2F;* * @功能：该程序演示了抽象类。 * @版本：1.01 * @时间：2021-07-21 * @作者：黄子涵 * *&#x2F; public class Huangzihan_PersonTest &#123; public static void main(String[] huangzihan_args) &#123; var huangzihan_people &#x3D; new Huangzihan_Person[2]; &#x2F;&#x2F; 用Huangzihan_Student和Huangzihan_Employee对象填充people数组 huangzihan_people[0] &#x3D; new Huangzihan_Employee(&quot;huangzihan&quot;, 50000, 1989, 10, 1); huangzihan_people[1] &#x3D; new Huangzihan_Student(&quot;黄子涵&quot;, &quot;电子信息工程专业&quot;); &#x2F;&#x2F; 打印出所有Huangzihan_Person对象的名称和描述 for(Huangzihan_Person huangzihan_p: huangzihan_people) &#123; System.out.println(huangzihan_p.huangzihan_getName() + &quot;,&quot; + huangzihan_p.huangzihan_getDescription()); &#125; &#125; &#125; 运行结果huangzihan,员工的工资为$50000.00 黄子涵,学生正在主修电子信息工程专业专业 受保护访问 大家都知道，最好将类中的字段标记为private，而方法标记为public。任何声明为private的内容对其他类都是不可见的。前面已经看到，这对于子类来说也完全适用，即子类也不能访问超类的私有字段。 不过，在有些时候，你可能希望限制超类中的某个方法只允许子类访问，或者更少见地，可能希望允许子类的方法访问超类的某个字段。为此，需要将这些类方法或字段声明为受保护（protected）。例如，如果将超类Employee中的hireDay字段声明为proteced，而不是private，Manager方法就可以直接访问这个字段。 在Java中，保护字段只能由同一个包中的类访问。现在考虑一个Administrator子类，这个子类在另一个不同的包中。Administrator类中的方法只能查看Administrator对象自己的hireDay字段，而不能查看其他Employee对象的这个字段。有了这个限制，就能避免滥用保护机制，不能通过派生子类来访问受保护的字段。 在实际应用中，要谨慎使用受保护字段。假设你的类要提供给其他程序员使用，而你在设计这个类时设置了一些受保护字段。你不知道的是，其他程序员可能会由这个类再派生出新类，并开始访问你的受保护字段。在这种情况下，如果你想修改你的类的实现，就势必会影响那些程序员。这违背了OOP提倡数据封装的精神。 受保护的方法更具有实际意义。如果需要限制某个方法的使用，就可以将它声明为protected。这表明子类（可能很熟悉祖先类）得到了信任，可以正确地使用这个方法，而其他类则不行。 这种方法的一个很好的示例就是Object类中的clone方法。 Java中的4个访问控制修饰符 下面对Java中的4个访问控制修饰符做个小结： 仅对本类可见————private。 对外部完全可见————public。 对本包和所有子类可见————protected。 对本包可见——默认（很遗憾），不需要修饰符。","path":"2021/07/22/类、超类和子类/","date":"07-22","excerpt":"类、超类和子类 假设你在某个公司工作，这个公司里经理的待遇与普通员工的待遇存在着一些差异。不过，他们之间也存在着很多相同的地方，例如，他们都领取薪水。只是普通员工在完成本职任务之后仅领取薪水，而经理在完成了预期的业绩之后还能得到奖金。这种情形就需要使用继承。为什么呢？因为需要为经理定义一个新类Manager，并增加一些新功能。但可以重用Employee类中已经编写的部分代码，并保留原来Employee类中的所有字段。从理论上讲，在Manager与Employee之间存在着明显的“is-a”（是）关系，每个经理都是一个员工：“is-a”关系是继承的一个明显特征。 注释 这一章中，我们使用了员工和经理的经典示例，不过必须提醒你的是对这个例子要有所保留。在真实世界里，员工也可能会成为经理，所以你建模时可能希望经理 也是员工，而不是员工的一个子类。不过，在我们的例子中，假设公司里只有两类人：一些人永远是员工，另一些人一直是经理。 定义子类 可以如下继承Employee类来定义Manager类，这里使用关键字extends表示继承。 public class Manager extends Employee &#123; added methods and fields &#125; 关键字extends 关键字extends表明正在构造的新类派生于一个已存在的类。这个已存在的类称为超类（superclass）、基类（base class）或父类（parent class）；新类称为子类（subclass）、派生类（derived class） 或孩子类（child class）。超类和子类是Java程序员最常用的两个术语，而了解 其他语言的程序员可能更加偏爱使用父类和孩子类，这也能很贴切地体现“继承”。 尽管Employee类是一个超类，但并不是因为它优于子类或者拥有比子类更多的功能。实际上恰恰相反，子类比超类拥有的功能更多。例如，看过Manager类的源代码之后就会发现，Manager类比超类Employee封装了更多的数据，拥有更多的功能。","tags":[{"name":"类","slug":"类","permalink":"http://www.huangzihan.top/tags/%E7%B1%BB/"},{"name":"超类","slug":"超类","permalink":"http://www.huangzihan.top/tags/%E8%B6%85%E7%B1%BB/"},{"name":"子类","slug":"子类","permalink":"http://www.huangzihan.top/tags/%E5%AD%90%E7%B1%BB/"},{"name":"super","slug":"super","permalink":"http://www.huangzihan.top/tags/super/"},{"name":"extends","slug":"extends","permalink":"http://www.huangzihan.top/tags/extends/"},{"name":"this","slug":"this","permalink":"http://www.huangzihan.top/tags/this/"},{"name":"多态","slug":"多态","permalink":"http://www.huangzihan.top/tags/%E5%A4%9A%E6%80%81/"},{"name":"动态绑定","slug":"动态绑定","permalink":"http://www.huangzihan.top/tags/%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/"},{"name":"继承链","slug":"继承链","permalink":"http://www.huangzihan.top/tags/%E7%BB%A7%E6%89%BF%E9%93%BE/"},{"name":"替换原则","slug":"替换原则","permalink":"http://www.huangzihan.top/tags/%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/"},{"name":"重载解析","slug":"重载解析","permalink":"http://www.huangzihan.top/tags/%E9%87%8D%E8%BD%BD%E8%A7%A3%E6%9E%90/"},{"name":"方法表","slug":"方法表","permalink":"http://www.huangzihan.top/tags/%E6%96%B9%E6%B3%95%E8%A1%A8/"},{"name":"final","slug":"final","permalink":"http://www.huangzihan.top/tags/final/"},{"name":"访问控制修饰符","slug":"访问控制修饰符","permalink":"http://www.huangzihan.top/tags/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6/"},{"name":"abstract","slug":"abstract","permalink":"http://www.huangzihan.top/tags/abstract/"},{"name":"抽象类","slug":"抽象类","permalink":"http://www.huangzihan.top/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/"},{"name":"内联","slug":"内联","permalink":"http://www.huangzihan.top/tags/%E5%86%85%E8%81%94/"}]},{"title":"类设计技巧","text":"类设计技巧 我们不会面面俱到，也不希望过于沉闷，简单地介绍几点技巧。应用这些技巧可以使你设计的类更能得到专业OOP圈子的认可。 一定要保证数据私有。 这是最重要的；绝对不要破坏封装性。有时候，可能需要编写一个访问器方法或更改器方法，但是最好还是保持实例字段的私有性。很多惨痛的教训告诉我们，数据的表示形式很可能会改变，但它们的使用方式却不会经变化。当数据保持私有时，表示形式的变化不会对类的使用者产生影响，而且也更容易检测bug。 一定要对数据进行初始化。 Java不会为你初始化局部变量，但是会对对象的实例字段进行初始化。最好不要依赖于系统的默认值，而是应该显式地初始化所有的数据，可以提供默认值，也可以在所有构造器中设置默认值。 不要在类中使用过多的基本类型。 这个想法是要用其他的类替换使用多个相关的基本类型。这样会使类更易于理解，也更易于修改。例如，用一个名为Address的新类替换一个Customer类中以下的实例字段： private String street; private String city; private String state; private int zip; 这样一来，可以很容易地处理地址的变化，例如，可能需要处理国际地址。 不是所有的字段都需要单独的字段访问器和字段更改器。 你可能需要获得或设置员工的工资。而一旦构造了员工对象，肯定不需要更改雇用日期。另外，在对象中，常常包含一些不希望别人获得或设置的实例字段，例如，Address类中的州缩写数组。 分解有过多职责的类。 这样说似乎有点含糊，究竟多少算是“过多”？每个人的看法都不同。但是，如果明显地可以将一个复杂的类分解成两个更为简单的类，就应该将其分解（但另一方面，也不要走极端。如果设计10个类，每个类只有一个方法，显然就有些矫枉过正了）。 下面是一个反面的设计示例。 public class CardDeck &#x2F;&#x2F; bad design &#123; private int[] value; private int[] suit; public CardDeck() &#123; . . . &#125; public void shuffle() &#123; . . . &#125; public int getTopValue() &#123; . . . &#125; public int getTopSuit() &#123; . . . &#125; public void draw() &#123; . . . &#125; &#125; 实际上，这个类实现了两个独立的概念：一副牌（包含shuffle方法和draw方法）和一张牌（包含查看面值和花色的方法）。最好引入一个表示一张牌的Card类。现在有两个类，每个类完成自己的职责： public class CardDeck &#123; private Card[] cards; public CardDeck() &#123; . . . &#125; public void shuffle() &#123; . . . &#125; public Card getTop() &#123; . . . &#125; public void draw() &#123; . . . &#125; &#125; public class Card &#123; private int value; private int suit； public Card(int aValue, int aSuit) &#123; . . . &#125; public int getValue() &#123; . . . &#125; public int getSuit() &#123; . . . &#125; &#125; 类名和方法名要能够体现它们的职责。 与变量应该有一个能够反映其含义的名字一样，类也应该如此（在标准类库中，也存在着一些含义不明确的例子，如Date类实际上是一个用于描述时间的类）。 类名命名的惯例 对此有一个很好的惯例：类名应当是一个名词（Order），或者是前面有形容词修饰的名词 （RushOrder），或者是有动名词（有“-ing”后缀）修饰的名词（例如，BillingAddress）。 方法命名的惯例 对于方法来说，要遵循标准惯例：访问器方法用小写get开头（getSalary），更改器方法用小写的set开头（setSalary）。 优先使用不可变的类。 LocalDate类以及java.time包中的其他类是不可变的————没有方法能修改对象的状态。类似plusDays的方法并不是更改对象，而是返回状态已修改的新对象。 更改对象的问题在于，如果多个线程试图同时更新一个对象，就会发生并发更改。其结果是不可预料的。如果类是不可变的，就可以安全地在多个线程间共享其对象。 因此，要尽可能让类是不可变的，这是一个很好的想法。对于表示值的类，如一个字符串或一个时间点，这尤其容易。计算会生成新值，而不是更新原来的值。 当然，并不是所有类都应当是不可变的。如果员工加薪时让raiseSalary方法返回一个新的Employee对象，这会很奇怪。","path":"2021/07/20/类设计技巧/","date":"07-20","excerpt":"类设计技巧 我们不会面面俱到，也不希望过于沉闷，简单地介绍几点技巧。应用这些技巧可以使你设计的类更能得到专业OOP圈子的认可。 一定要保证数据私有。 这是最重要的；绝对不要破坏封装性。有时候，可能需要编写一个访问器方法或更改器方法，但是最好还是保持实例字段的私有性。很多惨痛的教训告诉我们，数据的表示形式很可能会改变，但它们的使用方式却不会经变化。当数据保持私有时，表示形式的变化不会对类的使用者产生影响，而且也更容易检测bug。 一定要对数据进行初始化。 Java不会为你初始化局部变量，但是会对对象的实例字段进行初始化。最好不要依赖于系统的默认值，而是应该显式地初始化所有的数据，可以提供默认值，也可以在所有构造器中设置默认值。 不要在类中使用过多的基本类型。 这个想法是要用其他的类替换使用多个相关的基本类型。这样会使类更易于理解，也更易于修改。例如，用一个名为Address的新类替换一个Customer类中以下的实例字段： private String street; private String city; private String state; private int zip; 这样一来，可以很容易地处理地址的变化，例如，可能需要处理国际地址。","tags":[]},{"title":"文档注释","text":"文档注释 JDK包含一个很有用的工具，叫做javadoc，它可以由源文件生成一个HTML文档。事实上，联机API文档就是通过对标准Java类库的源代码运行javadoc生成的。 如果在源代码中添加以特殊定界符/**开始的注释，你也可以很容易地生成一个看上去具有专业水准的文档。这是一种很好的方法，因为这样可以将代码与注释放在一个地方。如果将文档存放在一个独立的文件中，就有可能会随着时间的推移出现代码和注释不一致的问题。然而，由于文档注释与源代码在同一个文件中，在修改源代码的同时，重新运行javadoc就可以轻而易举地保持两者的一致性。 注释的插入javadoc实用工具javadoc实用工具从下面几项中抽取信息： 模块； 包； 公共类与接口； 公共的和受保护的字段； 公共的和受保护的构造器及方法。 可以（而且应该）为以上各个特性编写注释。注释放置在所描述特性的前面。注释以/*开始，并以/结束。 每个/** . . . */文档注释包含标记以及之后紧跟着的自由格式文本（free-form text）。标记以@开始，如@since或@param。 自由格式文本的第一句应该是一个概要性的句子。javadoc工具自动地将这些句子抽取出来生成概要页。 在自由格式文本中，可以使用HTML修饰符，例如，用于强调的&lt;em&gt;...&lt;/em&gt;、用于着重强调的&lt;stron&gt;...&lt;/strong&gt;、用于项目符号列表的&lt;ul&gt;/&lt;li&gt;以及用于包含图像的&lt;img ...&gt;等。要键入等宽代码，需要使用&#123;@code ...&#125;而不是&lt;code&gt;...&lt;/code&gt;——这样一来，就不用操心对代码中的&lt;字符转义了。 注释 如果文档中有到其他文件的链接，如图像文件（例如，图表或用户界面组件的 图像），就应该将这些文件放到包含源文件的目录下的一个子目录doc-files中。javadoc工具将从源目录将doc-files目录及其内容拷贝到文档目录中。在链接中需要使用doc-files目录，例如：&lt;img src=&quot;doc-files/uml.png&quot; alt=&quot;UML diagram&quot;/&gt;。 类注释 类注释必须放在import语句之后，类定义之前。 下面是一个类注释的例子： &#x2F;** * A &#123;@code Card&#125; object represents a playing card, such * as &quot;Queen of Hearts&quot;. A card has a suit (Diamond, Heart, * Spade or Club) and a value (1 &#x3D; Ace, 2 . . . 10, 11 &#x3D; Jack, * 12 &#x3D; Queen, 13 &#x3D; King) *&#x2F; public class Card &#123; . . . &#125; 注释 没有必要在每一行的开始都添加星号*，例如，以下注释同样是合法的： &#x2F;** A &lt;code&gt;Card&lt;&#x2F;code&gt; object represents a playing card, such as &quot;Queen of Hearts&quot;. A card has a suit (Diamond, Heart, Spade or Club) and a value (1 &#x3D; Ace, 2 . . . 10, 11 &#x3D; Jack, 12 &#x3D; Queen, 13 &#x3D; King). *&#x2F; 不过，大部分IDE会自动提供星号*，而且换行改变时，还会重新放置星号。 方法注释 每一个方法注释必须放在所描述的方法之前。除了通用标记之外，还可以使用下面的标记： @param variable description 这个标记将给当前方法的“parameters”（参数）部分添加一个条目。这个描述可以占据多行，并且可以使用HTML标记。一个方法的所有@param标记必须放在一起。 @return description 这个标记将给当前方法添加“returns”（返回）部分。这个描述可以跨多行，并且可以使用HTML标记。 @throws class description 这个标记将添加一个注释，表示这个方法有可能抛出异常。 下面是一个方法注释的示例： &#x2F;** * Raises the salary of an employee. * @param byPercent the percentage by which to raise the salary (e.g., 10 means 10%) * @return the amount of the raise *&#x2F; public double raiseSalary(double byPercent) &#123; double raise &#x3D; salary * byPercent &#x2F; 100; salary +&#x3D; raise; return raise; &#125; 字段注释 只需要对公共字段（通常指的是静态常量）建立文档。例如， &#x2F;** * The &quot;Hearts&quot; card suit *&#x2F; public static final int HEARTS &#x3D; 1; 通用注释 标记@since text会建立一个“since”（始于）条目。text（文本）可以是引入这个特性的版 本的任何描述。例如，@sincel.7.1。下面的标记可以用在类文档注释中。 @author name 这个标记将产生一个“author”（作者）条目。可以使用多个@author标记，每个@author 标记对应一个作者。并不是非得使用这个标记，你的版本控制系统能够更好地跟踪作者。 ©version text 这个标记将产生一个“version”（版本）条目。这里的文本可以是对当前版本的任何描述。 通过@see和@link标记，可以使用超链接，链接到javadoc文档的相关部分或外部文档。 标记@see reference将在“see also”（参见）部分增加一个超链接。它可以用于类中，也可以用于方法中。这里的reference（引用）可以有以下选择： package.class#feature label &lt;a href&#x3D;&quot;. . .&quot;&gt;label&lt;&#x2F;a&gt; &quot;text&quot; 第一种情况是最有用的。只要提供类、方法或变量的名字，javadoc就在文档中插入一个超链接。例如， @see com.horstmann.corejava.Employee#raiseSalary(double) 这会建立一个链接到com.horstmann.corejava.Employee类的raiseSalary(double)方法的超链接。可以省略包名，甚至把包名和类名都省去，这样一来，这会位于当前包或当前类中。 需要注意，一定要使用井号（#），而不要使用句号（.）分隔类名与方法名，或类名与变量名。Java编译器自身可以熟练地确定句点在分隔包、子包、类、内部类与方法和变量时的不同含义。但是javadoc工具就没有这么聪明了，因此必须对它提供帮助。 如果@see标记后面有一个&lt;字符，就需要指定一个超链接。可以超链接到任何URL。 例如： @see &lt;a href&#x3D;&quot;www.horstmann.com&#x2F;corejava.html&quot;&gt;The Core Java home page&lt;&#x2F;a&gt; 在上述各种情况下，都可以指定一个可选的标签（label）作为链接锚（link anchor）。如果省略了标签，用户看到的锚就是目标代码名或URL。 如果@see标记后面有一个双引号(“)字符，文本就会显示在“see also”部分。例如， @see &quot;Core Java 2 volume 2&quot; 可以为一个特性添加多个@see标记，但必须将它们放在一起。 如果愿意，还可以在文档注释中的任何位置放置指向其他类或方法的超链接。可以在注释中的任何位置插入一个形式如下的特殊标记： &#123;@link package.class#feature label&#125; 这里的特性描述规则与@see标记的规则相同。 最后，在Java 9中，还可以使用{@index entry}标记为搜索框增加一个条目。 包注释 可以直接将类、方法和变量的注释放置在Java源文件中，只要用/** . . . */文档注释界定就可以了。但是，要想产生包注释，就需要在每一个包目录中添加一个单独的文件。可以有如下两个选择： 提供一个名为package-info.java的Java文件。这个文件必须包含一个初始的以/**和*/界定的Javadoc注释，后面是一个package语句。它不能包含更多的代码或注释。 提供一个名为package.html的HTML文件。会抽取标记&lt;body&gt;...&lt;/body&gt;之间的所有文本。 注释抽取 在这里，假设你希望HTML文件将放在名为docDirectory的目录下。执行以下步骤： 切换到包含想要生成文档的源文件的目录。如果有嵌套的包要生成文档，例如com.horstmann.corejava，就必须切换到包含子目录com的目录（如果提供了overview.html文件的话, 这就是这个文件所在的目录)。 如果是一个包，应该运行命令： javadoc -d docDirectory nameOfPackage 或者，如果要为多个包生成文档，运行： javadoc -d docDirectory nameOfPackage1 nameOfPackage2. . . 如果文件在无名的包中，就应该运行： javadoc -d docDirectory *.java 如果省略了-d docDirectory选项，那HTML文件就会被提取到当前目录下。这样有可能会带来混乱，因此不提倡这种做法。 可以使用很多命令行选项对javadoc程序进行优化。例如，可以使用-author和-version选项在文档中包含@author和@version标记（默认情况下，这些标记会被省略）。另一个很有用的选项是-link，用来为标准类添加超链接。例如，如果使用命令 javadoc -link http:&#x2F;&#x2F;docs.oracle.eom&#x2F;javase&#x2F;9&#x2F;docs&#x2F;api *.java 那么，所有的标准类库类都会自动地链接到Oracle网站的文档。 如果使用-linksource选项，每个源文件将会转换为HTML（不对代码着色，但包含行号），并且每个类和方法名将变为指向源代码的超链接。 还可以为所有的源文件提供一个概要注释。把它放在一个类似overview.html的文件中，运行javadoc工具，并提供命令行选项-overview filename。将抽取标记&lt;body&gt;...&lt;/body&gt;之间的所有文本。当用户从导航栏中选择“Overview”时，就会显示出这些内容。 有关其他的选项，请查阅javadoc工具的联机文档**https://docs.oracle.com/javase/9/javadoc/javadoc.htm。","path":"2021/07/19/文档注释/","date":"07-19","excerpt":"文档注释 JDK包含一个很有用的工具，叫做javadoc，它可以由源文件生成一个HTML文档。事实上，联机API文档就是通过对标准Java类库的源代码运行javadoc生成的。 如果在源代码中添加以特殊定界符/**开始的注释，你也可以很容易地生成一个看上去具有专业水准的文档。这是一种很好的方法，因为这样可以将代码与注释放在一个地方。如果将文档存放在一个独立的文件中，就有可能会随着时间的推移出现代码和注释不一致的问题。然而，由于文档注释与源代码在同一个文件中，在修改源代码的同时，重新运行javadoc就可以轻而易举地保持两者的一致性。 注释的插入javadoc实用工具javadoc实用工具从下面几项中抽取信息： 模块； 包； 公共类与接口； 公共的和受保护的字段； 公共的和受保护的构造器及方法。 可以（而且应该）为以上各个特性编写注释。注释放置在所描述特性的前面。注释以/*开始，并以/结束。 每个/** . . . */文档注释包含标记以及之后紧跟着的自由格式文本（free-form text）。标记以@开始，如@since或@param。 自由格式文本的第一句应该是一个概要性的句子。javadoc工具自动地将这些句子抽取出来生成概要页。 在自由格式文本中，可以使用HTML修饰符，例如，用于强调的&lt;em&gt;...&lt;/em&gt;、用于着重强调的&lt;stron&gt;...&lt;/strong&gt;、用于项目符号列表的&lt;ul&gt;/&lt;li&gt;以及用于包含图像的&lt;img ...&gt;等。要键入等宽代码，需要使用&#123;@code ...&#125;而不是&lt;code&gt;...&lt;/code&gt;——这样一来，就不用操心对代码中的&lt;字符转义了。","tags":[]},{"title":"JAR文件","text":"JAR文件 在将应用程序打包时，你一定希望只向用户提供一个单独的文件，而不是一个包含大量类文件的目录结构，Java归档（JAR）文件就是为此目的而设计的。一个JAR文件既可以包含类文件，也可以包含诸如图像和声音等其他类型的文件。此外，JAR文件是压缩的，它使用了我们熟悉的ZIP压缩格式。 创建JAR文件 可以使用jar工具制作JAR文件（在默认的JDK安装中，这个工具位于jdk/bin目录下）。创建一个新JAR文件最常用的命令使用以下语法： jar cvf jarFileName file1 file2 . . . 例如： jar cvf Calculatorclasses.jar *.class icon.gif 通常，jar命令的格式如下： jar options file1 file2 . . . jar程序选项 表（jar程序选项）列出了jar程序的所有选项。它们类似于UNIX tar命令的选项。 可以将应用程序和代码库打包在JAR文件中。例如，如果想在一个Java程序中发送邮件，就可以使用打包在文件javax.mail.jar中的一个库。 选项 说明 c 创建一个新的或者空的存档文件并加入文件。如果指定的文件名是目录，jar程序将会对它们进行递归处理 C 临时改变目录，例如：jar cvf jarFileName.jar -C classes *.class切换到classes子目录以便增加类文件 e 在清单文件中创建一个入口点 f 指定JAR文件名作为第二个命令行参数。如果没有这个参数，jar命令会将结果写至标准输出（在创建JAR文件时）或者从标准输入读取（在解压或者列出JAR文件内容时） i 建立索引文件（用于加快大型归档中的查找） m 将一个清单文件添加到JAR文件中。清单是对归档内容和来源的一个说明。每个归档有一个默认的清单文件。但是，如果想验证归档文件的内容，可以提供自己的清单文件 M 不为条目创建清单文件 t 显示内容表 u 更新一个已有的JAR文件 V 生成详细的输出结果 X 解压文件。如果提供一个或多个文件名，只解压这些文件；否则，解压所有文件 0 存储，但不进行ZIP压缩 清单文件 除了类文件、图像和其他资源外，每个JAR文件还包含一个清单文件（manifest），用于描述归档文件的特殊特性。 清单文件被命名为MANIFEST.MF，它位于JAR文件的一个特殊的META-INF子目录中。符合 标准的最小清单文件极其简单： Manifest-Version: 1.0 复杂的清单文件可能包含更多条目。这些清单条目被分成多个节。第一节被称为主节（main section）。它作用于整个JAR文件。随后的条目用来指定命名实体的属性，如单个文件、包或者URL。它们都必须以一个Name条目开始。节与节之间用空行分开。例如： Manifest-Version: 1.0 lines describing this archive Name: Woozle.class lines describing this file Name: com&#x2F;mycompany&#x2F;mypkg&#x2F; lines describing this package 要想编辑清单文件，需要将希望添加到清单文件中的行放到文本文件中，然后运行： jar cfm jarFileName manifestFileName . . . 例如，要创建一个包含清单文件的JAR文件，应该运行： jar cfm MyArchive.jar manifest.mf com&#x2F;mycompany&#x2F;mypkg&#x2F;*.class 要想更新一个已有的JAR文件的清单，则需要将增加的部分放置到一个文本文件中，然后执行以下命令： jar ufm MyArchive.jar manifest-additions.mf 注释 请参看https://docs.oracle.com/javase/10/docs/specs/jar/jar.html获得有关JAR文件和清单文件格式的更多信息。 可执行JAR文件 可以使用jar命令中的e选项指定程序的入口点，即通常需要在调用java程序启动器时指定的类： jar cvfe MyProgram.jar com.mycompany.mypkg.MainAppClass files to add 或者，可以在清单文件中指定程序的主类，包括以下形式的语句： Main-Class: com.mycompany.mypkg.MainAppClass 不要为主类名增加扩展名.class。 警告 清单文件的最后一行必须以换行符结束。否则，清单文件将无法被正确地读取。 常见的一个错误是创建了一个只包含Main-Class行而没有行结束符的文本文件。 不论使用哪一种方法，用户可以简单地通过下面的命令来启动程序： java -jar MyProgram.jar 取决于操作系统的配置，用户甚至可以通过双击JAR文件图标来启动应用程序。下面是各种操作系统的操作方式： 在Windows平台中，Java运行时安装程序将为”.jar”扩展名创建一个文件关联，会用javaw -jar命令启动文件（与java命令不同，javaw命令不打开shell窗口）。 在Mac OS X平台中，操作系统能够识别”.jar”扩展名文件。双击JAR文件时就会执 行Java程序。 不过，人们对JAR文件中的Java程序与原生应用还是感觉不同。在Windows平台 中，可以使用第三方的包装器工具将JAR文件转换成Windows可执行文件。包装器是一个Windows程序，有大家熟悉的扩展.exe，它可以查找和加载Java虚拟机（JVM），或者在没有找到JVM时会告诉用户应该做些什么。有许多商业的和开源的产品，例如，Launch4J （http://launch4j.soureforge.net）和 IzPack（http://izpack.org）。 多版本JAR文件 随着模块和包强封装的引入，之前可以访问的一些内部API不再可用。例如，JavaFX 8有一个内部类com.sun.javafx.css.CssParser。如果用它解析一个样式表，你会发现你的程序不再能正常编译了。补救很简单，只需要改用Java 9提供的javafx.css.CssParser。不过这样会有一个问题。你需要向Java 8和Java 9用户发布不同的应用程序，或者需要利用类加载和反射等一些技巧。 为了解决类似这样的问题，Java 9引入了多版本JAR（multi-release JAR），其中可以包含面向不同Java版本的类文件。 为了保证向后兼容，额外的类文件放在META-INF/versions目录中： Application.class BuildingBlocks.class Util.class META-INF |__ MANIFEST.MF (with line Multi-Release: true) |__ versions |__ 9 | |__ Application.class | |__ BuildingBlocks.class |__ 10 |__ BuildingBlocks.class 假设Application类使用了CssParser类。那么遗留版本的Application.class文件可以使用com.sun.javafx.css.CssParser，而Java 9版本可以使用javafx.css.CssParser。 Java 8完全不知道META-INF/versions目录，它只会加载遗留的类。Java 9读取这个JAR文件时，则会使用新版本。 要增加不同版本的类文件，可以使用--release标志： jar uf MyProgram.jar --release 9 Application.class 要从头构建一个多版本JAR文件，可以使用-C选项，对应每个版本要切换到一个不同的类文件目录： jar cf MyProgram.jar -C bin&#x2F;8 . --release 9 -C bin&#x2F;9 Application.class 面向不同版本编译时，要使用--release标志和-d标志来指定输出目录： javac -d bin&#x2F;8 --release 8 . . . 在Java 9中，-d选项会创建这个目录（如果原先该目录不存在）。 --release标志也是Java 9新增的。在较早的版本中，需要使用-source、 -target和-boot-classpath标志。JDK现在为之前的两个API版本提供了符号文件。在Java 9中，编译时可以将--release设置为9、8或7。 多版本JAR并不适用于不同版本的程序或库。对于不同的版本，所有类的公共API都应当是一样的。多版本JAR的唯一目的是支持你的某个特定版本的程序或库能够在多个不同的JDK版本上运行。如果你增加了功能或者改变了一个API，那就应当提供一个新版本的JAR。 注释 javap之类的工具并没有改造为可以处理多版本JAR文件。如果调用： javap -classpath MyProgram.jar Application.class 你会得到类的基本版本（毕竟，它与更新的版本应该有相同的公共API）。如果必须查看更新的版本，可以调用： javap -classpath MyProgram.jar\\!&#x2F;META-INF&#x2F;versions&#x2F;9&#x2F;Application.class 关于命令行选项的说明 Java开发包（JDK）的命令行选项一直以来都使用单个短横线加多字母选项名的形式，如： java -jar . . . javac -Xlint:unchecked -classpath . . . 但jar命令是个例外，这个命令遵循经典的tar命令选项格式，而没有短横线： jar cvf . . . 从Java 9开始，Java工具开始转向一种更常用的选项格式，多字母选项名前面加两个短横线，另外对于常用的选项可以使用单字母快捷方式。例如，调用Linux Is命令时可以提供 一个 “ human-readable ” 选项：ls命令时可以提供一个“human-readable”选项： ls --human-readable 或者 ls -h 在Java 9中，可以使用--version而不是-version，另外可以使用--class-path而不是-classpath。 详细内容可以参见JEP 293增强请求（http://openjdk.java.net/jeps/293)。在所有清理工作中，作者还提出要标准化选项参数。带—和多字母的选项的参数用空格或者一个等号（=）分隔： javac --class-path &#x2F;home&#x2F;user&#x2F;classdir . . . 或 javac --class-path&#x3D;&#x2F;home&#x2F;user&#x2F;classdir . . . 单字母选项的参数可以用空格分隔，或者直接跟在选项后面： javac -p moduledir . . . 或 javac -pmoduledir . . . 警告 后一种方式现在不能使用，而且一般来讲这也不是一个好主意。如果模块目录 恰好是arameters或rocessor，这就很容易与遗留的选项发生冲突，这又何必呢？ 无参数的单字母选项可以组合在一起： jar -cvf MyProgram.jar -e mypackage.MyProgram *&#x2F;*.class 警告 目前不能使用这种方式。这肯定会带来混淆。假设javac有一个-c选项。那么javac -cp是指javac -c-p还是-cp？ 这就会带来一些混乱，希望过段时间能够解决这个问题。尽管我们想要远离这些古老的jar选项，但最好还是等到尘埃落定为妙。不过，如果你想做到最现代化，那么可以安全地使用jar命令的长选项： jar --create --verbose --file jarFileName file1 file2 . . . 对于单字母选项，如果不组合，也是可以使用的： jar -c -v -f jarFileName file1 file2 . . .","path":"2021/07/19/JAR文件/","date":"07-19","excerpt":"JAR文件 在将应用程序打包时，你一定希望只向用户提供一个单独的文件，而不是一个包含大量类文件的目录结构，Java归档（JAR）文件就是为此目的而设计的。一个JAR文件既可以包含类文件，也可以包含诸如图像和声音等其他类型的文件。此外，JAR文件是压缩的，它使用了我们熟悉的ZIP压缩格式。 创建JAR文件 可以使用jar工具制作JAR文件（在默认的JDK安装中，这个工具位于jdk/bin目录下）。创建一个新JAR文件最常用的命令使用以下语法： jar cvf jarFileName file1 file2 . . . 例如： jar cvf Calculatorclasses.jar *.class icon.gif 通常，jar命令的格式如下： jar options file1 file2 . . .","tags":[]},{"title":"包","text":"包 Java允许使用包（package）将类组织在一个集合中。借助包可以方便地组织自己的代码，并将自己的代码与别人提供的代码库分开管理。下面我们将介绍如何使用和创建包。 包名 使用包的主要原因是确保类名的唯一性。假如两个程序员不约而同地建立了Employee类。只要将这些类放置在不同的包中，就不会产生冲突。事实上，为了保证包名的绝对唯一性，要用一个因特网域名（这显然是唯一的）以逆序的形式作为包名，然后对于不同的工程使用不同的子包。例如，考虑域名horstmann.com。如果逆序来写，就得到了包名com.horstmann。然后可以追加一个工程名，如com.horstmann.corejava。如果再把Employee类放在这个包里，那么这个类的“完全限定”名就是com.horstmann.corejava.Employee。 包名 注释 从编译器的角度来看，嵌套的包之间没有任何关系。例如，java.util包与java.util.jar包毫无关系。每一个包都是独立的类集合。 注释 类的导入 一个类可以使用所属包中的所有类，以及其他包中的公共类（public class）。 我们可以采用两种方式访问另一个包中的公共类。第一种方式就是使用完全限定名（fully qualified name）；就是包名后面跟着类名。例如： java.time.LocalDate today &#x3D; java.time.LocalDate.now(); 程序示例public class HuangZiHanTest &#123; public static void main(String[] huangzihan_args) &#123; java.time.LocalDate huangzihan_today &#x3D; java.time.LocalDate.now(); System.out.println(huangzihan_today); &#125; &#125; 运行结果2021-07-19 import语句 这显然很烦琐。更简单且更常用的方式是使用import语句。import语句是一种引用包中各个类的简捷方式。一旦使用了import语句，在使用类时，就不必写出类的全名了。 可以使用import语句导入一个特定的类或者整个包。import语句应该位于源文件的顶部（但位于package语句的后面）。例如，可以使用下面这条语句导入java.util包中的所有类。 import java.time.*; 然后，就可以使用 LocalDate today &#x3D; LocalDate.now(); 而无须在前面加上包前缀。还可以导入一个包中的特定类： import java.time.LocalDate; java.time.*的语法比较简单，对代码的规模也没有任何负面影响。不过，如果能够明确地指出所导入的类，代码的读者就能更加准确地知道你使用了哪些类。 程序示例一import java.time.LocalDate; public class HuangZiHanTest &#123; public static void main(String[] huangzihan_args) &#123; LocalDate huangzihan_today &#x3D; LocalDate.now(); System.out.println(huangzihan_today); &#125; &#125; 运行结果一2021-07-19 程序示例二import java.time.*; public class HuangZiHanTest &#123; public static void main(String[] huangzihan_args) &#123; LocalDate huangzihan_today &#x3D; LocalDate.now(); System.out.println(huangzihan_today); &#125; &#125; 运行结果二2021-07-19 提示 在Eclipse中，可以使用莱单选项Source——&gt;Organize Imports。诸如import java.util.*;等包语句将会自动扩展为一组特定的导入语句，如： import java.util.Arraylist; import java.util.Date; 提示 这是一个十分便捷的特性。 但是，需要注意的是，只能使用星号（）导入一个包，而不能使用`import java.或import java..`导入以java为前缀的所有包。 包的命名冲突 在大多数情况下，可以只导入你需要的包，并不必过多地考虑它们。但在发生命名冲突的时候，就要注意包了。例如，java.util和java.sql包都有Date类。如果在程序中导入了这两个包： import java.util.*; import java.sql.*; 在程序中使用Date类的时候，就会出现一个编译错误： Date today; &#x2F;&#x2F; ERROR--java.util.Date or java.sql.Date？ 程序示例一import java.util.*; import java.sql.*; public class HuangZiHanTest &#123; public static void main(String[] huangzihan_args) &#123; Date huangzihan_today; &#125; &#125; 运行结果一Exception in thread &quot;main&quot; java.lang.Error: Unresolved compilation problem: The type Date is ambiguous at HuangZiHanTest.main(HuangZiHanTest.java:8) 此时编译器无法确定你想使用的是哪一个Date类。可以增加一个特定的import语句来解决这个问题： import java.util.*; import java.sql.*; import java.util.Date; 程序示例二import java.util.*; import java.sql.*; import java.util.Date; public class HuangZiHanTest &#123; public static void main(String[] huangzihan_args) &#123; Date huangzihan_today; &#125; &#125; 运行结果二 如果这两个Date类都需要使用，又该怎么办呢？答案是，在每个类名的前面加上完整的包名。 var deadline &#x3D; new java.util.Date(); var today &#x3D; new java.sql.Date(...); 在包中定位类是编译器（compiler）的工作。类文件中的字节码总是使用完整的包名引用其他类。 程序示例三import java.util.*; import java.sql.*; import java.util.Date; public class HuangZiHanTest &#123; public static void main(String[] huangzihan_args) &#123; var huangzihan_deadline &#x3D; new java.util.Date(); var huangzihan_today &#x3D; new java.sql.Date(0); System.out.println(huangzihan_deadline); System.out.println(huangzihan_today); &#125; &#125; 运行结果三Mon Jul 19 10:33:53 CST 2021 1970-01-01 静态导入 有一种import语句允许导入静态方法和静态字段，而不只是类。 例如，如果在源文件顶部，添加一条指令： import static java.lang.System.*; 就可以使用System类的静态方法和静态字段，而不必加类名前缀： out.println(&quot;Goodbye, World!&quot;); &#x2F;&#x2F; i.e., System.out exit(0); &#x2F;&#x2F; i.e., System.exit 程序示例import static java.lang.System.*; public class HuangZiHanTest &#123; public static void main(String[] huangzihan_args) &#123; out.println(&quot;黄子涵&quot;); exit(0); &#125; &#125; 运行结果黄子涵 另外，还可以导入特定的方法或字段： import static java.lang.System.out; 实际上，是否有很多程序员想要用简写System.out或System.exit，这一点很让人怀疑。这样写出的代码看起来不太清晰。不过， sqrt(pow(x, 2) + pow(y, 2)) 看起来比 Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)) 清晰得多。 在包中增加类 要想将类放入包中，就必须将包的名字放在源文件的开头，即放在定义这个包中各个类的代码之前。例如，下面程序的文件Employee.java开头是这样的： package com.horstmann.corejava; public class Employee &#123; . . . &#125; 如果没有在源文件中放置package语句，这个源文件中的类就属于无名包（unnamed package）。无名包没有包名。到目前为止，我们定义的所有类都在这个无名包中。 将源文件放到与完整包名匹配的子目录中。例如，com.horstmann.corejava包中的所有源文件应该放置在子目录com/horstmann/corejava中（Windows中则是com\\horstmann\\corejava）。编译器将类文件也放在相同的目录结构中。 下面的程序分放在两个包中：PackageTest类属于无名包；Employee类属于com.horstmann.corejava包。因此，Employee.java文件必须包含在子目录com/horstmann/corejava中。换句话说，目录结构如下所示： . (base directory) |__ PackageText.java |__ PackageText.class |__ com&#x2F; |__ horstmann&#x2F; |__ corejava&#x2F; |__ Employee.java |__ Employee.class &#96;&#96;&#96; &gt; 要想编译这个程序，只需切换到基目录，并运行命令 &#96;&#96;&#96;C&#x2F;C++ javac PackageTest.java 编译器就会自动地查找文件com/horstmann/corejava/Employee.java并进行编译。 下面看一个更加实际的例子。在这里不使用无名包，而是将类分别放在不同的包中（com.horstmann.corejava和com.mycompany）。 . (base directory) |__ com&#x2F; |__ horstmann&#x2F; | |__ corejava&#x2F; | |__ Employee.java | |__ Employee.class |__ mycompany&#x2F; |__ PayrollApp.java |__ PayrollApp.class &#96;&#96;&#96; &gt; 在这种情况下，仍然要从基目录编译和运行类，即包含**com**目录的目录： &#96;&#96;&#96;C&#x2F;C++ javac com&#x2F;mycompany&#x2F;PayrollApp.java java com.mycompany.PayrolLApp 需要注意，编译器处理文件（带有文件分隔符和扩展名.java的文件），而Java解释器加载类（带有.分隔符）。 程序示例/JavaCore/src/Huangizhan_PackageTestpackage Huangizhan_PackageTest; import com.huangzihan.corejava.*; &#x2F;&#x2F;Employee 类在该包中定义 import static java.lang.System.*; &#x2F;* * @功能：该程序演示了包的使用。 * @版本：1.11 * @时间：2021-07-19 * @作者：黄子涵 * *&#x2F; public class Huangizhan_PackageTest &#123; public static void main(String[] huangzihan_args) &#123; &#x2F;&#x2F;由于导入语句，我们不必使用 &#x2F;&#x2F;com.huangzihan.corejava var huangzihan &#x3D; new Huangzihan_Employee(&quot;黄子涵&quot;, 50000, 1989, 10, 1); huangzihan.huangzihan_raiseSalary(5); &#x2F;&#x2F;由于静态导入语句，我们不必使用 System.在这里 out.println(&quot;名字&#x3D;&quot; + huangzihan.huangzihan_getName() + &quot;,工资&#x3D;&quot; + huangzihan.huangzihan_getSalary()); &#125; &#125; /JavaCore/src/com/huangzihan/corejavapackage com.huangzihan.corejava; &#x2F;&#x2F;这个文件中的类是这个包的一部分 import java.time.*; &#x2F;&#x2F;导入语句在包语句之后 &#x2F;* * @版本：1.11 * @时间：2015-05-08 * @作者：黄子涵 * *&#x2F; public class Huangzihan_Employee &#123; private String huangzihan_name; private double huangzihan_salary; private LocalDate huangzihan_hireDay; public Huangzihan_Employee(String huangzihan_name, double huangzihan_salary, int huangzihan_year, int huangzihan_month, int huangzihan_day) &#123; this.huangzihan_name &#x3D; huangzihan_name; this.huangzihan_salary &#x3D; huangzihan_salary; huangzihan_hireDay &#x3D; LocalDate.of(huangzihan_year, huangzihan_month, huangzihan_day); &#125; public String huangzihan_getName() &#123; return huangzihan_name; &#125; public double huangzihan_getSalary() &#123; return huangzihan_salary; &#125; public LocalDate huangzihan_getHireDay() &#123; return huangzihan_hireDay; &#125; public void huangzihan_raiseSalary(double huangzihan_byPercent) &#123; double huangzihan_raise &#x3D; huangzihan_salary * huangzihan_byPercent &#x2F; 100; huangzihan_salary +&#x3D; huangzihan_raise; &#125; &#125; 运行结果名字&#x3D;黄子涵,工资&#x3D;52500.0 警告 编译器在编译源文件的时候不检查目录结构。例如，假定一个源文件开头有以下指令： package com.mycompany; 即使这个源文件不在子目录com/mycompany下，也可以进行编译。如果它不依赖于其他包，就可以通过编译而不会出现编译错误。但是，最终的程序将无法运行，除非先将所有类文件移到正确的位置上。如果包与目录不匹配，虚拟机就找不到类。 包访问 前面已经接触过访问修饰符public和private。标记为public的部分可以由任意类使用；标记为private的部分只能由定义它们的类使用。如果没有指定public或private，这个部分（类、方法或变量）可以被同一个包中的所有方法访问。 如果我们没有将Employee类定义为公共类，因此只有在同一个包（在此是无名的包）中的其他类可以访问，例如EmployeeTest。对于类来说，这种默认方式是合乎情理的。但是，对于变量来说就有些不适宜了，变量必须显式地标记为private，不然的话将默认为包可访问。显然，这样做会破坏封装性。问题是人们经常忘记键入关键字private。java.awt包中的Window类就是一个典型的示例。java.awt包是JDK提供的部分源代码： public class Window extends Container &#123; String warningString; . . . &#125; 请注意，这里的warningString变量不是private！这意味着java.awt包中的所有类的方法都可以访问该变量，并将它设置为任意值（例如，“Trust me!“）。实际上，只有Window类的方法访问这个变量，因此本应该将它设置为私有变量才合适。可能是程序员敲代码时匆忙之中忘记private修饰符了？也可能是没有人关心这个问题？已经20多年了，这个变量仍然不是私有变量。不仅如此，这个类还陆续增加了一些新的字段，而其中大约有一半也不是私有的。 这可能会成为一个问题。在默认情况下，包不是封闭的实体。也就是说，任何人都可以向包中添加更多的类。当然，有恶意或低水平的程序员很可能利用包的可见性添加一些能修改变量的代码。例如，在Java程序设计语言的早期版本中，只需要将以下这条语句放在类文件的开头，就可以很容易地在java.awt包中混入其他类： package java.awt; 然后，把得到的类文件放置在类路径上某处的java/awt子目录下，这样就可以访问java.awt包的内部了。使用这一手段，完全可以设置警告字符串。 从1.2版开始，JDK的实现者修改了类加载器，明确地禁止加载包名以“java.”开头的用户自定义的类！当然，用户自定义的类无法从这种保护中受益。另一种机制是让JAR文件声明包为密封的（sealed），以防止第三方修改，但这种机制已经过时。现在应当使用模块封装包。 类路径 在前面已经看到，类存储在文件系统的子目录中。类的路径必须与包名匹配。 另外，类文件也可以存储在JAR（Java归档）文件中。在一个JAR文件中，可以包含多个压缩形式的类文件和子目录，这样既可以节省空间又可以改善性能。在程序中用到第三方的库文件时，你通常要得到一个或多个需要包含的JAR文件。 提示 JAR文件使用ZIP格式组织文件和子目录。可以使用任何ZIP工具查看JAR文件。 类能够被多个程序共享 为了使类能够被多个程序共享，需要做到下面几点： 把类文件放到一个目录中，例如/home/user/classdir。需要注意，这个目录是包树状结构的基目录。如果希望增加com.horstmann.corejava.Employee类，那么Employee.class类文件就必须位于子目录/home/user/classdir/com/horstmann/corejava中。 将JAR文件放在一个目录中，例如：/home/user/archives。 设置类路径（class path）。类路径是所有包含类文件的路径的集合。 在UNIX环境中，类路径中的各项之间用冒号（:）分隔： &#x2F;home&#x2F;user&#x2F;classdir:.:&#x2F;home&#x2F;user&#x2F;archives&#x2F;archive.jar 而在Windows环境中，则以分号（;）分隔： c:\\classdir;.;c:\\archives\\archive.jar 不论是UNIX还是Windows，都用句点（.）表示当前目录。 类路径包括： 基目录/home/user/classdir或c:\\classes; 当前目录（.）； JAR文件/home/user/archives/archive.jar或c:\\archives\\archive.jar。 从Java 6开始，可以在JAR文件目录中指定通配符，如下： &#x2F;home&#x2F;user&#x2F;classdir:.:&#x2F;home&#x2F;user&#x2F;archives&#x2F;&#39;*&#39; 或者 C:\\classdir；.；c:\\archives\\* 在UNIX中，*必须转义以防止shell扩展。 archives目录中的所有JAR文件（但不包括.class文件）都包含在这个类路径中。 由于总是会搜索Java API的类，所以不必显式地包含在类路径中。 警告 javac编译器总是在当前的目录中查找文件，但java虚拟机仅在类路径中包含“.”目录的时候才查看当前目录。如果没有设置类路径，那么没有什么问题，因为默认的类路径会包含“.”目录。但是如果你设置了类路径却忘记包含“.”目录，那么尽管你的程序可以没有错误地通过编译，但不能运行。 类路径所列出的目录和归档文件是搜寻类的起始点。下面看一个类路径示例： &#x2F;home&#x2F;user&#x2F;classdir:.:&#x2F;home&#x2F;user&#x2F;archives&#x2F;archive.jar 假定虚拟机要搜寻com.horstmann.corejava.Employee类的类文件。它首先要查看Java API类。显然，在那里找不到相应的类文件，所以转而查看类路径。然后查找以下文件： /home/user/classdir/com/horstmann/corejava/Employee.class com/horstmann/corejava/Employee.class（从当前目录开始） com/horstmann/corejava/Employee.class（/home/user/archives/archive.jar中） 编译器查找文件要比虚拟机复杂得多。如果引用了一个类，而没有指定这个类的包，那么编译器将首先查找包含这个类的包。它会查看所有的import指令，确定其中是否包含这个类。例如，假定源文件包含指令： import java.util.*; import com.horstmann.corejava.*; 并且源代码引用了Employee类。编译器将尝试查找java.lang.Employee（因为java.lang包总是会默认导入）、java.util.Employee、com.horstmann.corejava.Employee和当前包中的Employee。它会在类路径所有位置中搜索以上各个类。如果找到了一个以上的类，就会产生编译时错误（因为完全限定类名必须是唯一的，所以import语句的次序并不重要）。 编译器的任务不止这些，它还要查看源文件是否比类文件新。如果是这样的话，那么源文件就被自动地重新编译。在前面已经知道，只可以导入其他包中的公共类。一个源文件只能包含一个公共类，并且文件名与公共类名必须匹配。因此，编译器很容易找到公共类的源文件。不过，还可以从当前包中导入非公共类。这些类有可能在与类名不同的源文件中定义。如果从当前包中导入一个类，编译器就要搜索当前包中的所有源文件，查看哪个源文件定义了这个类。 设置类路径 最好使用-classpath（或-cp，或者Java 9中的--class-path）选项指定类路径： java -classpath &#x2F;home&#x2F;user&#x2F;classdir:.:&#x2F;home&#x2F;user&#x2F;archives&#x2F;archive.jar MyProg 或者 java -classpath c:\\classdir;.;c:\\archives\\archive.jar MyProg 整个指令必须写在一行中。将这样一个很长的命令行放在一个shell脚本或一个批处理文件中是个不错的主意。 利用-classpath选项设置类路径是首选的方法，也可以通过设置CLASSPATH环境变量来指定。具体细节依赖于所使用的shell。在Bourne Again shell（bash）中，命令如下： export CLASSPATH&#x3D;&#x2F;home&#x2F;user&#x2F;classdir:.：&#x2F;home&#x2F;user&#x2F;archives&#x2F;archive.jar 在Windows shell，命令如下： set CLASSPATH&#x3D;C:\\classdir；.；c:\\archives\\archive.jar 直到退出shell为止，类路径设置均有效。 警告 有人建议将CLASSPATH环境变量设置为永久不变的值。一般来说这是一个糟糕的想法。人们有可能会忘记全局设置，因此，当他们的类没有正确地加载时，就会感到很奇怪。一个应该受到谴责的示例是Windows中Apple的QuickTime安装程序。很多年来，它都将CLASSPATH全局设置为指向它需要的一个JAR文件，而没有在类路径中包含当前路径。因此，当程序编译后却不能运行时，无数Java程序员不得不花费很多精力去解决这个问题。 警告 过去，有人建议完全绕开类路径，将所有的文件都放在jre/lib/ext目录中。这种机制在Java 9中已经过时，不过不管怎样这都是一个不好的建议。很可能会从扩展目录加载一些已经遗忘很久的类，这会让人非常困惑。 注释 在Java9中，还可以从模块路径加载类。","path":"2021/07/19/包/","date":"07-19","excerpt":"包 Java允许使用包（package）将类组织在一个集合中。借助包可以方便地组织自己的代码，并将自己的代码与别人提供的代码库分开管理。下面我们将介绍如何使用和创建包。 包名 使用包的主要原因是确保类名的唯一性。假如两个程序员不约而同地建立了Employee类。只要将这些类放置在不同的包中，就不会产生冲突。事实上，为了保证包名的绝对唯一性，要用一个因特网域名（这显然是唯一的）以逆序的形式作为包名，然后对于不同的工程使用不同的子包。例如，考虑域名horstmann.com。如果逆序来写，就得到了包名com.horstmann。然后可以追加一个工程名，如com.horstmann.corejava。如果再把Employee类放在这个包里，那么这个类的“完全限定”名就是com.horstmann.corejava.Employee。 包名 注释 从编译器的角度来看，嵌套的包之间没有任何关系。例如，java.util包与java.util.jar包毫无关系。每一个包都是独立的类集合。 注释","tags":[]},{"title":"对象构造","text":"对象构造 构造器可以定义对象的初始状态。但是，由于对象构造非常重要，所以Java提供了多种编写构造器的机制。下面将详细介绍这些机制。 重载 有些类有多个构造器。例如，可以如下构造一个空的StringBuilder对象： var messages &#x3D; new StringBuilder(); 或者，可以指定一个初始字符串： var todolist &#x3D; new StringBuilder(&quot;To do:\\n&quot;); 这种功能叫做重载（overloading）。如果多个方法（比如，StringBuilder构造器方法）有相同的名字、不同的参数，便出现了重载。编译器必须挑选出具体调用哪个方法。它用各个方法首部中的参数类型与特定方法调用中所使用的值类型进行匹配，来选出正确的方法。如果编译器找不到匹配的参数，就会产生编译时错误，因为根本不存在匹配，或者没有一个比其他的更好（这个查找匹配的过程被称为重载解析（overloading resolution））。 程序示例public class HuangZiHanTest &#123; public static void main(String[] huangzihan_args) &#123; var huangzihan_messages &#x3D; new StringBuilder(&quot;黄子涵&quot;); var huangzihan_todoList &#x3D; new StringBuilder(&quot;黄子涵是帅哥！！！\\n&quot;); System.out.println(huangzihan_messages); System.out.println(huangzihan_todoList); &#125; &#125; 运行结果黄子涵 黄子涵是帅哥！！！ 注释方法的签名（signature） Java允许重载任何方法，而不只是构造器方法。因此，要完整地描述一个方法，需要指定方法名以及参数类型。这叫作方法的签名（signature）。例如，String类有4个名为indexOf的公共方法。它们的签名是 indexOf(int) indexOf(int, int) indexOf(String) indexOf(String, int) 返回类型不是方法签名的一部分。也就是说，不能有两个名字相同、参数类型也相同却有不同返回类型的方法。 程序示例public class HuangZiHanTest &#123; public static void main(String[] huangzihan_args) &#123; String huangzihan &#x3D; new String(&quot;黄子涵&quot;); System.out.println(&quot;************************************************&quot;); System.out.println(&quot;测试huangzihan.indexOf(int ch)&quot;); System.out.println(huangzihan.indexOf(&#39;黄&#39;)); System.out.println(huangzihan.indexOf(&#39;子&#39;)); System.out.println(huangzihan.indexOf(&#39;涵&#39;)); System.out.println(huangzihan.indexOf(&#39;!&#39;)); &#x2F;&#x2F;原字符串不包含“！” System.out.println(huangzihan.indexOf(&#39;\\u9ec4&#39;)); &#x2F;&#x2F;“黄”字的Unicode编码是\\u9ec4 System.out.println(huangzihan.indexOf(&#39;\\u5b50&#39;)); &#x2F;&#x2F;“子”字的Unicode编码是\\u5b50 System.out.println(huangzihan.indexOf(&#39;\\u6db5&#39;)); &#x2F;&#x2F;“涵”字的Unicode编码是\\u6db5 System.out.println(huangzihan.indexOf(&#39;\\u0021&#39;)); &#x2F;&#x2F;“！”字的Unicode编码是\\u0021 System.out.println(&quot;************************************************&quot;); System.out.println(); System.out.println(&quot;************************************************&quot;); System.out.println(&quot;测试huangzihan.indexOf(int ch, int fromIndex)&quot;); System.out.println(&quot;返回值为指定索引查找指定字符中第一个的索引：&quot;); System.out.println(huangzihan.indexOf(&#39;涵&#39;, 2)); System.out.println(huangzihan.indexOf(&#39;涵&#39;, 1)); System.out.println(huangzihan.indexOf(&#39;涵&#39;, 0)); System.out.println(huangzihan.indexOf(&#39;子&#39;, 1)); System.out.println(huangzihan.indexOf(&#39;子&#39;, 0)); System.out.println(huangzihan.indexOf(&#39;黄&#39;, 0)); System.out.println(); System.out.println(&quot;返回值为-1：&quot;); System.out.println(huangzihan.indexOf(&#39;黄&#39;, 1)); System.out.println(huangzihan.indexOf(&#39;黄&#39;, 2)); System.out.println(huangzihan.indexOf(&#39;子&#39;, 2)); System.out.println(huangzihan.indexOf(&#39;！&#39;, 0)); System.out.println(huangzihan.indexOf(&#39;！&#39;, 1)); System.out.println(huangzihan.indexOf(&#39;！&#39;, 2)); System.out.println(&quot;************************************************&quot;); System.out.println(); System.out.println(&quot;************************************************&quot;); System.out.println(&quot;测试huangzihan.indexOf(String str)&quot;); System.out.println(&quot;返回值为第一个字符的索引：&quot;); System.out.println(huangzihan.indexOf(&quot;黄&quot;)); &#x2F;&#x2F;返回“黄”的索引 System.out.println(huangzihan.indexOf(&quot;子&quot;)); &#x2F;&#x2F;返回“子”的索引 System.out.println(huangzihan.indexOf(&quot;涵&quot;)); &#x2F;&#x2F;返回“涵”的索引 System.out.println(huangzihan.indexOf(&quot;黄子&quot;)); &#x2F;&#x2F;返回“黄子”中“黄”的索引 System.out.println(huangzihan.indexOf(&quot;黄子涵&quot;)); &#x2F;&#x2F;返回“黄子涵”中“黄”的索引 System.out.println(huangzihan.indexOf(&quot;子涵&quot;)); &#x2F;&#x2F;返回“子涵”中“子”的索引 System.out.println(&quot;返回值为-1：&quot;); System.out.println(huangzihan.indexOf(&quot;！&quot;)); &#x2F;&#x2F;原字符串不包含“！” System.out.println(huangzihan.indexOf(&quot;黄子涵！&quot;)); &#x2F;&#x2F;原字符串不包含“！” System.out.println(huangzihan.indexOf(&quot;黄涵&quot;)); &#x2F;&#x2F;比原字符串少了“子” System.out.println(&quot;************************************************&quot;); System.out.println(); System.out.println(&quot;************************************************&quot;); System.out.println(&quot;测试huangzihan.indexOf(String str, int fromIndex)&quot;); System.out.println(&quot;返回值为指定索引查找指定字符串中第一个的索引：&quot;); System.out.println(huangzihan.indexOf(&quot;黄&quot;, 0)); System.out.println(huangzihan.indexOf(&quot;黄子&quot;, 0)); System.out.println(huangzihan.indexOf(&quot;黄子涵&quot;, 0)); System.out.println(huangzihan.indexOf(&quot;子涵&quot;, 0)); System.out.println(huangzihan.indexOf(&quot;涵&quot;, 0)); System.out.println(huangzihan.indexOf(&quot;子涵&quot;, 1)); System.out.println(huangzihan.indexOf(&quot;涵&quot;, 1)); System.out.println(huangzihan.indexOf(&quot;涵&quot;, 2)); System.out.println(&quot;返回值为-1&quot;); System.out.println(huangzihan.indexOf(&quot;黄&quot;, 1)); System.out.println(huangzihan.indexOf(&quot;黄子&quot;, 1)); System.out.println(huangzihan.indexOf(&quot;黄子涵&quot;, 1)); System.out.println(huangzihan.indexOf(&quot;黄&quot;, 2)); System.out.println(huangzihan.indexOf(&quot;黄子&quot;, 2)); System.out.println(huangzihan.indexOf(&quot;黄子涵&quot;, 2)); System.out.println(huangzihan.indexOf(&quot;子涵&quot;, 2)); System.out.println(huangzihan.indexOf(&quot;黄子涵！&quot;, 0)); System.out.println(huangzihan.indexOf(&quot;黄子涵！&quot;, 1)); System.out.println(huangzihan.indexOf(&quot;黄子涵！&quot;, 2)); System.out.println(huangzihan.indexOf(&quot;黄涵&quot;, 0)); System.out.println(huangzihan.indexOf(&quot;黄涵！&quot;, 1)); System.out.println(huangzihan.indexOf(&quot;黄涵！&quot;, 2)); System.out.println(&quot;************************************************&quot;); &#125; &#125; 运行结果************************************************ 测试huangzihan.indexOf(int ch) 0 1 2 -1 0 1 2 -1 ************************************************ ************************************************ 测试huangzihan.indexOf(int ch, int fromIndex) 返回值为指定索引查找指定字符中第一个的索引： 2 2 2 1 1 0 返回值为-1： -1 -1 -1 -1 -1 -1 ************************************************ ************************************************ 测试huangzihan.indexOf(String str) 返回值为第一个字符的索引： 0 1 2 0 0 1 返回值为-1： -1 -1 -1 ************************************************ ************************************************ 测试huangzihan.indexOf(String str, int fromIndex) 返回值为指定索引查找指定字符串中第一个的索引： 0 0 0 1 2 1 2 2 返回值为-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 ************************************************ 默认字段初始化 如果在构造器中没有显式地为字段设置初值，那么就会被自动地赋为默认值：数值为0、布尔值为false、对象引用为null。有些人认为依赖默认值的做法是一种不好的编程实践。确实，如果不明确地对字段进行初始化，就会影响程序代码的可读性。 注释 这是字段与局部变量的一个重要区别。方法中的局部变量必须明确地初始化。但是在类中，如果没有初始化类中的字段，将会自动初始化为默认值（0、false或null）。 例如，考虑Employee类。假定没有在构造器中指定如何初始化某些字段，默认情况下，就会将salary字段初始化为0，将name和hireDay字段初始化为null。 但是，这并不是一个好主意。如果此时调用getName方法或getHireDay方法，就会得到一个null引用，这应该不是我们所希望的结果： LocalDate h &#x3D; harry.getHireDay(); int year &#x3D; h.getYear(); &#x2F;&#x2F; throws exception if h is null 无参数的构造器 很多类都包含一个无参数的构造器，由无参数构造器创建对象时，对象的状态会设置为适当的默认值。例如，以下是Employee类的无参数构造器： public Employee() &#123; name &#x3D; &quot;&quot;; salary &#x3D; 0; hireDay &#x3D; LocalDate.now(); &#125; 如果写一个类时没有编写构造器，就会为你提供一个无参数构造器。这个构造器将所有的实例字段设置为默认值。于是，实例字段中的数值型数据设置为0，布尔型数据设置为false，所有对象变量将设置为null。 如果类中提供了至少一个构造器，但是没有提供无参数的构造器，那么构造对象时如果不提供参数就是不合法的。例如，下面程序中的Employee类提供了一个简单的构造器： public Employee(String n, double s, int year, int month, int day) 对于这个类，构造默认的员工就是不合法的。也就是说，调用 e &#x3D; new Employee(); 将会产生错误。 程序示例import java.time.LocalDate; public class HuangZiHanTest &#123; public static void main(String[] huangzihan_args) &#123; Huangzihan_Employee huangzihan_e &#x3D; new Huangzihan_Employee(null, 0, 0, 0, 0); System.out.println(huangzihan_e.huangzihan_getName()); System.out.println(huangzihan_e.huangzihan_getSalary()); System.out.println(huangzihan_e.getHireDay()); &#125; &#125; class Huangzihan_Employee &#123; &#x2F;&#x2F; instance fields private String huangzihan_name; private double huangzihan_salary; private LocalDate huangzihan_hireDay; &#x2F;&#x2F; constructor public Huangzihan_Employee(String huangzihan_n, double huangzihan_s, int huangzihan_year, int huangzihan_month, int huangzihan_day) &#123; huangzihan_name &#x3D; &quot;&quot;; huangzihan_salary &#x3D; 0; huangzihan_hireDay &#x3D; LocalDate.now(); &#125; &#x2F;&#x2F; a method public String huangzihan_getName() &#123; return huangzihan_name; &#125; public double huangzihan_getSalary() &#123; return huangzihan_salary; &#125; public LocalDate getHireDay() &#123; return huangzihan_hireDay; &#125; &#125; 运行结果 0.0 2021-07-18 警告 请记住，仅当类没有任何其他构造器的时候，你才会得到一个默认的无参数构造器。编写类的时候，如果写了一个你自己的构造器，要想让这个类的用户能够通过以下调用构造一个实例： new ClassName() 你就必须提供一个无参数的构造器。当然，如果希望所有字段被赋予默认值，只需要提供以下代码： public ClassName() 显式字段初始化 通过重载类的构造器方法，可以采用多种形式设置类的实例字段的初始状态。不管怎样调用构造器，每个实例字段都要设置为一个有意义的初值，确保这一点总是一个好主意。 可以在类定义中直接为任何字段赋值。例如： class Employee &#123; private String name &#x3D; &quot;&quot;; &#125; 在执行构造器之前先完成这个赋值操作。如果一个类的所有构造器都希望把某个特定的实例字段设置为同一个值，这个语法就特别有用。 初始值不一定是常量值。在下面的例子中，就是利用方法调用初始化一个字段。考虑以下Employee类，其中每个员工有一个id字段。可以使用下列方式进行初始化： class Employee &#123; private static int nextId; private int id &#x3D; assignId(); . . . private static int assignId() &#123; int r &#x3D; nextId; nextId++; return r; &#125; &#125; 参数名 在编写很小的构造器时（这十分常见），常常在参数命名时感到困惑。 用单个字母作为参数名 我们通常喜欢用单个字母作为参数名： public Employee(String n, double s) &#123; name &#x3D; n; salary &#x3D; s; &#125; 但这样做有一个缺点：只有阅读代码才能够了解参数n和参数s的含义。 参数名前面加前缀“a” 有些程序员在每个参数前面加上一个前缀“a”： public Employee(String aName, double aSalary) &#123; name &#x3D; aName; salary &#x3D; aSalary; &#125; 这样很清晰。读者一眼就能够看懂参数的含义。 还一种常用的技巧，它基于这样的事实：参数变量会遮蔽同名的实例字段。例如，如果将参数命名为salary，salary将指示这个参数，而不是实例字段。但是，还是可以用this.salary访问实例字段。回想一下，this指示隐式参数，也就是所构造的对象。下面是一个示例： public Employee(String name, double salary) &#123; this.name &#x3D; name; this.salary &#x3D; salary; &#125; 调用另一个构造器关键字this 关键字this指示一个方法的隐式参数。不过，这个关键字还有另外一个含义。 如果构造器的第一个语句形如this（…），这个构造器将调用同一个类的另一个构造器。下面是一个典型的例子： public Employee(double s) &#123; &#x2F;&#x2F; calls Employee(String, double) this(&quot;Employee #&quot; + nextId, s); nextId++; &#125; 当调用new Employe(60000)时，Employee(double)构造器将调用Employee(String, double)构造器。 采用这种方式使用this关键字非常有用，这样对公共的构造器代码只需要编写一次即可。 初始化块两种初始化数据字段的方法 前面已经讲过两种初始化数据字段的方法： 在构造器中设置值； 在声明中赋值。 实际上，Java还有第三种机制，称为初始化块（initialization block）。在一个类的声明中，可以包含任意多个代码块。只要构造这个类的对象，这些块就会被执行。例如， class Employee &#123; private static int nextId; private int id; private String name; private double salary; &#x2F;&#x2F; object initialization block &#123; id &#x3D; nextId; nextId++; &#125; public Employee(String n, double s) &#123; name &#x3D; n; salary &#x3D; s; &#125; public Employee() &#123; name &#x3D; &quot;&quot;; salary &#x3D; 0; &#125; . . . &#125; 在这个示例中，无论使用哪个构造器构造对象，id字段都会在对象初始化块中初始化。首先运行初始化块，然后才运行构造器的主体部分。 这种机制不是必需的，也不常见。通常会直接将初始化代码放在构造器中。 注释 可以在初始化块中设置字段，即使这些字段在类后面才定义，这是合法的。但是，为了避免循环定义，不允许读取在后面初始化的字段。具体规则请参看Java语言规范的网址（http://docs.oracle.com/javase/specs）。这些规则太过复杂，让编译器的实现者都很头疼，所以较早的Java版本中这些规则的实现存在一些小错误。因此建议总是将初始化块放在字段定义之后。 调用构造器的具体处理步骤 由于初始化数据字段有多种途径，所以列出构造过程的所有路径可能让人很困惑。下面是调用构造器的具体处理步骤： 如果构造器的第一行调用了另一个构造器，则基于所提供的参数执行第二个构造器。 否则， a） 所有数据字段初始化为其默认值（0、false或nul）。 b）按照在类声明中出现的顺序，执行所有字段初始化方法和初始化块。 执行构造器主体代码。 当然，应该精心地组织好初始化代码，这样有利于其他程序员理解。例如，如果让类的构造器依赖于数据字段声明的顺序，那就会显得很奇怪并且容易引起错误。 可以通过提供一个初始值，或者使用一个静态的初始化块来初始化静态字段。前面已经介绍过第一种机制： private static int nextId &#x3D; 1; 如果类的静态字段需要很复杂的初始化代码，那么可以使用静态的初始化块。 将代码放在一个块中，并标记关键字static。下面是一个示例。其功能是将员工ID的起始值赋予一个小于10 000的随机整数。 &#x2F;&#x2F; static initialization block static &#123; var generator &#x3D; new Random(); nextId &#x3D; generator.nextInt(10000); &#125; 在类第一次加载的时候，将会进行静态字段的初始化。与实例字段一样，除非将静态字段显式地设置成其他值，否则默认的初始值是0、false或null。所有的静态字段初始化方法以及静态初始化块都将依照类声明中出现的顺序执行。 注释 让人惊讶的是，在JDK6之前，都可以用Java编写一个没有main方法的“Hello, World”程序。 public class Hello &#123; static &#123; System.out.println(&quot;Hello, World&quot;); &#125; &#125; 当用java Hello调用这个类时，就会加载这个类，静态初始化块将会打印“Hello, World”。在此之后才会显示一个消息指出main未定义。从Java 7以后，java程序首先会检查是否有一个main方法。 下面程序展示了本节讨论的很多特性： 重载构造器； 用this(…)调用另一个构造器； 无参数构造器； 对象初始化块； 静态初始化块； 实例字段初始化。 程序示例import java.time.LocalDate; import java.util.Random; &#x2F;* * @功能：该程序演示了对象构造。 * @版本：1.02 * @时间：2021-07-19 * @作者：黄子涵 * *&#x2F; public class HuangZiHanTest &#123; public static void main(String[] huangzihan_args) &#123; &#x2F;&#x2F;用三个Employee对象填充人员数组 var huangzihan &#x3D; new Huangzihan_Employee[3]; huangzihan[0] &#x3D; new Huangzihan_Employee(&quot;huangzihan&quot;, 40000); huangzihan[1] &#x3D; new Huangzihan_Employee(60000); huangzihan[2] &#x3D; new Huangzihan_Employee(); &#x2F;&#x2F;打印出所有Employee对象的信息 for(Huangzihan_Employee huangzihan_e : huangzihan) &#123; System.out.println(&quot;名字&#x3D;&quot; + huangzihan_e.huangzihan_getName() + &quot;,id&#x3D;&quot; + huangzihan_e.huangzihan_getId() + &quot;,工资&#x3D;&quot; + huangzihan_e.huangzihan_getSalary()); &#125; &#125; &#125; class Huangzihan_Employee &#123; private static int huangzihan_nextId; private int huangzihan_id; private String huangzihan_name &#x3D; &quot;&quot;; &#x2F;&#x2F;实例字段初始化 private double huangzihan_salary; &#x2F;&#x2F;静态初始化块 static &#123; var huangzihan_generator &#x3D; new Random(); &#x2F;&#x2F;将 nextId 设置为 0 到 9999 之间的随机数 huangzihan_nextId &#x3D; huangzihan_generator.nextInt(10000); &#125; &#x2F;&#x2F;对象初始化块 &#123; huangzihan_id &#x3D; huangzihan_nextId; huangzihan_nextId++; &#125; &#x2F;&#x2F;三个重载构造函数 public Huangzihan_Employee(String huangzihan_n, double huangzihan_s) &#123; huangzihan_name &#x3D; huangzihan_n; huangzihan_salary &#x3D; huangzihan_s; &#125; public Huangzihan_Employee(double huangzihan_s) &#123; &#x2F;&#x2F;调用Employee(String,double)构造函数 this(&quot;Huangzihan_Employee #&quot; + huangzihan_nextId, huangzihan_s); &#125; &#x2F;&#x2F;默认构造函数 public Huangzihan_Employee() &#123; &#x2F;&#x2F;名称初始化为&quot;&quot;。--见上文 &#x2F;&#x2F;工资未明确设置--初始化为0 &#x2F;&#x2F;id在初始化块中初始化 &#125; public String huangzihan_getName() &#123; return huangzihan_name; &#125; public double huangzihan_getSalary() &#123; return huangzihan_salary; &#125; public int huangzihan_getId() &#123; return huangzihan_id; &#125; &#125; 运行结果名字&#x3D;huangzihan,id&#x3D;4294,工资&#x3D;40000.0 名字&#x3D;Huangzihan_Employee #4295,id&#x3D;4295,工资&#x3D;60000.0 名字&#x3D;,id&#x3D;4296,工资&#x3D;0.0 对象析构与finalize方法 有些面向对象的程序设计语言，特别是C++，有显式的析构器方法，其中放置一些当对象不再使用时需要执行的清理代码。在析构器中，最常见的操作是回收分配给对象的存储空间。由于Java会完成自动的垃圾回收，不需要人工回收内存，所以Java不支持析构器。 当然，某些对象使用了内存之外的其他资源，例如，文件或使用了系统资源的另一个对象的句柄。在这种情况下，当资源不再需要时，将其回收和再利用显得十分重要。 如果一个资源一旦使用完就需要立即关闭，那么应当提供一个close方法来完成必要的清理工作。可以在对象使用完时调用这个close方法。 如果可以等到虚拟机退出，那么可以用方法Runtime.addShutdownHook增加一个“关闭钩”（shutdown hook）。在Java 9中，可以使用Cleaner类注册一个动作，当对象不再可达时（除了清洁器还能访问，其他对象都无法访问这个对象），就会完成这个动作。在实际中这些情况很少见。可以参见API文档来了解这两种方法的详细内容。 警告 不要使用finalize方法来完成清理。这个方法原本要在垃圾回收器清理对象之前调用。不过，你并不能知道这个方法到底什么时候调用，而且该方法已经被废弃。","path":"2021/07/19/对象构造/","date":"07-19","excerpt":"对象构造 构造器可以定义对象的初始状态。但是，由于对象构造非常重要，所以Java提供了多种编写构造器的机制。下面将详细介绍这些机制。 重载 有些类有多个构造器。例如，可以如下构造一个空的StringBuilder对象： var messages &#x3D; new StringBuilder(); 或者，可以指定一个初始字符串： var todolist &#x3D; new StringBuilder(&quot;To do:\\n&quot;); 这种功能叫做重载（overloading）。如果多个方法（比如，StringBuilder构造器方法）有相同的名字、不同的参数，便出现了重载。编译器必须挑选出具体调用哪个方法。它用各个方法首部中的参数类型与特定方法调用中所使用的值类型进行匹配，来选出正确的方法。如果编译器找不到匹配的参数，就会产生编译时错误，因为根本不存在匹配，或者没有一个比其他的更好（这个查找匹配的过程被称为重载解析（overloading resolution））。 程序示例public class HuangZiHanTest &#123; public static void main(String[] huangzihan_args) &#123; var huangzihan_messages &#x3D; new StringBuilder(&quot;黄子涵&quot;); var huangzihan_todoList &#x3D; new StringBuilder(&quot;黄子涵是帅哥！！！\\n&quot;); System.out.println(huangzihan_messages); System.out.println(huangzihan_todoList); &#125; &#125;","tags":[]},{"title":"方法参数","text":"方法参数按值调用和按引用调用 按值调用（call by value）表示方法接收的是调用者提供的值。而按引用调用（call by reference）表示方法接收的是调用者提供的变量地址。方法可以修改按引用传递的变量的值，而不能修改按值传递的变量的值。“按……调用”（call by）是一个标准的计算机科学术语，用来描述各种程序设计语言（不只是Java）中方法参数的传递方式（事实上，以前还有按名调用（call byname），Algol程序设计语言是最古老的高级程序设计语言之一，它使用的就是这种参数传递方式。不过，这种传递方式已经成为历史）。 Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个副本。具体来讲，方法不能修改传递给它的任何参数变量的内容。 例如，考虑下面的调用： double percent &#x3D; 10; harry.raiseSalary(percent); 不论这个方法具体如何实现，我们知道，在这个方法调用之后，percent的值还是10。 下面再仔细研究一下这种情况。假定一个方法试图将一个参数值增加至3倍： public static void tripleValue(double x) &#x2F;&#x2F; doesn&#39;t work &#123; x &#x3D; 3 * x; &#125; 然后调用这个方法： double percent &#x3D; 10; tripleValue(percent); 调用方法执行过程 不过，这样并不能起作用。调用这个方法之后，percent的值还是10。下面看一下具体的执行过程： x初始化为percent值的一个副本（也就是10）。 x乘以3后等于30，但是percent仍然是10（如图（修改数值参数没有持久效果）所示）。 这个方法结束之后，参数变量x不再使用。 修改数值参数没有持久效果 修改数值参数没有持久效果 两种类型的方法参数然而，有两种类型的方法参数： 基本数据类型（数字、布尔值）。 对象引用。 你已经看到，一个方法不可能修改基本数据类型的参数，而对象引用作为参数就不同了，可以很容易地利用下面这个方法将一个员工的工资增至三倍： public static void tripleSalary(Employee x) &#x2F;&#x2F; works &#123; x.raiseSalary(200); &#125; 当调用 harry &#x3D; new Employee(. . .); tripleSalary(harry); 时，具体的执行过程为： x初始化为harry值的一个副本，这里就是一个对象引用。 raiseSalary方法应用于这个对象引用。x和harry同时引用的那个Employee对象的工资提高了200%。 方法结束后，参数变量x不再使用。当然，对象变量harry继续引用那个工资增至3倍的员工对象（如图（修改对象参数有持久效果）所示）。 修改对象参数有持久效果 修改对象参数有持久效果 可以看到，实现一个改变对象参数状态的方法是完全可以的，实际上也相当常见。理由很简单，方法得到的是对象引用的副本，原来的对象引用和这个副本都引用同一个对象。 很多程序设计语言（特别是C++和Pascal）提供了两种参数传递的方式：按值调用和按引用调用。有些程序员（甚至有些书的作者）认为Java程序设计语言对对象采用的是按引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以很有必要给出一个反例来详细地说明一下这个问题。 首先，编写一个交换两个Employee对象的方法： public static void swap(Employee x, Employee y) &#x2F;&#x2F; doesn&#39;t work &#123; Employee temp &#x3D; x; x &#x3D; y; y &#x3D; temp; &#125; 如果Java对对象采用的是按引用调用，那么这个方法就应该能够实现交换： var a &#x3D; new Employee(&quot;Alice&quot;, . . .); var b &#x3D; new Employee(&quot;Bob&quot;, . . .); swap(a, b); &#x2F;&#x2F; does a now refer to Bob, b to Alice? 但是，这个方法并没有改变存储在变量a和b中的对象引用。swap方法的参数x和y被初始化为两个对象引用的副本，这个方法交换的是这两个副本。 &#x2F;&#x2F; x refers to Alice, y to Bob Employee temp &#x3D; x; x &#x3D; y; y &#x3D; temp; &#x2F;&#x2F; now x refers to Bob, y to Alice 最终，白费力气。在方法结束时参数变量x和y被丢弃了。原来的变量a和b仍然引用这个方法调用之前所引用的对象（如图（交换对象参数没有持久效果）所示）。 交换对象参数没有持久效果 交换对象参数没有持久效果 这个过程说明：Java程序设计语言对对象采用的不是按引用调用，实际上，对象引用是按值传递的。 Java中方法参数的使用 下面总结一下在Java中对方法参数能做什么和不能做什么： 方法不能修改基本数据类型的参数（即数值型或布尔型）。 方法可以改变对象参数的状态。 方法不能让一个对象参数引用一个新的对象。 程序清单4-4中的程序展示了这几点。在这个程序中，首先试图将一个数值参数的值增至三倍，但没有成功： Testing tripleValue: Before: percent&#x3D;10.0 End of method: x&#x3D;30.0 After: percent&#x3D;10.0 随后，成功地将一个员工的工资增至三倍： Testing tripleSalary: Before: salary&#x3D;50000.0 End of method:salary&#x3D;150000.0 After: salary&#x3D;150000.0 方法结束之后，harry引用的对象状态发生了改变。这是因为这个方法可以通过对象引用的副本修改所引用对象的状态。 最后，程序演示了swap方法的失败效果： Testing swap: Before: a&#x3D;Alice Before: b&#x3D;Bob End of method: x&#x3D;Bob End of method: y&#x3D;Alice After: a&#x3D;Alice After: b&#x3D;Bob 可以看出，参数变量x和y交换了，但是变量a和b没有受到影响。 程序示例&#x2F;* * 功能：这个程序演示了Java中的参数传递。 * @版本：1.01 * @时间：2021-07-17 * @作者：黄子涵 * *&#x2F; public class HuangZiHanTest &#123; public static void main(String[] huangzihan_args) &#123; &#x2F;*测试一：方法不能修改数值参数*&#x2F; System.out.println(&quot;测试一：方法不能修改数值参数&quot;); System.out.println(&quot;huangzihan_tripleValue()测试中：&quot;); double huangzihan_percent &#x3D; 10; System.out.println(&quot;测试之前：huangzihan_percent&#x3D;&quot; + huangzihan_percent); huangzihan_tripleValue(huangzihan_percent); System.out.println(&quot;测试之后：huangzihan_percent()&#x3D;&quot; + huangzihan_percent); System.out.println(); &#x2F;*测试二：方法可以更改对象参数的状态*&#x2F; System.out.println(&quot;测试二：方法可以更改对象参数的状态&quot;); System.out.println(&quot;huangzihan_tripleSalary()测试中:&quot;); var huangzihan &#x3D; new Huangzihan_Employee(&quot;huangzihan&quot;, 50000); System.out.println(&quot;测试之前：huangzihan_salary()&#x3D;&quot; + huangzihan.huangzihan_getSalary()); huangzihan_tripleSalary(huangzihan); System.out.println(&quot;测试之后：huangzihan_salary()&#x3D;&quot; + huangzihan.huangzihan_getSalary()); System.out.println(); &#x2F;*测试三：方法无法将新对象附加到对象参数*&#x2F; System.out.println(&quot;测试三：方法无法将新对象附加到对象参数&quot;); System.out.println(&quot;huangzihan_swap()测试中：&quot;); var huangzihan_a &#x3D; new Huangzihan_Employee(&quot;Huangzihan_Alice&quot;, 70000); var huangzihan_b &#x3D; new Huangzihan_Employee(&quot;Huangzihan_Bob&quot;, 60000); System.out.println(&quot;测试之前：huangzihan_a&#x3D;&quot; + huangzihan_a.huangzihan_getName()); System.out.println(&quot;测试之前：huangzihan_b&#x3D;&quot; + huangzihan_b.huangzihan_getName()); huangzihan_swap(huangzihan_a, huangzihan_b); System.out.println(&quot;测试之后：huangzihan_a&#x3D;&quot; + huangzihan_a.huangzihan_getName()); System.out.println(&quot;测试之后：huangzihan_b&#x3D;&quot; + huangzihan_b.huangzihan_getName()); System.out.println(); &#125; public static void huangzihan_tripleValue(double huangzihan_x) &#123; huangzihan_x &#x3D; 3* huangzihan_x; System.out.println(&quot;方法结束：huangzihan_x&#x3D;&quot; + huangzihan_x); &#125; public static void huangzihan_tripleSalary(Huangzihan_Employee huangzihan_x) &#123; huangzihan_x.huangzihan_raiseSalary(200); System.out.println(&quot;方法结束：huangzihan_salary&#x3D;&quot; + huangzihan_x.huangzihan_getSalary()); &#125; public static void huangzihan_swap(Huangzihan_Employee huangzihan_x, Huangzihan_Employee huangzihan_y) &#123; Huangzihan_Employee huangzihan_temp &#x3D; huangzihan_x; huangzihan_x &#x3D; huangzihan_y; huangzihan_y &#x3D; huangzihan_temp; System.out.println(&quot;方法结束：huangzihan_x&#x3D;&quot; + huangzihan_x.huangzihan_getName()); System.out.println(&quot;方法结束：huangzihan_y&#x3D;&quot; + huangzihan_y.huangzihan_getName()); &#125; &#125; class Huangzihan_Employee &#123; String huangzihan_name; double huangzihan_salary; public Huangzihan_Employee(String huangzihan_n, double huangzihan_s) &#123; huangzihan_name &#x3D; huangzihan_n; huangzihan_salary &#x3D; huangzihan_s; &#125; public String huangzihan_getName() &#123; return huangzihan_name; &#125; public double huangzihan_getSalary() &#123; return huangzihan_salary; &#125; public void huangzihan_raiseSalary(double huangzihan_byPercent) &#123; double huangzihan_raise &#x3D; huangzihan_salary * huangzihan_byPercent &#x2F; 100; huangzihan_salary +&#x3D; huangzihan_raise; &#125; &#125; 运行结果测试一：方法不能修改数值参数 huangzihan_tripleValue()测试中： 测试之前：huangzihan_percent&#x3D;10.0 方法结束：huangzihan_x&#x3D;30.0 测试之后：huangzihan_percent()&#x3D;10.0 测试二：方法可以更改对象参数的状态 huangzihan_tripleSalary()测试中: 测试之前：huangzihan_salary()&#x3D;50000.0 方法结束：huangzihan_salary&#x3D;150000.0 测试之后：huangzihan_salary()&#x3D;150000.0 测试三：方法无法将新对象附加到对象参数 huangzihan_swap()测试中： 测试之前：huangzihan_a&#x3D;Huangzihan_Alice 测试之前：huangzihan_b&#x3D;Huangzihan_Bob 方法结束：huangzihan_x&#x3D;Huangzihan_Bob 方法结束：huangzihan_y&#x3D;Huangzihan_Alice 测试之后：huangzihan_a&#x3D;Huangzihan_Alice 测试之后：huangzihan_b&#x3D;Huangzihan_Bob","path":"2021/07/17/方法参数/","date":"07-17","excerpt":"方法参数按值调用和按引用调用 按值调用（call by value）表示方法接收的是调用者提供的值。而按引用调用（call by reference）表示方法接收的是调用者提供的变量地址。方法可以修改按引用传递的变量的值，而不能修改按值传递的变量的值。“按……调用”（call by）是一个标准的计算机科学术语，用来描述各种程序设计语言（不只是Java）中方法参数的传递方式（事实上，以前还有按名调用（call byname），Algol程序设计语言是最古老的高级程序设计语言之一，它使用的就是这种参数传递方式。不过，这种传递方式已经成为历史）。 Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个副本。具体来讲，方法不能修改传递给它的任何参数变量的内容。 例如，考虑下面的调用： double percent &#x3D; 10; harry.raiseSalary(percent); 不论这个方法具体如何实现，我们知道，在这个方法调用之后，percent的值还是10。 下面再仔细研究一下这种情况。假定一个方法试图将一个参数值增加至3倍： public static void tripleValue(double x) &#x2F;&#x2F; doesn&#39;t work &#123; x &#x3D; 3 * x; &#125;","tags":[]},{"title":"静态字段与静态方法","text":"静态字段与静态方法静态字段 如果将一个字段定义为static，每个类只有一个这样的字段。而对于非静态的实例字段，每个对象都有自己的一个副本。例如，假设需要给每一个员工赋予唯一的标识码。这里给Employee类添加一个实例字段id和一个静态字段nextId： class Employee &#123; private static int nextId &#x3D; 1; private int id; &#125; 现在，每一个Employee对象都有一个自己的id字段，但这个类的所有实例将共享一个nextId字段。换句话说，如果有1000个Employee类对象，则有1000个实例字段id，分别对应每一个对象。但是，只有一个静态字段nextId。即使没有Employee对象，静态字段nextId也存在。它属于类，而不属于任何单个的对象。 程序示例public class HuangZiHanTest &#123; public static void main(String[] huangzihan_args) &#123; Huangzihan_Employee huangzihan &#x3D; new Huangzihan_Employee(1,2); System.out.println(huangzihan.huangzihan_nextId()); System.out.println(huangzihan.huangzihan_id()); System.out.println(); Huangzihan_Employee Huangzihan &#x3D; new Huangzihan_Employee(3,4); System.out.println(Huangzihan.huangzihan_nextId()); System.out.println(Huangzihan.huangzihan_id()); &#125; &#125; class Huangzihan_Employee &#123; private static int huangzihan_nextId &#x3D; 1; private int huangzihan_id; public Huangzihan_Employee(int huangzihan_n, int huangzihan_i) &#123; huangzihan_nextId &#x3D; huangzihan_n; huangzihan_id &#x3D; huangzihan_i; &#125; public int huangzihan_nextId() &#123; return huangzihan_nextId; &#125; public int huangzihan_id() &#123; return huangzihan_id; &#125; &#125; 运行结果1 2 3 4 注释类字段 在一些面向对象程序设计语言中，静态字段被称为类字段。术语“静态”只是沿用了C++的叫法，并无实际意义。 下面实现一个简单的方法： public void setId() &#123; id &#x3D; nextId; nextId++; &#125; &#96;&#96;&#96; &gt; 假定为**harry**设置员工标识码： &#96;&#96;&#96;C&#x2F;C++ harry.setId(); harry的id字段被设置为静态字段nextId当前的值，并且静态字段nextId的值加1： harry.id &#x3D; Employee.nextId; Employee.nextId++; 程序示例public class HuangZiHanTest &#123; public static void main(String[] huangzihan_args) &#123; Huangzihan_Employee huangzihan &#x3D; new Huangzihan_Employee(1,2); huangzihan.huangzihan_setId(1, 2); &#125; &#125; class Huangzihan_Employee &#123; private static int huangzihan_nextId &#x3D; 1; private int huangzihan_id; public Huangzihan_Employee(int huangzihan_n, int huangzihan_i) &#123; huangzihan_nextId &#x3D; huangzihan_n; huangzihan_id &#x3D; huangzihan_i; &#125; public void huangzihan_setId(int huangzihan_n, int huangzihan_i) &#123; huangzihan_id &#x3D; huangzihan_nextId; huangzihan_nextId++; System.out.println(huangzihan_nextId); &#125; &#125; 运行结果2 静态常量 静态变量使用得比较少，但静态常量却很常用。例如，在Math类中定义一个静态常量： public class Math &#123; . . . public static final double PI &#x3D; 3.14159265358979323846; . . . &#125; 在程序中，可以用Math.PI来访问这个常量。 如果省略关键字static，PI就变成了Math类的一个实例字段。也就是说，需要通过Math类的一个对象来访问PI，并且每一个Math对象都有它自己的一个PI副本。 你已经多次使用的另一个静态常量是System.out。它在System类中声明如下： public class System &#123; . . . public static final PrintStream out &#x3D; . . .; . . . &#125; 前面曾经多次提到过，由于每个类对象都可以修改公共字段，所以，最好不要有公共字段。然而，公共常量（即final字段）却没问题。因为out被声明为final，所以，不允许再将它重新赋值为另一个打印流： System.out &#x3D; new PrintStream(...); &#x2F;&#x2F;ERROR--out is final 注释 如果查看System类，就会发现有一个setOut方法可以将System.out设置为不同的流。你可能会感到奇怪，为什么这个方法可以修改final变量的值。原因在于，setOut方法是一个原生方法，而不是在Java语言中实现的。原生方法可以绕过Java语言的访问控制机制。这是一种特殊的解决方法，你自己编写程序时不要模仿这种做法。 静态方法 静态方法是不在对象上执行的方法。例如，Math类的pow方法就是一个静态方法。表达式 Math.pow(x, a) 会计算幂x^3。在完成运算时，它并不使用任何Math对象。换句话说，它没有隐式参数。 可以认为静态方法是没有this参数的方法（在一个非静态的方法中，this参数指示这个方法的隐式参数）。 Employee类的静态方法不能访问id实例字段，因为它不能在对象上执行操作。但是，静态方法可以访问静态字段。下面是这样一个静态方法的示例： public static int getNextId() &#123; return nextId; &#x2F;&#x2F;returns static field &#125; 可以提供类名来调用这个方法： int n &#x3D; Employee.getNextId(); 这个方法可以省略关键字static吗？答案是肯定的。但是，这样一来，你就需要通过Employee类对象的引用来调用这个方法。 程序示例public class HuangZiHanTest &#123; public static void main(String[] huangzihan_args) &#123; int x &#x3D; 2; double a &#x3D; Math.pow(x, 3); System.out.println(a); Huangzihan_Employee huangzihan &#x3D; new Huangzihan_Employee(); int huangzihan_n &#x3D; huangzihan.huangzihan_getNextId(); System.out.println(huangzihan_n); &#125; &#125; class Huangzihan_Employee &#123; private static int huangzihan_nextId &#x3D; 3; public static int huangzihan_getNextId() &#123; return huangzihan_nextId; &#125; &#125; 运行结果8.0 3 注释 可以使用对象调用静态方法，这是合法的。例如，如果harry是一个Employee对象，可以用harry.getNextId()代替Employee.getNextId()。不过，这种写法很容易造成混淆，其原因是getNextId方法计算的结果与harry毫无关系。我们建议使用类名而不是对象来调用静态方法。 两种情况下可以使用静态方法 在下面两种情况下可以使用静态方法： 方法不需要访问对象状态，因为它需要的所有参数都通过显式参数提供（例如：Math.pow）。 方法只需要访问类的静态字段（例如：Employee.getNextId）。 工厂方法 静态方法还有另外一种常见的用途。类似LocalDate和NumberFormat的类使用静态工厂方法（factory method）来构造对象。你已经见过工厂方法LocalDate.now和LocalDate.of。NumberFormat类如下生成不同风格的格式化对象： NumberFormat currencyFormatter &#x3D; NumberFormat.getCurrencyInstance(); NumberFormat percentFormatter &#x3D; NumberFormat.getPercentInstance(); double x &#x3D; 0.1; System.out.println(currencyFormatter.format(x)); &#x2F;&#x2F; prints $0.10 System.out.println(percentFormatter.format(x)); &#x2F;&#x2F; prints 10% NumberFormat类不利用构造器的两个原因 为什么NumberFormat类不利用构造器完成这些操作呢？这主要有两个原因： 无法命名构造器。构造器的名字必须与类名相同。但是，这里希望有两个不同的名字，分别得到货币实例和百分比实例。 使用构造器时，无法改变所构造对象的类型。而工厂方法实际上将返回DecimalFormat类的对象，这是NumberFormat的一个子类。 程序示例import java.text.NumberFormat; public class HuangZiHanTest &#123; public static void main(String[] huangzihan_args) &#123; NumberFormat currencyFormatter &#x3D; NumberFormat.getCurrencyInstance(); NumberFormat percentFormatter &#x3D; NumberFormat.getPercentInstance(); double x &#x3D; 0.1; System.out.println(currencyFormatter.format(x)); System.out.println(percentFormatter.format(x)); &#125; &#125; 运行结果¥0.10 10% main方法 需要注意，可以调用静态方法而不需要任何对象。例如，不需要构造Math类的任何对象就可以调用Math.pow。 同理，main方法也是一个静态方法。 public class Application &#123; public static void main(String[] args) &#123; &#x2F;&#x2F; construct objects here . . . &#125; &#125; main方法不对任何对象进行操作。事实上，在启动程序时还没有任何对象。静态的main方法将执行并构造程序所需要的对象。 提示 每一个类可以有一个main方法。这是常用于对类进行单元测试的一个技巧。例如，可以在Employee类中添加一个main方法： class Employee &#123; public Employee(String n, double s, int year, int month, int day) &#123; name &#x3D; n; salary &#x3D; s; hireDay &#x3D; LocalDate.of(year, month, day); &#125; . . . public static void main(String[] args) &#x2F;&#x2F; unit test &#123; var e &#x3D; new Employee(&quot;Romeo&quot;, 50000, 2003, 3, 31); e.raiseSalary(10); System.out.println(e.getName() + &quot; &quot; + e.getSalary()); &#125; . . . &#125; 如果想要独立地测试Employee类，只需要执行 java Employee 如果Employee类是一个更大型应用程序的一部分，就可以使用下面这条语句运行程序 java Application Employee类的main方法永远不会执行。 下面中的程序包含了Employee类的一个简单版本，其中有一个静态字段nextId和一个静态方法getNextId。这里将三个Employee对象填入一个数组，然后打印员工信息。最后，打印出下一个可用的员工标识码来展示静态方法。 需要注意，Employee类也有一个静态的main方法用于单元测试。试试运行 java Employee 和 java StaticTest 执行两个main方法。 程序示例&#x2F;* * 功能： * @版本：1.02 * @时间：2021-07-16 * @作者：黄子涵 * *&#x2F; public class HuangZiHanTest &#123; public static void main(String[] huangzihan_args) &#123; var huangzihan &#x3D; new Huangzihan_Employee[4]; huangzihan[0] &#x3D; new Huangzihan_Employee(&quot;huangzihan&quot;, 40000); huangzihan[1] &#x3D; new Huangzihan_Employee(&quot;Huangzihan&quot;, 60000); huangzihan[2] &#x3D; new Huangzihan_Employee(&quot;huang_zihan&quot;, 80000); huangzihan[3] &#x3D; new Huangzihan_Employee(&quot;Huang_zihan&quot;, 100000); for(Huangzihan_Employee Huangzihan : huangzihan) &#123; Huangzihan.huangzihan_setId(); System.out.println(&quot;名字&#x3D;&quot; + Huangzihan.huangzihan_getName() + &quot;,ID&#x3D;&quot; + Huangzihan.huangzihan_getId() + &quot;,工资&#x3D;&quot; + Huangzihan.huangzihan_getSalary()); &#125; int huangzihan_n &#x3D; Huangzihan_Employee.huangzihan_getNextId(); System.out.println(&quot;下一个有效的ID&#x3D;&quot; + huangzihan_n); &#125; &#125; class Huangzihan_Employee &#123; private static int huangzihan_nextId &#x3D; 1; private String huangzihan_name; private double huangzihan_salary; private int huangzihan_id; public Huangzihan_Employee(String huangzihan_n, double huangzihan_s) &#123; huangzihan_name &#x3D; huangzihan_n; huangzihan_salary &#x3D; huangzihan_s; huangzihan_id &#x3D; 0; &#125; public String huangzihan_getName() &#123; return huangzihan_name; &#125; public double huangzihan_getSalary() &#123; return huangzihan_salary; &#125; public int huangzihan_getId() &#123; return huangzihan_id; &#125; public void huangzihan_setId() &#123; huangzihan_id &#x3D; huangzihan_nextId; huangzihan_nextId++; &#125; public static int huangzihan_getNextId() &#123; return huangzihan_nextId; &#125; public static void main(String[] huangzihan_args) &#123; var huangzihan_e &#x3D; new Huangzihan_Employee(&quot;黄子涵&quot;, 50000); System.out.println(huangzihan_e.huangzihan_getName() + &quot;&quot; + huangzihan_e.huangzihan_getSalary());; &#125; &#125; 运行结果名字&#x3D;huangzihan,ID&#x3D;1,工资&#x3D;40000.0 名字&#x3D;Huangzihan,ID&#x3D;2,工资&#x3D;60000.0 名字&#x3D;huang_zihan,ID&#x3D;3,工资&#x3D;80000.0 名字&#x3D;Huang_zihan,ID&#x3D;4,工资&#x3D;100000.0 下一个有效的ID&#x3D;5","path":"2021/07/16/静态字段与静态方法/","date":"07-16","excerpt":"静态字段与静态方法静态字段 如果将一个字段定义为static，每个类只有一个这样的字段。而对于非静态的实例字段，每个对象都有自己的一个副本。例如，假设需要给每一个员工赋予唯一的标识码。这里给Employee类添加一个实例字段id和一个静态字段nextId： class Employee &#123; private static int nextId &#x3D; 1; private int id; &#125; 现在，每一个Employee对象都有一个自己的id字段，但这个类的所有实例将共享一个nextId字段。换句话说，如果有1000个Employee类对象，则有1000个实例字段id，分别对应每一个对象。但是，只有一个静态字段nextId。即使没有Employee对象，静态字段nextId也存在。它属于类，而不属于任何单个的对象。 程序示例public class HuangZiHanTest &#123; public static void main(String[] huangzihan_args) &#123; Huangzihan_Employee huangzihan &#x3D; new Huangzihan_Employee(1,2); System.out.println(huangzihan.huangzihan_nextId()); System.out.println(huangzihan.huangzihan_id()); System.out.println(); Huangzihan_Employee Huangzihan &#x3D; new Huangzihan_Employee(3,4); System.out.println(Huangzihan.huangzihan_nextId()); System.out.println(Huangzihan.huangzihan_id()); &#125; &#125; class Huangzihan_Employee &#123; private static int huangzihan_nextId &#x3D; 1; private int huangzihan_id; public Huangzihan_Employee(int huangzihan_n, int huangzihan_i) &#123; huangzihan_nextId &#x3D; huangzihan_n; huangzihan_id &#x3D; huangzihan_i; &#125; public int huangzihan_nextId() &#123; return huangzihan_nextId; &#125; public int huangzihan_id() &#123; return huangzihan_id; &#125; &#125;","tags":[]},{"title":"用户自定义类","text":"用户自定义类 简单的类只包含一个简单的main方法。现在来学习如何编写复杂应用程序所需要的那种主力类（workhorse class）。通常，这些类没有main方法，却有自己的实例字段和实例方法。要想构建一个完整的程序，会结合使用多个类，其中只有一个类有main方法。 Employee类 在Java中，最简单的类定义形式为： class ClassName &#123; field1 field2 . . . constructor1 constructor2 . . . method1 method2 &#125; 下面看一个非常简单的Employee类。在编写工资管理系统时可能会用到。 class Employee &#123; &#x2F;&#x2F; instance fields private String name; private double salary; private LocalDate hireDay; &#x2F;&#x2F; constructor public Employee(String n, double s, int year, int month, int day) &#123; name &#x3D; n; salary &#x3D; s; hireDay &#x3D; LocalDate.of(year, month, day); &#125; &#x2F;&#x2F; a method public String getName() &#123; return name; &#125; &#x2F;&#x2F; more methods . . . &#125; 在这个程序中，我们构造了一个Employee数组，并填入了3个Employee对象： Employee[] staff &#x3D; new Employee[3]; staff[0] &#x3D; new Employee(&quot;Carl Cracker&quot;, . . .); staff[1] &#x3D; new Employee(&quot;Harry Hacker&quot;, . . .); staff[2] &#x3D; new Employee(&quot;Tony Tester&quot;, . . .); 接下来，使用Employee类的raiseSalary方法将每个员工的薪水提高5%： for(Employee e : staff) e.raiseSalary(5); &#96;&#96;&#96; &gt; 最后，调用**getName**方法、**getSalary**方法和**getHireDay**方法打印各个员工的信息： &#96;&#96;&#96;C&#x2F;C++ for(Employee e : staff) System.out.println(&quot;name&#x3D;&quot; + e.getName() +&quot;,salary&#x3D;&quot; + e.getSalary() +&quot;,hireDay&#x3D;&quot; + e.getHireDay()); 注意，在这个示例程序中包含两个类：Employee类和带有public访问修饰符的EmployeeTest类。EmployeeTest类包含了main方法，其中使用了前面介绍的指令。 源文件名是EmployeeTest.java，这是因为文件名必须与public类的名字相匹配。在一个源文件中，只能有一个公共类，但可以有任意数目的非公共类。 接下来，当编译这段源代码的时候，编译器将在目录下创建两个类文件：EmployeeTest.class和Employee.class。 将程序中包含main方法的类名提供给字节码解释器，以启动这个程序： java EmployeeTest 字节码解释器开始运行EmployeeTest类的main方法中的代码。在这段代码中，先后构造了3个新Employee对象，并显示它们的状态。 程序示例import java.time.LocalDate; &#x2F;* * 功能：这个程序测试这个Huangzihan_Employee类 * @版本：1.13 * @时间：2018-04-10 * @作者：黄子涵 * *&#x2F; public class HuangZiHanTest &#123; public static void main(String[] huangzihan_args) &#123; Huangzihan_Employee[] huangzihan_staff &#x3D; new Huangzihan_Employee[4]; huangzihan_staff[0] &#x3D; new Huangzihan_Employee(&quot;huangzihan&quot;, 75000, 1987, 12, 15); huangzihan_staff[1] &#x3D; new Huangzihan_Employee(&quot;Huangzihan&quot;, 50000, 1989, 10, 1); huangzihan_staff[2] &#x3D; new Huangzihan_Employee(&quot;huang_zihan&quot;, 40000, 1990, 3, 15); huangzihan_staff[3] &#x3D; new Huangzihan_Employee(&quot;Huang_zihan&quot;, 30000, 1996, 7, 10); for(Huangzihan_Employee huangzihan_e : huangzihan_staff) &#123; huangzihan_e.huangzihan_raiseSalary(5); &#125; for(Huangzihan_Employee huangzihan_e : huangzihan_staff) &#123; System.out.println(&quot;名字&#x3D;&quot;+huangzihan_e.huangzihan_getName()+&quot;,工资&#x3D;&quot;+huangzihan_e.huangzihan_getSalary()+&quot;,雇佣天数&#x3D;&quot; + huangzihan_e.getHireDay()); &#125; &#125; &#125; class Huangzihan_Employee &#123; &#x2F;&#x2F; instance fields private String huangzihan_name; private double huangzihan_salary; private LocalDate huangzihan_hireDay; &#x2F;&#x2F; constructor public Huangzihan_Employee(String huangzihan_n, double huangzihan_s, int huangzihan_year, int huangzihan_month, int huangzihan_day) &#123; huangzihan_name &#x3D; huangzihan_n; huangzihan_salary &#x3D; huangzihan_s; huangzihan_hireDay &#x3D; LocalDate.of(huangzihan_year, huangzihan_month, huangzihan_day); &#125; &#x2F;&#x2F; a method public String huangzihan_getName() &#123; return huangzihan_name; &#125; public double huangzihan_getSalary() &#123; return huangzihan_salary; &#125; public LocalDate getHireDay() &#123; return huangzihan_hireDay; &#125; public void huangzihan_raiseSalary(double huangzihan_byPercent) &#123; double huangzihan_raise &#x3D; huangzihan_salary * huangzihan_byPercent &#x2F; 100; huangzihan_salary +&#x3D; huangzihan_raise; &#125; &#125; 运行结果名字&#x3D;huangzihan,工资&#x3D;78750.0,雇佣天数&#x3D;1987-12-15 名字&#x3D;Huangzihan,工资&#x3D;52500.0,雇佣天数&#x3D;1989-10-01 名字&#x3D;huang_zihan,工资&#x3D;42000.0,雇佣天数&#x3D;1990-03-15 名字&#x3D;Huang_zihan,工资&#x3D;31500.0,雇佣天数&#x3D;1996-07-10 多个源文件的使用 许多程序员习惯于将每一个类存放在一个单独的源文件中。例如，将Employee类存放在文件Employee.java中，将EmployeeTest类存放在文件EmployeeTest.java中。 两种编译源程序的方法使用通配符调用Java编译器 如果喜欢这样组织文件，可以有两种编译源程序的方法。一种是使用通配符调用Java编译器： javac Employee*.java 键入命令 这样一来，所有与通配符匹配的源文件都将被编译成类文件。或者键入以下命令： javac EmployeeTest.java 你可能会感到惊讶，使用第二种方式时并没有显式地编译Employee.java。不过，当Java编译器发现EmployeeTest.java使用了Employee类时，它会查找名为Employee.class的文件。如果没有找到这个文件，就会自动地搜索Employee.java，然后，对它进行编译。更重要的是：如果Employee.java版本较已有的Employee.class文件版本更新，Java编译器就会自动地重新编译这个文件。 注释 如果熟悉UNIX的make工具（或者是Windows中的nmake等工具），可以认为Java编译器内置了make功能。 剖析Employee类 首先从这个类的方法开始。通过查看源代码会发现，这个类包含一个构造器和4个方法： public Employee(String n, double s, int year, int month, int day) public String getName() public double getSalary() public LocalDate getHireDay() public void raiseSalary(double byPercent) public 这个类的所有方法都被标记为public。关键字public意味着任何类的任何方法都可以调用这些方法（共有4种访问级别）。 接下来，需要注意在Employee类的实例中有3个实例字段用来存放将要操作的数据： private String name; private double salary; private LocalDate hireDay; private 关键字private确保只有Employee类自身的方法能够访问这些实例字段，而其他类的方法不能够读写这些字段。 注释 可以用public标记实例字段，但这是一种很不好的做法。public数据字段允许程序中的任何方法对其进行读取和修改，这就完全破坏了封装。任何类的任何方法都可以修改public字段，从我们的经验来看，有些代码将利用这种存取权限，而这是我们最不希望看到的。因此，这里强烈建议将实例字段标记为private。 最后，请注意，有两个实例字段本身就是对象：name字段是String类对象，hireDay字段是LocalDate类对象。这种情况十分常见：类包含的实例字段通常属于某个类类型。 程序示例一public class HuangZiHanTest &#123; public static void main(String[] huangzihan_args) &#123; String huangzihan_name&#x3D;&quot;黄子涵是帅哥！&quot;; System.out.println(huangzihan_name); Huangzihan_Employee huangzihan &#x3D; new Huangzihan_Employee(); System.out.println(huangzihan.huangzihan_getName1()); &#125; &#125; class Huangzihan_Employee &#123; private String huangzihan_name&#x3D;&quot;黄子涵&quot;; public String huangzihan_getName1() &#123; return huangzihan_name; &#125; &#125; 运行结果一黄子涵是帅哥！ 黄子涵 程序示例二public class HuangZiHanTest &#123; public static void main(String[] huangzihan_args) &#123; System.out.println(huangzihan_name); &#125; &#125; class Huangzihan_Employee &#123; private String huangzihan_name&#x3D;&quot;黄子涵&quot;; public String huangzihan_getName1() &#123; return huangzihan_name; &#125; &#125; 运行结果二Exception in thread &quot;main&quot; java.lang.Error: Unresolved compilation problem: huangzihan_name cannot be resolved to a variable at HuangZiHanTest.main(HuangZiHanTest.java:5) 从构造器开始 下面先看看Employee类的构造器： public Employee(String n, double s, int year, int month, int day) &#123; name &#x3D; n; salary &#x3D; s; hireDay &#x3D; LocalDate.of(year, month, day); &#125; 构造器与类同名 可以看到，构造器与类同名。在构造Employee类的对象时，构造器会运行，从而将实例字段初始化为所希望的初始状态。 例如，当使用下面这条代码创建Employee类的实例时： new Employee(&quot;James Bond&quot;, 100000, 1950, 1, 1) 将会把实例字段设置为： name &#x3D; &quot;James Bond&quot;; salary &#x3D; 100000; hireDay &#x3D; LocalDate.of(1950, 1, 1); &#x2F;&#x2F;January 1, 1950 构造器结合new运算符来调用 构造器与其他方法有一个重要的不同。构造器总是结合new运算符来调用。不能对一个已经存在的对象调用构造器来达到重新设置实例字段的目的。例如， james.Employee(&quot;James Bond&quot;, 250000, 1950, 1, 1) &#x2F;&#x2F;ERROR 将产生编译错误。 有关构造器的内容 现在只需要记住： 构造器与类同名。 每个类可以有一个以上的构造器。 构造器可以有0个、1个或多个参数。 构造器没有返回值。 构造器总是伴随着new操作符一起调用。 警告 请注意，不要在构造器中定义与实例字段同名的局部变量。例如，下面的构造器将不会设置salary。 public Employee(String n, double s, . . .) &#123; String name &#x3D; n; &#x2F;&#x2F; ERROR double salary &#x3D; s; &#x2F;&#x2F; ERROR . . . &#125; 这个构造器声明了局部变量name和salary。这些变量只能在构造器内部访问。这些变量会遮蔽（shadow）同名的实例字段。有些程序员偶尔会不假思索地写出这类代码，因为他们的手指会不自觉地增加数据类型。这种错误很难检查出来，因此，必须注意在所有的方法中都不要使用与实例字段同名的变量。 用var声明局部变量 在Java 10中，如果可以从变量的初始值推导出它们的类型，那么可以用var关键字声明局部变量，而无须指定类型。例如，可以不这样声明： Employee harry &#x3D; new Employee(&quot;Harry Hacker&quot;, 50000, 1989, 18, 1); 只需要写以下代码： var harry &#x3D; new Employee(&quot;Harry Hacker&quot;, 50000, 1989, 10, 1); 这一点很好，因为这样可以避免重复写类型名Employee。 从现在开始，倘若无须了解任何Java API就能从等号右边明显看出类型，在这种情况下我们都将使用var表示法。不过我们不会对数值类型使用var，如int、long或double，使你不用当心0、0L和0.0之间的区别。对Java API有了更多使用经验后，你可能会希望更多地使用var关键字。 注意var关键字只能用于方法中的局部变量。参数和字段的类型必须声明。 程序示例public class HuangZiHanTest &#123; public static void main(String[] huangzihan_args) &#123; var huangzihan &#x3D; new Huangzihan_Employee[1]; huangzihan[0] &#x3D; new Huangzihan_Employee(&quot;黄子涵&quot;,123); for(Huangzihan_Employee a1 : huangzihan) &#123; System.out.println(&quot;使用var变量：&quot;+a1.get_name()+a1.get_number()); &#125; System.out.println(); Huangzihan_Employee[] Huangzihan &#x3D; new Huangzihan_Employee[1]; Huangzihan[0] &#x3D; new Huangzihan_Employee(&quot;黄子涵&quot;,123); for(Huangzihan_Employee a2 : huangzihan) &#123; System.out.println(&quot;不使用var变量：&quot;+a2.get_name()+a2.get_number()); &#125; &#125; &#125; class Huangzihan_Employee &#123; private String huangzihan_name; private int huangzihan_number; public Huangzihan_Employee(String huangzihan_s, int huangzihan_n) &#123; huangzihan_name &#x3D; huangzihan_s; huangzihan_number &#x3D; huangzihan_n; &#125; public String get_name() &#123; return huangzihan_name; &#125; public int get_number() &#123; return huangzihan_number; &#125; &#125; 运行结果使用var变量：黄子涵123 不使用var变量：黄子涵123 使用null引用 一个对象变量包含一个对象的引用，或者包含一个特殊值null，后者表示没有引用任何对象。 听上去这是一种处理特殊情况的便捷机制，如未知的名字或雇用日期。不过使用null值时要非常小心。 NullPointerException异常 如果对null值应用一个方法，会产生一个NullPointerException异常。 LocalDate birthday &#x3D; null; String s &#x3D; birthday.toString(); &#x2F;&#x2F; NullPointerException 程序示例import java.time.LocalDate; public class HuangZiHanTest &#123; public static void main(String[] huangzihan_args) &#123; LocalDate birthday &#x3D; null; String s &#x3D; birthday.toString(); &#x2F;&#x2F; NullPointerException System.out.println(s); &#125; &#125; 运行结果Exception in thread &quot;main&quot; java.lang.NullPointerException: Cannot invoke &quot;java.time.LocalDate.toString()&quot; because &quot;birthday&quot; is null at HuangZiHanTest.main(HuangZiHanTest.java:8) 这是一个很严重的错误，类似于“索引越界”异常。如果你的程序没有“捕获”异常，程序就会终止。正常情况下，程序并不捕获这些异常，而是依赖于程序员从一开始就不要带来异常。 定义一个类时，最好清楚地知道哪些字段可能为null。在我们的例子中，我们不希望name或hireDay字段为null。（不用担心salary字段。这个字段是基本类型，所以不可能是null。） hireDay字段肯定是非null的，因为它初始化为一个新的LocalDate对象。但是name可能为null，如果调用构造器时为n提供的实参是null，name就会是null。 处理null值的两种解决方法处理null值的宽容型方法 对此有两种解决方法。“宽容型”方法是把null参数转换为一个适当的非null值： if(n &#x3D;&#x3D; null) name &#x3D; &quot;unknown&quot;; else name &#x3D; n; 在Java 9中，Objects类对此提供了一个便利方法： public Employee(String n, double s, int year, int month, int day) &#123; name &#x3D; Objects.requireNonNullElse(n, &quot;unknown&quot;); . . . &#125; 程序示例import java.util.Objects; public class HuangZiHanTest &#123; public static void main(String[] huangzihan_args) &#123; Huangzihan_Employee[] huangzihan &#x3D; new Huangzihan_Employee[1]; huangzihan[0] &#x3D; new Huangzihan_Employee(&quot;huangzihan&quot;,123); for(Huangzihan_Employee Huangzihan : huangzihan) &#123; System.out.println(Huangzihan.get_name()); System.out.println(Huangzihan.get_number()); &#125; &#125; &#125; class Huangzihan_Employee &#123; private Object huangzihan_name; private int huangzihan_number; public Huangzihan_Employee(String huangzihan_s, int huangzihan_n) &#123; huangzihan_number &#x3D; huangzihan_n; huangzihan_name &#x3D; Objects.requireNonNullElse(huangzihan_n, &quot;unknown&quot;); &#125; public Object get_name() &#123; return huangzihan_name; &#125; public int get_number() &#123; return huangzihan_number; &#125; &#125; 运行结果123 123 处理null值的严格型方法 “严格型”方法则是干脆拒绝null参数： public Employee(String n, double s, int year, int month, int day) &#123; Objects.requireNonNull(n, &quot;The name cannot be null&quot;); name &#x3D; n; . . . &#125; 程序示例import java.util.Objects; public class HuangZiHanTest &#123; public static void main(String[] huangzihan_args) &#123; Huangzihan_Employee[] huangzihan &#x3D; new Huangzihan_Employee[1]; huangzihan[0] &#x3D; new Huangzihan_Employee(&quot;huangzihan&quot;,123); for(Huangzihan_Employee Huangzihan : huangzihan) &#123; System.out.println(Huangzihan.get_name()); System.out.println(Huangzihan.get_number()); &#125; &#125; &#125; class Huangzihan_Employee &#123; private Object huangzihan_name; private int huangzihan_number; public Huangzihan_Employee(String huangzihan_s, int huangzihan_n) &#123; Objects.requireNonNull(huangzihan_n, &quot;黄子涵是帅哥！&quot;); huangzihan_name &#x3D; huangzihan_n; &#125; public Object get_name() &#123; return huangzihan_name; &#125; public int get_number() &#123; return huangzihan_number; &#125; &#125; 运行结果123 0 null名字构造对象 如果有人用一个null名字构造了一个Employee对象，就会产生NullPointerException异常。乍看上去这种做法好像不太有用。不过这种方法有两个好处： 1.异常报告会提供这个问题的描述。 2.异常报告会准确地指出问题所在的位置，否则NullPointerException异常可能在其他地方出现，而很难追踪到真正导致问题的这个构造器参数。 注释 如果要接受一个对象引用作为构造参数，就要问问自己：是不是真的希望接受可有可无的值。如果不是，那么“严格型”方法更合适。 隐式参数与显式参数（这里不太懂！！！） 方法用于操作对象以及存取它们的实例字段。例如，以下方法： public void raiseSalary(double byPercent) &#123; double raise &#x3D; salary * byPercent &#x2F; 100; salary +&#x3D; raise; &#125; 将调用这个方法的对象的salary实例字段设置为一个新值。考虑下面这个调用： number007.raiseSalary(5); 它的结果是将nunber007.salary字段的值增加5%。具体地说，这个调用将执行下列指令： double raise &#x3D; number007.salary * 5 &#x2F; 100; numbere007.salary +&#x3D; raise; raiseSalary方法有两个参数。第一个参数称为隐式（implicit）参数，是出现在方法名前的Employee类型的对象。第二个参数是位于方法名后面括号中的数值，这是一个显式（explicit）参数。（有人把隐式参数称为方法调用的目标或接收者。）可以看到，显式参数显式地列在方法声明中，例如double byPercent。隐式参数没有出现在方法声明中。 关键字this 在每一个方法中，关键字this指示隐式参数。如果喜欢的话，可以如下改写raiseSalary方法： public void raiseSalary(double byPercent) &#123; double raise &#x3D; this.salary * byPercent &#x2F; 100; this.salary +&#x3D; raise; &#125; 有些程序员更偏爱这样的风格，因为这样可以将实例字段与局部变量明显地区分开来。 封装的优点 最后再仔细看一下非常简单的getName方法、getSalary方法和getHireDay方法。 public String getName() &#123; return name; &#125; &#96;&#96;&#96; &#96;&#96;&#96;C&#x2F;C++ public double getSalary() &#123; return salary; &#125; &#96;&#96;&#96; &#96;&#96;&#96;C&#x2F;C++ public LocalDate getHireDay() &#123; return hireDay; &#125; 字段访问器 这些都是典型的访问器方法。由于它们只返回实例字段值，因此又称为字段访问器。 如果将name、salary和hireDay字段标记为公共，而不是编写单独的访问器方法，难道不是更容易一些吗？ 不过，name是一个只读字段。一旦在构造器中设置，就没有任何办法可以对它进行修改，这样我们可以确保name字段不会受到外界的破坏。 虽然salary不是只读字段，但是它只能用raiseSalary方法修改。特别是一旦这个值出现了错误，只需要调试这个方法就可以了。如果salary字段是公共的，破坏这个字段值的捣乱者有可能会出没在任何地方（那就很难调试了）。 获得或设置实例字段的值 有些时候，可能想要获得或设置实例字段的值。那么你需要提供下面三项内容： 一个私有的数据字段； 一个公共的字段访问器方法； 一个公共的字段更改器方法。 这样做要比提供一个简单的公共数据字段复杂些，但却有着下列明显的好处： 首先，可以改变内部实现，而除了该类的方法之外，这不会影响其他代码。例如，如果将存储名字的字段改为： String firstName; String lastName; 那么getName方法可以改为返回 firstName + &quot; &quot; + lastName 这个改变对于程序的其他部分是完全不可见的。 当然，为了进行新旧数据表示之间的转换，访问器方法和更改器方法可能需要做许多工作。但是，这将为我们带来第二点好处：更改器方法可以完成错误检查，而只对字段赋值的代码可能没有这个麻烦。例如，setSalary方法可以检查工资是否小于0。 程序示例public class HuangZiHanTest &#123; public static void main(String[] huangzihan_args) &#123; Huangzihan_Employee[] huangzihan &#x3D; new Huangzihan_Employee[1]; huangzihan[0] &#x3D; new Huangzihan_Employee(&quot;黄&quot;, &quot;子涵&quot;); for(Huangzihan_Employee Huangzihan : huangzihan) &#123; System.out.println(Huangzihan.get_name()); &#125; &#125; &#125; class Huangzihan_Employee &#123; private String huangzihan_firstname; private String huangzihan_lastname; public Huangzihan_Employee(String huangzihan_fn, String huangzihan_ln) &#123; huangzihan_firstname &#x3D; huangzihan_fn; huangzihan_lastname &#x3D; huangzihan_ln; &#125; public String get_name() &#123; return huangzihan_firstname+huangzihan_lastname; &#125; &#125; 运行结果黄子涵 警告 注意不要编写返回可变对象引用的访问器方法。下面的Employee类就违反了这个设计原则，其中的getHireDay方法返回了一个Date类对象： class Employee &#123; private Date hireDay; . . . public Date getHireDay() &#123; return hireDay; &#x2F;&#x2F; BAD &#125; . . . &#125; 更改器方法setTime LocalDate类没有更改器方法，与之不同，Date类有一个更改器方法setTime，可以在这里设置毫秒数。 Date对象是可变的，这一点就破坏了封装性！请看下面这段代码： Employee harry &#x3D; . . .; Date d &#x3D; harry.getHireDay(); double tenYearsInMilliSeconds &#x3D; 10 * 365.25 * 24 * 60 * 60 * 1000; d.setTime(d.getTime() -(long) tenYearsInMilliSeconds); &#x2F;&#x2F; let&#39;s give Harry ten years of added seniority 出错的原因很微妙。d和harry.hireDay引用同一个对象（请参见图（返回可变数据字段的引用））。对d调用更改器方法就可以自动地改变这个Employee对象的私有状态！ 返回可变数据字段的引用 程序示例import java.util.Date; public class HuangZiHanTest &#123; public static void main(String[] huangzihan_args) &#123; Huangzihan_Employee huangzihan &#x3D; new Huangzihan_Employee(null, 0, null); Date huangzihan_d &#x3D; huangzihan.get_day(); double tenYearsInMilliSecons &#x3D; 10*365.25*24*60*60*1000; huangzihan_d.setTime(huangzihan_d.getTime()-(long)tenYearsInMilliSecons); System.out.println(huangzihan); System.out.println(huangzihan_d); System.out.println(tenYearsInMilliSecons); &#125; &#125; class Huangzihan_Employee &#123; private Date huangzihan_day; private String huangzihan_name; private int huangzihan_salary; public Huangzihan_Employee(String huangzihan_n, int huangzihan_s, Date huangzihan_d) &#123; huangzihan_name &#x3D; huangzihan_n; huangzihan_salary &#x3D; huangzihan_s; huangzihan_day &#x3D; huangzihan_d; &#125; public Date get_day() &#123; return huangzihan_day; &#125; public String get_name() &#123; return huangzihan_name; &#125; public int get_salary() &#123; return huangzihan_salary; &#125; &#125; 运行结果Exception in thread &quot;main&quot; java.lang.NullPointerException: Cannot invoke &quot;java.util.Date.getTime()&quot; because &quot;huangzihan_d&quot; is null at HuangZiHanTest.main(HuangZiHanTest.java:10) 克隆（clone） 如果需要返回一个可变对象的引用，首先应该对它进行克隆（clone）。对象克隆是指存放在另一个新位置上的对象副本。下面是修改后的代码： class Employee &#123; . . . public Date getHireDay() &#123; return(Date) hireDay.clone(); &#x2F;&#x2F;OK &#125; &#125; &#96;&#96;&#96; &gt; 这里有一个经验，如果需要返回一个可变数据字段的副本，就应该使用**clone**。 ## 基于类的访问权限 &gt; 从前面已经知道，方法可以访问调用这个方法的对象的私有数据。一个方法可以访问**所属类的所有对象**的私有数据，这令很多人感到奇怪！例如，下面看一下用来比较两个员工的equals方法。 &#96;&#96;&#96;C&#x2F;C++ class Employee &#123; . . . public boolean equals(Employee other) &#123; return name.equals(other.name); &#125; &#125; 典型的调用方式是 if(harry.equals(boss)) . . . 这个方法访问harry的私有字段，这点并不会让人奇怪，不过，它还访问了boss的私有字段。这是合法的，其原因是boss是Employee类型的对象，而Employee类的方法可以访问任何Employee类型对象的私有字段。 程序示例public class HuangZiHanTest &#123; public static void main(String[] huangzihan_args) &#123; String huangzihan&#x3D;&quot;黄子涵&quot;; String Boss_huangzihan &#x3D;&quot;老板黄子涵&quot;; Huangzihan_Employee Huangzihan &#x3D; new Huangzihan_Employee(huangzihan); Huangzihan_Employee Boss_Huangzihan &#x3D; new Huangzihan_Employee(Boss_huangzihan); if(Huangzihan.equals(Boss_Huangzihan)) &#123; System.out.println(&quot;黄子涵是帅哥！！！&quot;); &#125; else &#123; System.out.println(&quot;黄子涵是帅哥！&quot;); &#125; &#125; &#125; class Huangzihan_Employee &#123; private String huangzihan_name; public Huangzihan_Employee(String huangzihan_n) &#123; huangzihan_name &#x3D; huangzihan_n; &#125; public boolean huangzihan_equals(Huangzihan_Employee other) &#123; return huangzihan_name.equals(huangzihan_name); &#125; &#125; 运行结果黄子涵是帅哥！ 私有方法 在实现一个类时，由于公共数据非常危险，所以应该将所有的数据字段都设置为私有的。然而，方法又应该如何设计呢？尽管绝大多数方法都被设计为公共的，但在某些特殊情况下，将方法设计为私有可能很有用。有时，你可能希望将一个计算代码分解成若干个独立的辅助方法。通常，这些辅助方法不应该成为公共接口的一部分，这是由于它们往往与当前实现关系非常紧密，或者需要一个特殊协议或者调用次序。最好将这样的方法设计为私有方法。 在Java中，要实现私有方法，只需将关键字public改为private即可。 通过将方法设计为私有，如果你改变了方法的实现方式，将没有义务保证这个方法依然可用。如果数据的表示发生了变化，这个方法可能会变得难以实现，或者不再需要；这并不重要。重点在于，只要方法是私有的，类的设计者就可以确信它不会在别处使用，所以可以将其删去。如果一个方法是公共的，就不能简单地将其删除，因为可能会有其他代码依赖这个方法。 final实例字段（这个不太懂！！！） 可以将实例字段定义为final。这样的字段必须在构造对象时初始化。也就是说，必须确保在每一个构造器执行之后，这个字段的值已经设置，并且以后不能再修改这个字段。例如，可以将Employee类中的name字段声明为final，因为在对象构造之后，这个值不会再改变，即没有setName方法。 class Employee &#123; private final String name; &#125; final修饰符对于类型为基本类型或者不可变类的字段尤其有用。（如果类中的所有方法都不会改变其对象，这样的类就是不可变的类。例如，String类就是不可变的。） 对于可变的类，使用final修饰符可能会造成混乱。例如，考虑以下字段： private final StringBuilder evaluations; 它在Employee构造器中初始化为 evaluations &#x3D; new StringBuilder(); final关键字只是表示存储在evaluations变量中的对象引用不会再指示另一个不同的StringBuilder对象。不过这个对象可以更改： public void giveGoldStar() &#123; evaluations.append(LocalDate.now() + &quot;：Gold star!\\n&quot;); &#125;","path":"2021/07/15/用户自定义类/","date":"07-15","excerpt":"用户自定义类 简单的类只包含一个简单的main方法。现在来学习如何编写复杂应用程序所需要的那种主力类（workhorse class）。通常，这些类没有main方法，却有自己的实例字段和实例方法。要想构建一个完整的程序，会结合使用多个类，其中只有一个类有main方法。 Employee类 在Java中，最简单的类定义形式为： class ClassName &#123; field1 field2 . . . constructor1 constructor2 . . . method1 method2 &#125; 下面看一个非常简单的Employee类。在编写工资管理系统时可能会用到。 class Employee &#123; &#x2F;&#x2F; instance fields private String name; private double salary; private LocalDate hireDay; &#x2F;&#x2F; constructor public Employee(String n, double s, int year, int month, int day) &#123; name &#x3D; n; salary &#x3D; s; hireDay &#x3D; LocalDate.of(year, month, day); &#125; &#x2F;&#x2F; a method public String getName() &#123; return name; &#125; &#x2F;&#x2F; more methods . . . &#125;","tags":[]},{"title":"使用预定义类","text":"使用预定义类 在Java中，没有类就无法做任何事情。然而，并不是所有的类都表现出面向对象的典型特征。例如，Math类，可以直接使用Math类的方法，如Math.random，而不必了解它具体是如何实现的，你只需要知道方法名和参数（如果有的话）。这正是封装的关键所在，当然所有类都是这样。但Math类只封装了功能，它不需要也不必隐藏数据。由于没有数据，因此也不必考虑创建对象和初始化它们的实例字段，因为根本没有实例字段！ 对象与对象变量构造器（constructor，或称构造函数） 要想使用对象，首先必须构造对象，并指定其初始状态。然后对对象应用方法。 在Java程序设计语言中，要使用构造器（constructor，或称构造函数）构造新实例。构造器是一种特殊的方法，用来构造并初始化对象。下面看一个例子。在标准Java库中包含一个Date类。它的对象可以描述一个时间点，例如，“December 31,1999,23:59:59 GMT”。 注释 你可能会感到奇怪：为什么用类描述时间，而不像其他语言那样用一个内置的（built-in）类型？例如，在Visual Basic中有一个内置的date类型，程序员可以采用#6/1/1995#的格式指定日期。从表面上看这似乎很方便，因为程序员只需要使用内置的date类型，而不必为设计类而操心。但实际上，Visual Basic这样设计的适应性如何呢？在有些地区，日期表示为月/日/年，而另一些地区则表示为日/月/年。语言设计者是否能够预见这些问题呢？如果没有处理好这类问题，语言就有可能陷入混乱，对此感到不满的程序员也会丧失使用这种语言的热情。如果使用类，这些设计任务就交给了类库的设计者。如果类设计得不完善，其他的程序员可以很容易地编写自己的类，以便增强或替代（replace）系统提供的类（作为印证：Java的日期类库开始时有些混乱，现在已经重新设计了两次）。 构造器的名字与类名相同 构造器的名字应该与类名相同。因此Date类的构造器名为Date。要想构造一个Date对象，需要在构造器前面加上new操作符，如下所示： new Date() 这个表达式构造了一个新对象。这个对象被初始化为当前的日期和时间。 如果需要的话，也可以将这个对象传递给一个方法： System.out.println(new Date()); 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; new Date(); &#125; &#125; 运行结果Exception in thread &quot;main&quot; java.lang.Error: Unresolved compilation problem: Date cannot be resolved to a type at HuangZiHanTest.main(HuangZiHanTest.java:7) 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; new HuangZiHanTest(); System.out.println(new HuangZiHanTest()); &#125; &#125; 运行结果HuangZiHanTest@24d46ca6 toString方法 或者，也可以对刚刚创建的对象应用一个方法。Date类中有一个toString方法。这个方法将返回日期的字符串描述。下面的语句可以说明如何对新构造的Date对象应用toString方法。 String s&#x3D;new Date().toString(); 对象变量 在这两个例子中，构造的对象仅使用了一次。通常，你会希望构造的对象可以多次使用，因此，需要将对象存放在一个变量中： Date birthday&#x3D;new Date(); 创建一个新对象 图（创建一个新对象）显示了对象变量birthday，它引用了新构造的对象。 创建一个新对象 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; new HuangZiHanTest(); System.out.println(new HuangZiHanTest()); System.out.println(); String huangzihan&#x3D;new HuangZiHanTest().toString(); System.out.println(huangzihan); System.out.println(); HuangZiHanTest Huangzihan&#x3D;new HuangZiHanTest(); System.out.println(Huangzihan); &#125; &#125; 运行结果HuangZiHanTest@24d46ca6 HuangZiHanTest@4517d9a3 HuangZiHanTest@372f7a8d 对象与对象变量 在对象与对象变量之间存在着一个重要的区别。例如，以下语句 Date deadline; &#x2F;&#x2F;deadline doesn&#39;t refer to any object 定义了一个对象变量deadline，它可以引用Date类型的对象。但是，一定要认识到：变量deadline不是一个对象，而且实际上它也没有引用任何对象。此时还不能在这个变量上使用任何Date方法。下面的语句 s &#x3D; deadline.toString(); &#x2F;&#x2F;not yet 将产生编译错误。 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; HuangZiHanTest shuai_ge; huangzihan &#x3D; shuai_ge.toString(); &#125; &#125; 运行结果Exception in thread &quot;main&quot; java.lang.Error: Unresolved compilation problem: huangzihan cannot be resolved to a variable at HuangZiHanTest.main(HuangZiHanTest.java:8) 必须首先初始化变量deadline，这里有两个选择。当然，可以初始化这个变量，让它引用一个新构造的对象： deadline &#x3D; new Date(); 也可以设置这个变量，让它引用一个已有的对象： deadline &#x3D; birthday; 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; HuangZiHanTest shuai_ge; HuangZiHanTest Huangzihan&#x3D;new HuangZiHanTest(); shuai_ge&#x3D;new HuangZiHanTest(); String huangzihan &#x3D; shuai_ge.toString(); System.out.println(huangzihan); System.out.println(); System.out.println(Huangzihan); &#125; &#125; 运行结果HuangZiHanTest@24d46ca6 HuangZiHanTest@4517d9a3 引用同一个对象的对象变量 现在，这两个变量都引用同一个对象（请参见图（引用同一个对象的对象变量））。 引用同一个对象的对象变量 要认识到重要的一点：对象变量并没有实际包含一个对象，它只是引用一个对象。 在Java中，任何对象变量的值都是对存储在另外一个地方的某个对象的引用。new操作符的返回值也是一个引用。下面的语句： Date deadline &#x3D; new Date(); 有两个部分。表达式new Date()构造了一个Date类型的对象，它的值是对新创建对象的一个引用。这个引用存储在变量deadline中。 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; HuangZiHanTest shuai_ge&#x3D;new HuangZiHanTest(); HuangZiHanTest huangzihan&#x3D;new HuangZiHanTest(); System.out.println(shuai_ge); System.out.println(huangzihan); &#125; &#125; 运行结果HuangZiHanTest@24d46ca6 HuangZiHanTest@4517d9a3 对象变量设置为null 可以显式地将对象变量设置为null，指示这个对象变量目前没有引用任何对象。 deadline &#x3D; null; . . . if(deadline !&#x3D; null) System.out.println(deadline); &#96;&#96;&#96; ##### 程序示例 &#96;&#96;&#96;C&#x2F;C++ public class HuangZiHanTest &#123; public static void main(String[] args) &#123; HuangZiHanTest shuai_ge&#x3D;new HuangZiHanTest(); HuangZiHanTest huangzihan&#x3D;new HuangZiHanTest(); System.out.println(shuai_ge); System.out.println(huangzihan); System.out.println(); shuai_ge&#x3D;null; huangzihan&#x3D;null; System.out.println(shuai_ge); System.out.println(huangzihan); System.out.println(); if(shuai_ge&#x3D;&#x3D;null) &#123; System.out.println(&quot;黄子涵是帅哥！&quot;); &#125; if(huangzihan&#x3D;&#x3D;null) &#123; System.out.println(&quot;黄子涵是帅哥！&quot;); &#125; &#125; &#125; 运行结果HuangZiHanTest@24d46ca6 HuangZiHanTest@4517d9a3 null null 黄子涵是帅哥！ 黄子涵是帅哥！ Java类库中的LocalDate类 在前面的例子中，已经使用了Java标准类库中的Date类。Date类的实例有一个状态，即特定的时间点。 纪元 尽管在使用Date类时不必知道这一点，但时间是用距离一个固定时间点的毫秒数（可正可负）表示的，这个时间点就是所谓的纪元（epoch），它是UTC时间1970年1月1日00:00:00。UTC就是Coordinated UniversalTime（国际协调时间），与大家熟悉的GMT（即Greenwich Mean Time，格林尼治时间）一样，是一种实用的科学标准时间。 但是，Date类对于处理人类记录日期的日历信息并不是很有用，如“December 31，1999”。这种特定的日期描述遵循了世界上大多数地区使用的Gregorian阳历。但是，同样的这个时间点采用中国或希伯来的阴历来描述就很不一样了，倘若我们有来自火星的顾客，基于他们使用的火星历来描述这个时间点就更不一样了。 类库设计者决定将保存时间与给时间点命名分开。所以标准Java类库分别包含了两个类：一个是用来表示时间点的Date类；另一个是用大家熟悉的日历表示法表示日期的LocalDate类。 将时间度量与日历分开是一种很好的面向对象设计。通常，最好使用不同的类表示不同的概念。 静态工厂方法（factory method） 不要使用构造器来构造LocalDate类的对象。实际上，应当使用静态工厂方法（factory method），它会代表你调用构造器。下面的表达式： LocalDate.now() 会构造一个新对象，表示构造这个对象时的日期。 可以提供年、月和日来构造对应一个特定日期的对象： LocalDate.of(1999,12,31) 当然，通常我们都希望将构造的对象保存在一个对象变量中： LocalDate newYearsEve &#x3D; LocalDate.of(1999,12,31); 一旦有了一个LocalDate对象，可以用方法getYear、getMonthValue和getDayOfMonth得到年、月和日： int year &#x3D; newYearsEve.getYear(); &#x2F;&#x2F;1999 int month &#x3D; newYearsEve.getMonthValue(); &#x2F;&#x2F;12 int day &#x3D; newYearsEve.getDayOfMonth(); &#x2F;&#x2F;31 看起来这似乎没有多大的意义，因为这正是构造对象时使用的那些值。不过，有时可能有一个计算得到的日期，然后你希望调用这些方法来了解它的更多信息。例如，plusDays方法会得到一个新的LocalDate，如果把应用这个方法的对象称为当前对象，这个新日期对象则是距当前对象指定天数的一个新日期： LocalDate aThousandDaysLater &#x3D; newYearsEve.plusDays(1000); year &#x3D; aThousandDaysLater.getYear(); &#x2F;&#x2F;2002 month &#x3D; aThousandDaysLater.getMonthValue(); &#x2F;&#x2F;09 day &#x3D; aThousandDaysLater.getDayOfMonth(); &#x2F;&#x2F;26 LocalDate类封装了实例字段来维护所设置的日期。如果不查看源代码，就不可能知道类内部的日期表示。当然，封装的意义就在于内部表示并不重要，重要的是类对外提供的方法。 程序示例import java.time.LocalDate; public class HuangZiHanTest &#123; public static void main(String[] args) &#123; LocalDate.now(); System.out.println(LocalDate.now()); System.out.println(); LocalDate.of(1949, 10, 01); System.out.println(LocalDate.of(1949, 10, 01)); System.out.println(); LocalDate huangzihan_NationalDay&#x3D;LocalDate.of(2021, 10, 01); System.out.println(huangzihan_NationalDay); System.out.println(); int huangzihan_year &#x3D; huangzihan_NationalDay.getYear(); int huangzihan_month &#x3D; huangzihan_NationalDay.getMonthValue(); int huangzihan_day &#x3D; huangzihan_NationalDay.getDayOfMonth(); System.out.println(huangzihan_year); System.out.println(huangzihan_month); System.out.println(huangzihan_day); System.out.println(); LocalDate aThousandDaysLater &#x3D; huangzihan_NationalDay.plusDays(1000); int Huangzihan_year &#x3D; aThousandDaysLater.getYear(); int Huangzihan_month &#x3D; aThousandDaysLater.getMonthValue(); int Huangzihan_day &#x3D; aThousandDaysLater.getDayOfMonth(); System.out.println(Huangzihan_year); System.out.println(Huangzihan_month); System.out.println(Huangzihan_day); System.out.println(); &#125; &#125; 运行结果2021-07-05 1949-10-01 2021-10-01 2021 10 1 2024 6 27 注释 实际上，Date类也有得到日、月、年的方法，分别是getDay、getMonth以及getYear，不过这些方法已经废弃。当类库设计者意识到某个方法最初就不该引入时，就把它标记为废弃，不鼓励使用。 类库设计者意识到应当单独提供类来处理日历，不过在此之前这些方法已经是Date类的一部分了。Java 1.1中引入较早的一组日历类时，Date方法被标为废弃不用。虽然仍然可以在程序中使用这些方法，不过如果这样做，编译时会出现警告。最好还是不要使用这些废弃的方法，因为将来的某个类库版本很有可能会将它们完全删除。 提示 JDK提供了jdeprscan工具来检查你的代码中是否使用了Java API已经废弃的特性。有关说明参见https://docs.oracle.com/javase/9/tools/jdeprscan.htm。 更改器方法与访问器方法 再来看上一节中的plusDays方法调用： LocalDate aThousandDaysLater &#x3D; newYearsEve.plusDays(1000); 这个调用之后newYearsEve会有什么变化？它会改为1000天之后的日期吗？事实上，并没有。plusDays方法会生成一个新的LocalDate对象，然后把这个新对象赋给aThousandDaysLater变量。原来的对象不做任何改动。我们说plusDays方法没有更改调用这个方法的对象。（这类似于String类的toUpperCase方法。在一个字符串上调用toUpperCase时，这个字符串仍保持不变，会返回一个将字符大写的新字符串。） 程序示例import java.time.LocalDate; public class HuangZiHanTest &#123; public static void main(String[] args) &#123; LocalDate.now(); System.out.println(LocalDate.now()); System.out.println(); LocalDate.of(1949, 10, 01); System.out.println(LocalDate.of(1949, 10, 01)); System.out.println(); LocalDate huangzihan_NationalDay&#x3D;LocalDate.of(2021, 10, 01); System.out.println(huangzihan_NationalDay); System.out.println(); int huangzihan_year &#x3D; huangzihan_NationalDay.getYear(); int huangzihan_month &#x3D; huangzihan_NationalDay.getMonthValue(); int huangzihan_day &#x3D; huangzihan_NationalDay.getDayOfMonth(); System.out.println(huangzihan_year); System.out.println(huangzihan_month); System.out.println(huangzihan_day); System.out.println(); LocalDate aThousandDaysLater &#x3D; huangzihan_NationalDay.plusDays(1000); int Huangzihan_year &#x3D; aThousandDaysLater.getYear(); int Huangzihan_month &#x3D; aThousandDaysLater.getMonthValue(); int Huangzihan_day &#x3D; aThousandDaysLater.getDayOfMonth(); System.out.println(Huangzihan_year); System.out.println(Huangzihan_month); System.out.println(Huangzihan_day); System.out.println(huangzihan_NationalDay); System.out.println(aThousandDaysLater); System.out.println(); &#125; &#125; 运行结果2021-07-05 1949-10-01 2021-10-01 2021 10 1 2024 6 27 2021-10-01 2024-06-27 GregorianCalendar Java库的一个较早版本曾经有另一个处理日历的类，名为GregorianCalendar。可以如下为这个类表示的一个日期增加1000天： GregorianCalendar someDay &#x3D; new GregorianCalendar(1999,11,31); &#x2F;&#x2F;odd feature of that class:month numbers go from 0 to 11 someDay.add(Calendar.DAY_OF_MONTH,1000); 与LocalDate.plusDays方法不同，GregorianCalendar.add方法是一个更改器方法（mutator method）。调用这个方法后，someDay对象的状态会改变。可以如下查看新状态： year &#x3D; someDay.get(Calendar.YEAR); &#x2F;&#x2F;2002 month &#x3D; someDay.get(Calendar.MONTH)+1; &#x2F;&#x2F;09 day &#x3D; someDay.get(Calendar.DAY_OF_MONTH); &#x2F;&#x2F;26 正是因为这个原因，我们将变量命名为someDay而不是newYearsEve——调用这个更改器方法之后，它不再是新年前夜。 程序示例import java.util.Calendar; import java.util.GregorianCalendar; public class HuangZiHanTest &#123; public static void main(String[] args) &#123; GregorianCalendar huangzihanDay &#x3D; new GregorianCalendar(2021,07,05); huangzihanDay.add(Calendar.DAY_OF_MONTH,1000); int huangzihan_year &#x3D; huangzihanDay.get(Calendar.YEAR); int huangzihan_month &#x3D; huangzihanDay.get(Calendar.MONTH)+1; int huangzihan_day &#x3D; huangzihanDay.get(Calendar.DAY_OF_MONTH); System.out.println(huangzihan_year); System.out.println(huangzihan_month); System.out.println(huangzihan_day); &#125; &#125; 运行结果2024 5 1 访问器方法（accessor method） 相反，只访问对象而不修改对象的方法有时称为访问器方法（accessor method）。例如，LocalDate.getYear和GregorianCalendar.get就是访问器方法。 下面用一个应用LocalDate类的程序来结束本节内容的介绍。这个程序将显示当前月的日历，其格式为： Mon Tue Wed Thu Fri Sat Sun 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26* 27 28 29 30 当前日期用一个*号标记。可以看到，这个程序需要知道如何计算某月份的天数以及一个给定日期相应是星期几。 下面看一下这个程序的关键步骤。首先构造一个对象，并用当前的日期初始化。 LocalDate date&#x3D;LocalDate.now(); 下面获得当前的月份和日期。 int month &#x3D; date. getMonthValue(); int today &#x3D; date.getDayOfMonth(); 然后，将date设置为这个月的第一天，并得到这一天为星期几。 date &#x3D; date.minusDays(today - 1); &#x2F;&#x2F;set to start of month DayOfWeek weekday &#x3D; date.getDayOfweek(); int value &#x3D; weekday.getValue(); &#x2F;&#x2F; 1 &#x3D; Monday, . . ., 7 &#x3D; Sunday 变量weekday设置为DayOfWeek类型的对象。我们调用这个对象的getValue方法来得到星期几的一个数值。这会得到一个整数，这里遵循国际惯例，即周末是一周的末尾，星期一就返回1，星期二返回2，依此类推。星期日则返回7。 注意，日历的第一行是缩进的，这样可使月份的第一天指向相应的星期几。下面的代码会打印表头和第一行的缩进： 访问器方法程序示例一 现在我们来打印日历的主体。进入一个循环，其中date遍历一个月中的每一天。 每次迭代时，打印日期值。如果date是当前日期，这个日期则用一个 标记。接下来，把*date推进到下一天。如果到达新的一周的第一天，则换行打印： while(date.getMonthValue() &#x3D;&#x3D; month) &#123; System.out.printf(&quot;%3d&quot;,date.getDayOfMonth()); if(date.getDayOfMonth() &#x3D;&#x3D; today) System.out.print(“*&quot;); else System.out.print(&quot; &quot;); date &#x3D; date.plusDays(1); if(date.getDayOfWeek().getValue() &#x3D;&#x3D; 1)System.out.println(); &#125; 什么时候结束呢？我们不知道这个月有几天，是31天、30天、29天还是28天。实际上，只要date还在当月就要继续迭代。 可以看到，利用LocalDate类可以编写一个日历程序，能处理星期几以及各月天数不同等复杂问题。你并不需要知道LocalDate类如何计算月和星期几。只需要使用这个类的接口，如plusDays和getDayOfWeek等方法。。 程序示例 访问器方法程序示例二 运行结果huangzihanDate&#x3D;2021-07-14（当前日期） huangzihanDate&#x3D;2021-07-01（当前日期本月的第一天） huangzihanMonth&#x3D;7（当前日期的月份） huangzihanToday&#x3D;14（当前日期的号数） huangzihanWeekDay&#x3D;THURSDAY（当前日期的星期） huangzihanValue&#x3D;4（当前日期的星期值） Mon Tue Wed Thu Fri Sat Sun 1 2 3 4 5 6 7 8 9 10 11 12 13 14* 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31","path":"2021/07/14/使用预定义类/","date":"07-14","excerpt":"使用预定义类 在Java中，没有类就无法做任何事情。然而，并不是所有的类都表现出面向对象的典型特征。例如，Math类，可以直接使用Math类的方法，如Math.random，而不必了解它具体是如何实现的，你只需要知道方法名和参数（如果有的话）。这正是封装的关键所在，当然所有类都是这样。但Math类只封装了功能，它不需要也不必隐藏数据。由于没有数据，因此也不必考虑创建对象和初始化它们的实例字段，因为根本没有实例字段！ 对象与对象变量构造器（constructor，或称构造函数） 要想使用对象，首先必须构造对象，并指定其初始状态。然后对对象应用方法。 在Java程序设计语言中，要使用构造器（constructor，或称构造函数）构造新实例。构造器是一种特殊的方法，用来构造并初始化对象。下面看一个例子。在标准Java库中包含一个Date类。它的对象可以描述一个时间点，例如，“December 31,1999,23:59:59 GMT”。 注释 你可能会感到奇怪：为什么用类描述时间，而不像其他语言那样用一个内置的（built-in）类型？例如，在Visual Basic中有一个内置的date类型，程序员可以采用#6/1/1995#的格式指定日期。从表面上看这似乎很方便，因为程序员只需要使用内置的date类型，而不必为设计类而操心。但实际上，Visual Basic这样设计的适应性如何呢？在有些地区，日期表示为月/日/年，而另一些地区则表示为日/月/年。语言设计者是否能够预见这些问题呢？如果没有处理好这类问题，语言就有可能陷入混乱，对此感到不满的程序员也会丧失使用这种语言的热情。如果使用类，这些设计任务就交给了类库的设计者。如果类设计得不完善，其他的程序员可以很容易地编写自己的类，以便增强或替代（replace）系统提供的类（作为印证：Java的日期类库开始时有些混乱，现在已经重新设计了两次）。 构造器的名字与类名相同 构造器的名字应该与类名相同。因此Date类的构造器名为Date。要想构造一个Date对象，需要在构造器前面加上new操作符，如下所示： new Date() 这个表达式构造了一个新对象。这个对象被初始化为当前的日期和时间。 如果需要的话，也可以将这个对象传递给一个方法： System.out.println(new Date());","tags":[]},{"title":"数组","text":"数组 数组存储相同类型值的序列。 声明数组下标（index，或称索引） 数组是一种数据结构，用来存储同一类型值的集合。通过一个整型下标（index，或称索引）可以访问数组中的每一个值。例如，如果 a 是一个整型数组，a[i]就是数组中下标为 i 的整数。 在声明数组变量时，需要指出数组类型（数据元素类型紧跟[]）和数组变量的名字。下面声明了整型数组 a ： int[] a; 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; int[] huangzihan_a; int[] huangzihan_b; int[] huangzihan_c; &#125; &#125; 运行结果 创建数组 不过，这条语句只声明了变量 a ，并没有将 a 初始化为一个真正的数组。应该使用 new 操作符创建数组。 int[] a &#x3D; new int[100]; &#x2F;&#x2F;or var a &#x3D; new int[100]; 这条语句声明并初始化了一个可以存储100个整数的数组。 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; int[] huangzihan_a &#x3D; new int[0]; int[] huangzihan_b &#x3D; new int[5]; int[] huangzihan_c &#x3D; new int[10]; System.out.println(huangzihan_a); System.out.println(huangzihan_b); System.out.println(huangzihan_c); &#125; &#125; 运行结果[I@24d46ca6 [I@4517d9a3 [I@372f7a8d 数组长度 数组长度不要求是常量：new int[n]会创建一个长度为 n 的数组。 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; int[] huangzihan_a &#x3D; new int[0]; int[] huangzihan_b &#x3D; new int[5]; int[] huangzihan_c &#x3D; new int[10]; System.out.println(huangzihan_a.length); System.out.println(huangzihan_b.length); System.out.println(huangzihan_c.length); &#125; &#125; 运行结果0 5 10 数组列表（array list） 一旦创建了数组，就不能再改变它的长度（不过，当然可以改变单个的数组元素）。如果程序运行中需要经常扩展数组的大小，就应该使用另一种数据结构——数组列表（array list）。 注释 可以使用下面两种形式定义一个数组变量： int[] a; 或 int a[]; 大多数Java应用程序员喜欢使用第一种风格，因为它可以将类型int[]（整型数组）与变量名清晰地分开。 初始化数组对象 在Java中，提供了一种创建数组对象并同时提供初始值的简写形式。下面是一个例子： int[] smallPrimes &#x3D; &#123;2, 3, 5, 7, 11, 13&#125;; 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; int[] huangzihan_a &#x3D; &#123;&#125;; int[] huangzihan_b &#x3D; &#123;1, 2, 3, 4, 5&#125;; int[] huangzihan_c &#x3D; &#123;10, 11, 12, 13, 14, 15, 16, 17, 18, 19&#125;; System.out.println(huangzihan_a); System.out.println(); System.out.println(huangzihan_b[0]); System.out.println(huangzihan_b[1]); System.out.println(huangzihan_b[2]); System.out.println(huangzihan_b[3]); System.out.println(huangzihan_b[4]); System.out.println(); System.out.println(huangzihan_c[0]); System.out.println(huangzihan_c[1]); System.out.println(huangzihan_c[2]); System.out.println(huangzihan_c[3]); System.out.println(huangzihan_c[4]); System.out.println(huangzihan_c[5]); System.out.println(huangzihan_c[6]); System.out.println(huangzihan_c[7]); System.out.println(huangzihan_c[8]); System.out.println(huangzihan_c[9]); &#125; &#125; 运行结果[I@24d46ca6 1 2 3 4 5 10 11 12 13 14 15 16 17 18 19 请注意，这个语法中不需要使用new，甚至不用指定长度。 数组增加值 最后一个值后面允许有逗号，如果你要不断为数组增加值，这会很方便： String[] authors &#x3D; &#123; &quot;James Gosling&quot;, &quot;Bil1 Joy&quot;, &quot;Guy Steele&quot;, &#x2F;&#x2F; add more names here and put a comma after each name &#125;; 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; String[] huangzihan_authors &#x3D; &#123; &quot;Huangzihan&quot;, &quot;Huang_zihan&quot;, &quot;HuangZihan&quot;, &quot;Huang_Zihan&quot;, &quot;huangzihan&quot;, &quot;huang_zihan&quot;, &#125;; System.out.println(huangzihan_authors[0]); System.out.println(huangzihan_authors[1]); System.out.println(huangzihan_authors[2]); System.out.println(huangzihan_authors[3]); System.out.println(huangzihan_authors[4]); System.out.println(huangzihan_authors[5]); &#125; &#125; 运行结果Huangzihan Huang_zihan HuangZihan Huang_Zihan huangzihan huang_zihan 匿名数组 还可以声明一个匿名数组： new int[] &#123; 17, 19, 23, 29, 31, 37 &#125; 这会分配一个新数组并填入大括号中提供的值。它会统计初始值个数，并相应地设置数组大小。可以使用这种语法重新初始化一个数组而无须创建新变量。例如： smallPrimes &#x3D; new int[] &#123; 17, 19, 23, 29, 31, 37&#125;; 这是下列语句的简写形式： int[] anonymous &#x3D; &#123; 17, 19, 23, 29, 31, 37 &#125;; smallPrimes &#x3D; anonymous; 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; int[] huangzihan_a &#x3D; new int[] &#123;17, 19, 23, 29, 31, 37&#125;; int[] huangzihan_b &#x3D; huangzihan_a; System.out.println(huangzihan_a[0]); System.out.println(huangzihan_a[1]); System.out.println(huangzihan_a[2]); System.out.println(huangzihan_a[3]); System.out.println(huangzihan_a[4]); System.out.println(); System.out.println(huangzihan_b[0]); System.out.println(huangzihan_b[1]); System.out.println(huangzihan_b[2]); System.out.println(huangzihan_b[3]); System.out.println(huangzihan_b[4]); &#125; &#125; 运行结果17 19 23 29 31 17 19 23 29 31 注释 在Java中，允许有长度为0的数组。在编写一个结果为数组的方法时，如果碰巧结果为空，这样一个长度为0的数组就很有用。可以如下创建长度为0的数组： new elementType[0] 或 new elementType[] &#123;&#125; 注意，长度为0的数组与null并不相同。 访问数组元素 前面的数组元素的下标为从0 ~ 99（不是1 ~ 100）。一旦创建了数组，就可以在数组中填入元素。例如，使用一个循环： 访问数组元素程序示例一 程序示例 访问数组元素程序示例二 运行结果0 1 2 3 4 boolean数组与null 创建一个数字数组时，所有元素都初始化为0。 boolean 数组的元素会初始化为 false 。对象数组的元素则初始化为一个特殊值 null ，表示这些元素（还）未存放任何对象。初学者对此可能有些不解。例如， String[] names &#x3D; new String[10]; 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; String[] huangzihan_a &#x3D; new String[5]; boolean[] huangzihan_b &#x3D; new boolean[5]; System.out.println(huangzihan_a[0]); System.out.println(huangzihan_a[1]); System.out.println(huangzihan_a[2]); System.out.println(huangzihan_a[3]); System.out.println(huangzihan_a[4]); System.out.println(); System.out.println(huangzihan_b[0]); System.out.println(huangzihan_b[1]); System.out.println(huangzihan_b[2]); System.out.println(huangzihan_b[3]); System.out.println(huangzihan_b[4]); &#125; &#125; 运行结果null null null null null false false false false false 会创建一个包含10个字符串的数组，所有字符串都为 null 。如果希望这个数组包含空串，必须为元素指定空串： boolean数组与null程序示例一 程序示例 boolean数组与null程序示例二 运行结果 警告 如果创建了一个100个元素的数组，并且试图访问元素a[100]（或在0 ~ 99之外的任何下标），就会引发“array index out of bounds”异常。 要想获得数组中的元素个数，可以使用 array.length 。例如， 警告程序示例一 程序示例 警告程序示例二 运行结果null Exception in thread &quot;main&quot; java.lang.ArrayIndexOutOfBoundsException: Index 5 out of bounds for length 5 at HuangZiHanTest.main(HuangZiHanTest.java:11) for each循环 Java有一种功能很强的循环结构，可以用来依次处理数组（或者其他元素集合）中的每个元素，而不必考虑指定下标值。 这种增强的 for 循环的语句格式为： for(variable:collection) statement 它定义一个变量用于暂存集合中的每一个元素，并执行相应的语句（当然，也可以是语句块）。collection 这一集合表达式必须是一个数组或者是一个实现了 Iterable 接口的类对象（例如 ArrayList ）。 例如， for(int element:a) System.out.println(element); 打印数组 a 的每一个元素，一个元素占一行。 这个循环应该读作“循环a中的每一个元素”（for each element ina）。Java语言的设计者认为应该使用诸如 foreach 、 in 这样的关键字，但这种循环语句并不是最初就包含在Java语言中的，而是后来添加进去的，而且没有人希望破坏已经包含同名（例如 Systen.in ）方法或变量的旧代码。 当然，使用传统的 for 循环也可以获得同样的效果： for each循环程序示例一 但是，for each循环语句显得更加简洁、更不易出错，因为你不必为下标的起始值和终止值而操心。 程序示例 for each循环程序示例二 运行结果1 2 3 4 5 1 2 3 4 5 注释 for each 循环语句的循环变量将会遍历数组中的每个元素，而不是下标值。 如果需要处理一个集合中的所有元素，for each 循环语句相对于传统循环语句所做的改进很让人欣喜。然而，在很多情况下还是需要使用传统的 for 循环。例如，如果不希望遍历整个集合，或者在循环内部需要使用下标值时。 提示 有一个更加简单的方式可以打印数组中的所有值，即利用 Arrays 类的 toString 方法。调用 Arrays.toString(a) ，返回一个包含数组元素的字符串，这些元素包围在中括号内，并用逗号分隔，例如，”[2,3,5,7,11,13]”。要想打印数组，只需要调用 System.out.println(Arrays.toString(a)); 程序示例import java.util.Arrays; public class HuangZiHanTest &#123; public static void main(String[] args) &#123; int[] huangzihan_int &#x3D; &#123;11, 12, 13, 14, 15&#125;; double[] huangzihan_double &#x3D; &#123;1.0, 2.0, 3.0, 4.0, 5.0&#125;; char[] huangzihan_char &#x3D; &#123;&#39;黄&#39;,&#39;子&#39;,&#39;涵&#39;,&#39;是&#39;,&#39;帅&#39;,&#39;哥&#39;,&#39;！&#39;&#125;; boolean[] huangzihan_boolean &#x3D; &#123;true,false&#125;; byte[] huangzihan_byte &#x3D; &#123;1, 2, 3, 4, 5&#125;; System.out.println(Arrays.toString(huangzihan_int)); System.out.println(Arrays.toString(huangzihan_double)); System.out.println(Arrays.toString(huangzihan_char)); System.out.println(Arrays.toString(huangzihan_boolean)); System.out.println(Arrays.toString(huangzihan_byte)); &#125; &#125; 运行结果[11, 12, 13, 14, 15] [1.0, 2.0, 3.0, 4.0, 5.0] [黄, 子, 涵, 是, 帅, 哥, ！] [true, false] [1, 2, 3, 4, 5] 数组拷贝 在Java中，允许将一个数组变量拷贝到另一个数组变量。这时，两个变量将引用同一个数组： int[] luckyNumbers &#x3D; smallPrimes; luckyNumbers[5] &#x3D; 12; &#x2F;&#x2F;now smallPrimes[5] is also 12 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; int[] huangzihan_smallPrimes &#x3D; new int[6]; int[] huangzihan_luckyNumbers &#x3D; huangzihan_smallPrimes; huangzihan_luckyNumbers[5] &#x3D; 12; System.out.println(huangzihan_luckyNumbers[5]); System.out.println(huangzihan_smallPrimes[5]); &#125; &#125; 运行结果12 12 copyOf方法 图（拷贝一个数组变量）显示了拷贝的结果。如果希望将一个数组的所有值拷贝到一个新的数组中去，就要使用 Arrays 类的 copyOf 方法： 拷贝一个数组变量 int[] copiedLuckyNumbers &#x3D; Arrays.copyOf(LuckyNumbers,LuckyNumbers.length); 第2个参数是新数组的长度。这个方法通常用来增加数组的大小： luckyNumbers &#x3D; Arrays.copyOf(luckyNumbers,2*luckyNumbers.length); 如果数组元素是数值型，那么额外的元素将被赋值为0；如果数组元素是布尔型，则将赋值为 false 。相反，如果长度小于原始数组的长度，则只拷贝前面的值。 程序示例import java.util.Arrays; public class HuangZiHanTest &#123; public static void main(String[] args) &#123; System.out.println(&quot;第一部分测试开始！&quot;); int[] huangzihan_smallPrimes_int &#x3D; &#123;1, 2, 3, 4, 5, 6&#125;; System.out.println(&quot;huangzihan_smallPrimes_int[]&#x3D;&quot;+Arrays.toString(huangzihan_smallPrimes_int)); int[] huangzihan_luckyNumbers_int &#x3D; huangzihan_smallPrimes_int; System.out.println(&quot;huangzihan_luckyNumbers_int[5]&#x3D;&quot;+huangzihan_luckyNumbers_int[5]); System.out.println(&quot;huangzihan_smallPrimes_int[5]&#x3D;&quot;+huangzihan_smallPrimes_int[5]); huangzihan_luckyNumbers_int[5] &#x3D; 12; System.out.println(&quot;&quot;); System.out.println(&quot;huangzihan_smallPrimes_int[5]&#x3D;&quot;+huangzihan_smallPrimes_int[5]); System.out.println(&quot;huangzihan_luckyNumbers_int[5]&#x3D;&quot;+huangzihan_luckyNumbers_int[5]); System.out.println(&quot;第一部分测试结束！&quot;); System.out.println(&quot;&quot;); System.out.println(&quot;第二部分测试开始！&quot;); char[] huangzihan_smallPrimes_char &#x3D; &#123;&#39;黄&#39;,&#39;子&#39;,&#39;涵&#39;,&#39;是&#39;,&#39;帅&#39;,&#39;哥&#39;,&#39;！&#39;&#125;; System.out.println(&quot;huangzihan_smallPrimes_char[]&#x3D;&quot;+Arrays.toString(huangzihan_smallPrimes_char)); char[] huangzihan_luckyNumbers_char &#x3D; huangzihan_smallPrimes_char; System.out.println(&quot;huangzihan_smallPrimes_char[5]&#x3D;&quot;+huangzihan_smallPrimes_char[5]); System.out.println(&quot;huangzihan_luckyNumbers_char[5]&#x3D;&quot;+huangzihan_luckyNumbers_char[5]); huangzihan_luckyNumbers_char[5] &#x3D; &#39;黄&#39;; System.out.println(&quot;&quot;); System.out.println(&quot;huangzihan_luckyNumbers_char[5]&#x3D;&quot;+huangzihan_luckyNumbers_char[5]); System.out.println(&quot;huangzihan_smallPrimes_char[5]&#x3D;&quot;+huangzihan_smallPrimes_char[5]); System.out.println(&quot;第二部分测试结束！&quot;); System.out.println(&quot;&quot;); System.out.println(&quot;第三部分测试开始！&quot;); boolean[] huangzihan_smallPrimes_boolean &#x3D; &#123;true, false, true, false, true, false&#125;; System.out.println(&quot;huangzihan_smallPrimes_boolean[]&#x3D;&quot;+Arrays.toString(huangzihan_smallPrimes_boolean)); System.out.println(&quot;&quot;); boolean[] huangzihan_luckyNumbers_boolean &#x3D; huangzihan_smallPrimes_boolean; System.out.println(&quot;huangzihan_luckyNumbers_boolean[5]&#x3D;&quot;+huangzihan_luckyNumbers_boolean[5]); System.out.println(&quot;huangzihan_smallPrimes_boolean[5]&#x3D;&quot;+huangzihan_smallPrimes_boolean[5]); System.out.println(&quot;&quot;); huangzihan_luckyNumbers_boolean[5] &#x3D; true; System.out.println(&quot;huangzihan_smallPrimes_boolean[5]&#x3D;&quot;+huangzihan_smallPrimes_boolean[5]); System.out.println(&quot;huangzihan_luckyNumbers_boolean[5]&#x3D;&quot;+huangzihan_luckyNumbers_boolean[5]); System.out.println(&quot;第三部分测试结束！&quot;); System.out.println(&quot;&quot;); System.out.println(&quot;第四部分测试开始！&quot;); int[] huangzihan_int &#x3D; Arrays.copyOf(huangzihan_luckyNumbers_int, huangzihan_luckyNumbers_int.length); char[] huangzihan_char &#x3D; Arrays.copyOf(huangzihan_luckyNumbers_char, huangzihan_luckyNumbers_char.length); boolean[] huangzihan_boolean &#x3D; Arrays.copyOf(huangzihan_luckyNumbers_boolean, huangzihan_luckyNumbers_boolean.length); System.out.println(&quot;huangzihan_int[5]&#x3D;&quot;+huangzihan_int[5]); System.out.println(&quot;huangzihan_char[5]&#x3D;&quot;+huangzihan_char[5]); System.out.println(&quot;huangzihan_boolean[5]&#x3D;&quot;+huangzihan_boolean[5]); System.out.println(&quot;第四部分测试结束！&quot;); System.out.println(&quot;&quot;); System.out.println(&quot;第五部分测试开始！&quot;); huangzihan_luckyNumbers_int &#x3D; Arrays.copyOf(huangzihan_luckyNumbers_int, 2*huangzihan_luckyNumbers_int.length); huangzihan_luckyNumbers_char &#x3D; Arrays.copyOf(huangzihan_luckyNumbers_char, 2*huangzihan_luckyNumbers_char.length); huangzihan_luckyNumbers_boolean &#x3D; Arrays.copyOf(huangzihan_luckyNumbers_boolean, 2*huangzihan_luckyNumbers_boolean.length); System.out.println(&quot;huangzihan_luckyNumbers_int[5]&#x3D;&quot;+huangzihan_luckyNumbers_int[5]); System.out.println(&quot;huangzihan_luckyNumbers_char[5]&#x3D;&quot;+huangzihan_luckyNumbers_char[5]); System.out.println(&quot;huangzihan_luckyNumbers_boolean[5]&#x3D;&quot;+huangzihan_luckyNumbers_boolean[5]); System.out.println(&quot;&quot;); System.out.println(&quot;huangzihan_luckyNumbers_int[10]&#x3D;&quot;+huangzihan_luckyNumbers_int[10]); System.out.println(&quot;huangzihan_luckyNumbers_char[10]&#x3D;&quot;+huangzihan_luckyNumbers_char[10]); System.out.println(&quot;huangzihan_luckyNumbers_boolean[10]&#x3D;&quot;+huangzihan_luckyNumbers_boolean[10]); System.out.println(&quot;第五部分测试结束！&quot;); System.out.println(&quot;&quot;); System.out.println(&quot;第六部分测试开始！&quot;); int[] Huangzihan_int &#x3D; &#123;1, 2, 3, 4, 5, 6&#125;; System.out.println(&quot;Huangzihan_int[]&#x3D;&quot;+Arrays.toString(Huangzihan_int)); int[] Huangzihan_copyOf_int &#x3D; Arrays.copyOf(Huangzihan_int, 3); System.out.println(&quot;Huangzihan_copyOf_int[]&#x3D;&quot;+Arrays.toString(Huangzihan_copyOf_int)); System.out.println(&quot;&quot;); char[] Huangzihan_char &#x3D; &#123;&#39;黄&#39;,&#39;子&#39;,&#39;涵&#39;,&#39;是&#39;,&#39;帅&#39;,&#39;哥&#39;,&#39;！&#39;&#125;; System.out.println(&quot;Huangzihan_char[]&#x3D;&quot;+Arrays.toString(Huangzihan_char)); char[] Huangzihan_copyOf_char &#x3D; Arrays.copyOf(Huangzihan_char, 3); System.out.println(&quot;Huangzihan_copyOf_char[]&#x3D;&quot;+Arrays.toString(Huangzihan_copyOf_char)); System.out.println(&quot;&quot;); boolean[] Huangzihan_boolean &#x3D; &#123;true, false, true, false, true, false&#125;; System.out.println(&quot;Huangzihan_boolean[]&#x3D;&quot;+Arrays.toString(Huangzihan_boolean)); boolean[] Huangzihan_copyOf_boolean &#x3D; Arrays.copyOf(Huangzihan_boolean, 3); System.out.println(&quot;Huangzihan_copyOf_boolean[]&#x3D;&quot;+Arrays.toString(Huangzihan_copyOf_boolean)); System.out.println(&quot;第六部分测试结束！&quot;); System.out.println(&quot;&quot;); &#125; &#125; 运行结果第一部分测试开始！ huangzihan_smallPrimes_int[]&#x3D;[1, 2, 3, 4, 5, 6] huangzihan_luckyNumbers_int[5]&#x3D;6 huangzihan_smallPrimes_int[5]&#x3D;6 huangzihan_smallPrimes_int[5]&#x3D;12 huangzihan_luckyNumbers_int[5]&#x3D;12 第一部分测试结束！ 第二部分测试开始！ huangzihan_smallPrimes_char[]&#x3D;[黄, 子, 涵, 是, 帅, 哥, ！] huangzihan_smallPrimes_char[5]&#x3D;哥 huangzihan_luckyNumbers_char[5]&#x3D;哥 huangzihan_luckyNumbers_char[5]&#x3D;黄 huangzihan_smallPrimes_char[5]&#x3D;黄 第二部分测试结束！ 第三部分测试开始！ huangzihan_smallPrimes_boolean[]&#x3D;[true, false, true, false, true, false] huangzihan_luckyNumbers_boolean[5]&#x3D;false huangzihan_smallPrimes_boolean[5]&#x3D;false huangzihan_smallPrimes_boolean[5]&#x3D;true huangzihan_luckyNumbers_boolean[5]&#x3D;true 第三部分测试结束！ 第四部分测试开始！ huangzihan_int[5]&#x3D;12 huangzihan_char[5]&#x3D;黄 huangzihan_boolean[5]&#x3D;true 第四部分测试结束！ 第五部分测试开始！ huangzihan_luckyNumbers_int[5]&#x3D;12 huangzihan_luckyNumbers_char[5]&#x3D;黄 huangzihan_luckyNumbers_boolean[5]&#x3D;true huangzihan_luckyNumbers_int[10]&#x3D;0 huangzihan_luckyNumbers_char[10]&#x3D; 命令行参数Stringarg[]参数 前面已经看到一个Java数组重复出现过很多次。每一个Java应用程序都有一个带 Stringarg[]参数的 main方法。这个参数表明main方法将接收一个字符串数组，也就是命令行上指定的参数。 例如，来看下面这个程序： Stringarg[]参数程序示例一 如果使用下面这种形式调用这个程序： java Message -g cruel world args 数组将包含以下内容： args[0]: &quot;-g&quot; args[1]：&quot;cruel&quot; args[2]：&quot;world&quot; 这个程序会显示下面这个消息： Goodbye,cruel world！ 程序示例 Stringarg[]参数程序示例二 运行结果Hello,! 数组排序sort方法 要想对数值型数组进行排序，可以使用 Arrays 类中的 sort 方法： int[] a &#x3D; new int[10000]; . . . Arrays.sort(a) 这个方法使用了优化的快速排序（QuickSort）算法。快速排序算法对于大多数数据集合来说都是效率比较高的。 程序清单3-7中的程序具体使用了数组，它产生一个抽彩游戏中的随机数字组合。假如抽彩是从49个数字中抽取6个，那么程序可能的输出结果为： Bet the following combination.It&#39;ll make you rich！ 4 7 8 19 30 44 要想选择这样一个随机的数字集合，就要首先将值 1,2,…,n 存入数组 numbers 中： sort方法程序示例二 而用第二个数组存放抽取出来的数： int[] result &#x3D; new int[k]; 现在，就可以开始抽取 k 个数了。Math.random 方法将返回一个 0 到 1 之间（包含0、不包含1）的随机浮点数。用 n 乘以这个浮点数，就可以得到从 0 到 n-1 之间的一个随机数。 int r &#x3D;(int)(Math.random() * n); 下面将 result 的第 i 个元素设置为numbers[r]存放的数值，最初是 r+1 。但正如所看到的，numbers 数组的内容在每一次抽取之后都会发生变化。 result[i] &#x3D; numbers[r]; 现在，必须确保不会再次抽取到那个数，因为所有抽彩的数必须不相同。因此，这里用数组中的最后一个数覆盖number[r]，并将 n 减 1 。 numbers[r] &#x3D; numbers[n - 1]; n--; 关键在于每次抽取的都是下标，而不是实际的值。下标指向数组中包含尚未抽取过的值。 在抽取了 k 个数之后，可以对result数组进行排序，这样可以让输出效果更好： Arrays.sort(result); for(int r : result) System.out.println(r); 程序示例运行结果你需要画多少个数字？ 5 huangzihan_k&#x3D;5 你能画5个数字 你能画最高的数字是多少？ 10 huangzihan_n&#x3D;10 你能画最高的数字是10 huangzihan_numbers.length&#x3D;10 第1次循环 1 第2次循环 2 第3次循环 3 第4次循环 4 第5次循环 5 第6次循环 6 第7次循环 7 第8次循环 8 第9次循环 9 第10次循环 10 huangzihan_numbers[]&#x3D;[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] huangzihan_result.length&#x3D;5 第1次循环 10 10 9 9 第2次循环 9 9 8 8 第3次循环 2 8 1 7 第4次循环 7 7 6 6 第5次循环 1 6 0 5 huangzihan_result[]&#x3D;[10, 9, 2, 7, 1] 快速排序之后：[1, 2, 7, 9, 10] 127910 多维数组 多维数组将使用多个下标访问数组元素，它适用于表示表格或更加复杂的排列形式。假设需要建立一个数值表格，用来显示在不同利率下投资10000美元会增长多少，利息每年兑现并复投（见表（不同利率下的投资增长情况））。 不同利率下的投资增长情况 10% 11% 12% 13% 14% 15% 10 000.00 10 000.00 10 000.00 10 000.00 10 000.00 10 000.00 11 000.00 11 100.00 11 200.00 11 300.00 11 400.00 11 500.00 12 100.00 12 321.00 12 544.00 12 769.00 12 996.00 13 225.00 13 310.00 13 676.31 14 049.28 14 428.97 14 815.44 15 208.75 14 641.00 15 180.70 15 735.19 16 304.74 16 889.60 17 490.06 16 105.10 16 850.58 17 623.42 18 424.35 19 254.15 20 113.57 17 715.61 18 704.15 19 738.23 20 819.52 21 949.73 23 130.61 19 487.17 20 761.60 22 106.81 23 526.05 25 022.69 26 600.20 21 435.89 23 045.38 24 759.63 26 584.44 28 525.86 30 590.23 23 579.48 25 580.37 27 730.79 30 040.42 32 519.49 35 178.76 可以使用一个二维数组（也称为矩阵）来存储这些信息。这个数组被命名为balances。 声明二维数组 在Java中，声明一个二维数组相当简单。例如： double[][] balances; 程序示例public class HuangZiHanTest &#123; public static void main(String[] huangzihan_args) &#123; double[][] balances; &#125; &#125; 运行结果 初始化二维数组 对数组进行初始化之前是不能使用的。在这里可以如下初始化： balances &#x3D; new double[NYEARS][NRATES]; 另外，如果知道数组元素，就可以不调用new，而直接使用简写形式对多维数组进行初始化。例如： int[][] magicSquare &#x3D; &#123; &#123;16, 3, 2, 13&#125;, &#123;5, 10, 11, 8&#125;, &#123;9, 6, 7, 12&#125;, &#123;4, 15, 14, 1&#125; &#125;; 一旦数组初始化，就可以利用两个中括号访问各个元素，例如，balances[i][j]。 在示例程序中用到了一个存储利率的一维数组interest与一个存储余额的二维数组balances，一维用于表示年，另一维表示利率，使用初始余额来初始化这个数组的第一行： 初始化二维数组程序示例一 然后计算其他行，如下所示： 初始化二维数组程序示例二 程序示例 初始化二维数组程序示例三 运行结果huangzihan_balances[][]&#x3D;[[0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]] huangzihan_magicSquare[][]&#x3D;[[16, 3, 2, 13], [5, 10, 11, 8], [9, 6, 7, 12], [4, 15, 14, 1]] [[10000.0, 10000.0, 10000.0, 10000.0, 10000.0, 10000.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]] 注释 for each循环语句不能自动处理二维数组的每一个元素。它会循环处理行，而这些行本身就是一维数组。要想访问二维数组 a 的所有元素，需要使用两个嵌套的循环，如下所示： for (double[] row : a) for (double value : row) do something with value &#96;&#96;&#96; ## 提示 &gt; 要想快速地打印一个二维数组的数据元素列表，可以调用： &#96;&#96;&#96;C&#x2F;C++ System.out.println(Arrays.deepToString(a)); 输出格式为： [[16, 3, 2, 13], [5, 10, 11, 8], [9, 6, 7, 12], [4, 15, 14, 1]] 程序示例import java.util.Arrays; public class HuangZiHanTest &#123; public static void main(String[] huangzihan_args) &#123; double[][] huangzihan_a &#x3D; &#123; &#123;1, 2, 3, 4&#125;, &#123;5, 6, 7, 8&#125;, &#123;4, 3, 2, 1&#125;, &#123;8, 7, 6, 5&#125;, &#125;; for(double[] row : huangzihan_a) &#123; for(double huangzihan_value : row) &#123; System.out.println(Arrays.deepToString(huangzihan_a)); &#125; &#125; &#125; &#125; 运行结果[[1.0, 2.0, 3.0, 4.0], [5.0, 6.0, 7.0, 8.0], [4.0, 3.0, 2.0, 1.0], [8.0, 7.0, 6.0, 5.0]] [[1.0, 2.0, 3.0, 4.0], [5.0, 6.0, 7.0, 8.0], [4.0, 3.0, 2.0, 1.0], [8.0, 7.0, 6.0, 5.0]] [[1.0, 2.0, 3.0, 4.0], [5.0, 6.0, 7.0, 8.0], [4.0, 3.0, 2.0, 1.0], [8.0, 7.0, 6.0, 5.0]] [[1.0, 2.0, 3.0, 4.0], [5.0, 6.0, 7.0, 8.0], [4.0, 3.0, 2.0, 1.0], [8.0, 7.0, 6.0, 5.0]] [[1.0, 2.0, 3.0, 4.0], [5.0, 6.0, 7.0, 8.0], [4.0, 3.0, 2.0, 1.0], [8.0, 7.0, 6.0, 5.0]] [[1.0, 2.0, 3.0, 4.0], [5.0, 6.0, 7.0, 8.0], [4.0, 3.0, 2.0, 1.0], [8.0, 7.0, 6.0, 5.0]] [[1.0, 2.0, 3.0, 4.0], [5.0, 6.0, 7.0, 8.0], [4.0, 3.0, 2.0, 1.0], [8.0, 7.0, 6.0, 5.0]] [[1.0, 2.0, 3.0, 4.0], [5.0, 6.0, 7.0, 8.0], [4.0, 3.0, 2.0, 1.0], [8.0, 7.0, 6.0, 5.0]] [[1.0, 2.0, 3.0, 4.0], [5.0, 6.0, 7.0, 8.0], [4.0, 3.0, 2.0, 1.0], [8.0, 7.0, 6.0, 5.0]] [[1.0, 2.0, 3.0, 4.0], [5.0, 6.0, 7.0, 8.0], [4.0, 3.0, 2.0, 1.0], [8.0, 7.0, 6.0, 5.0]] [[1.0, 2.0, 3.0, 4.0], [5.0, 6.0, 7.0, 8.0], [4.0, 3.0, 2.0, 1.0], [8.0, 7.0, 6.0, 5.0]] [[1.0, 2.0, 3.0, 4.0], [5.0, 6.0, 7.0, 8.0], [4.0, 3.0, 2.0, 1.0], [8.0, 7.0, 6.0, 5.0]] [[1.0, 2.0, 3.0, 4.0], [5.0, 6.0, 7.0, 8.0], [4.0, 3.0, 2.0, 1.0], [8.0, 7.0, 6.0, 5.0]] [[1.0, 2.0, 3.0, 4.0], [5.0, 6.0, 7.0, 8.0], [4.0, 3.0, 2.0, 1.0], [8.0, 7.0, 6.0, 5.0]] [[1.0, 2.0, 3.0, 4.0], [5.0, 6.0, 7.0, 8.0], [4.0, 3.0, 2.0, 1.0], [8.0, 7.0, 6.0, 5.0]] [[1.0, 2.0, 3.0, 4.0], [5.0, 6.0, 7.0, 8.0], [4.0, 3.0, 2.0, 1.0], [8.0, 7.0, 6.0, 5.0]] 不规则数组 到目前为止，我们看到的数组与其他程序设计语言中提供的数组没有多大区别。但在底层实际存在着一些细微的差异，有时你可以充分利用这一点：Java实际上没有多维数组，只有一维数组。多维数组被解释为“数组的数组”。 例如，在前面的示例中，balances数组实际上是一个包含10个元素的数组，而每个元素 又是一个由6个浮点数组成的数组（请参看图（一个二维数组））。 一个二维数组 表达式balances[i]引用第 i 个子数组，也就是表格的第 i 行。它本身也是一个数组，balances[i][j]引用这个数组的第 j 个元素。 由于可以单独地访问数组的某一行，所以可以让两行交换。 double[] temp &#x3D; balances[i]; balances[i] &#x3D; balances[i + 1]; balances[i + 1] &#x3D; temp; 程序示例import java.util.Arrays; public class HuangZiHanTest &#123; public static void main(String[] huangzihan_args) &#123; double[] huangzihan_temp; int huangzihan_i&#x3D;0; double[][] huangzihan_balances &#x3D; &#123; &#123;1, 2, 3, 4&#125;, &#123;4, 3, 2, 1&#125;, &#123;5, 6, 7, 8&#125;, &#123;8, 7, 6, 5&#125;, &#125;; huangzihan_temp &#x3D; huangzihan_balances[huangzihan_i]; huangzihan_balances[huangzihan_i] &#x3D; huangzihan_balances[huangzihan_i + 1]; huangzihan_balances[huangzihan_i + 1] &#x3D; huangzihan_temp; System.out.println(Arrays.deepToString(huangzihan_balances)); &#125; &#125; 运行结果[[4.0, 3.0, 2.0, 1.0], [1.0, 2.0, 3.0, 4.0], [5.0, 6.0, 7.0, 8.0], [8.0, 7.0, 6.0, 5.0]] 还可以方便地构造一个“不规则”数组，即数组的每一行有不同的长度。下面是一个标准的示例。我们将创建一个数组，第 i 行第 j 列将存放“从 i 个数中抽取 j 个数”可能的结果数。 1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1 1 6 15 20 15 6 1 由于 j 不可能大于 i，所以矩阵是三角形的。第 i 行有 i + 1 个元素（允许抽取 0 个元素，这种选择只有一种可能）。要想创建这样一个不规则的数组，首先需要分配一个数组包含这些行： int[][] odds &#x3D; new int[NMAx + 1][]; 接下来，分配这些行： 不规则数组程序示例三 在分配了数组之后，假定没有超出边界，就可以采用通常的方式访问其中的元素了。 不规则数组程序示例一 程序示例 不规则数组程序示例二 运行结果5 [[0], [0, 0], [0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0, 0]] huangzihan_lotteryoOdds&#x3D;1 huangzihan_lotteryoOdds&#x3D;2 huangzihan_lotteryoOdds&#x3D;2 huangzihan_lotteryoOdds&#x3D;1 huangzihan_lotteryoOdds&#x3D;3 huangzihan_lotteryoOdds&#x3D;3 huangzihan_lotteryoOdds&#x3D;3 huangzihan_lotteryoOdds&#x3D;3 huangzihan_lotteryoOdds&#x3D;3 huangzihan_lotteryoOdds&#x3D;1 huangzihan_lotteryoOdds&#x3D;4 huangzihan_lotteryoOdds&#x3D;4 huangzihan_lotteryoOdds&#x3D;6 huangzihan_lotteryoOdds&#x3D;4 huangzihan_lotteryoOdds&#x3D;6 huangzihan_lotteryoOdds&#x3D;4 huangzihan_lotteryoOdds&#x3D;4 huangzihan_lotteryoOdds&#x3D;6 huangzihan_lotteryoOdds&#x3D;4 huangzihan_lotteryoOdds&#x3D;1 huangzihan_odds&#x3D;[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]] 1 1 1 1 2 1 1 3 3 1 1 4 6 4 1","path":"2021/07/12/数组/","date":"07-12","excerpt":"数组 数组存储相同类型值的序列。 声明数组下标（index，或称索引） 数组是一种数据结构，用来存储同一类型值的集合。通过一个整型下标（index，或称索引）可以访问数组中的每一个值。例如，如果 a 是一个整型数组，a[i]就是数组中下标为 i 的整数。 在声明数组变量时，需要指出数组类型（数据元素类型紧跟[]）和数组变量的名字。下面声明了整型数组 a ： int[] a; 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; int[] huangzihan_a; int[] huangzihan_b; int[] huangzihan_c; &#125; &#125;","tags":[]},{"title":"大数","text":"大数java.math 如果基本的整数和浮点数精度不能够满足需求，那么可以使用java.math包中两个很有用的类：BigInteger和BigDecimal。这两个类可以处理包含任意长度数字序列的数值。 BigInteger类 BigInteger类实现任意精度的整数运算 BigDecimal类 BigDecimal类实现任意精度的浮点数运算。 静态的valueOf方法 使用静态的valueOf方法可以将普通的数值转换为大数： BigInteger a &#x3D; BigInteger.valueOf(100); 程序示例import java.math.BigInteger; public class HuangZiHanTest &#123; public static void main(String[] args) &#123; int huangzihan100 &#x3D; 100; int huangzihan1314 &#x3D; 1314; int huangzihan123456789 &#x3D; 123456789; BigInteger huangzihanValueOf100 &#x3D; BigInteger.valueOf(100); BigInteger huangzihanValueOf1314 &#x3D; BigInteger.valueOf(1314); BigInteger huangzihanValueOf123456789 &#x3D; BigInteger.valueOf(123456789); System.out.println(huangzihan100); System.out.println(huangzihan1314); System.out.println(huangzihan123456789); System.out.println(); System.out.println(huangzihanValueOf100); System.out.println(huangzihanValueOf1314); System.out.println(huangzihanValueOf123456789); &#125; &#125; 运行结果100 1314 123456789 100 1314 123456789 带字符串参数的构造器 对于更大的数，可以使用一个带字符串参数的构造器： BigInteger reallyBig &#x3D; new BigInteger(&quot;222232244629428445529739893461909967206666939096499764998979600&quot;); 程序示例import java.math.BigInteger; public class HuangZiHanTest &#123; public static void main(String[] args) &#123; BigInteger huangzihan123456789987654321 &#x3D; new BigInteger(&quot;123456789987654321&quot;); BigInteger huangzihan123456789123456789123456789 &#x3D; new BigInteger(&quot;123456789123456789123456789&quot;); System.out.println(huangzihan123456789987654321); System.out.println(huangzihan123456789123456789123456789); &#125; &#125; 运行结果123456789987654321 123456789123456789123456789 另外还有一些常量：BigInteger.ZERO、BigInteger.ONE和BigInteger.TEN，Java 9之后还增加了BigInteger.TWO。 add和multiply方法 遗憾的是，不能使用人们熟悉的算术运算符（如：+和×）处理大数，而需要使用大数类中的add和multiply方法。 BigInteger c &#x3D; a.add(b); &#x2F;&#x2F;c&#x3D;a+b BigInteger d &#x3D; c.multiply(b.add(BigInteger.valueOf(2))); &#x2F;&#x2F;d&#x3D;c*(b+2) 程序示例import java.math.BigInteger; public class HuangZiHanTest &#123; public static void main(String[] args) &#123; BigInteger huangzihanA &#x3D; BigInteger.valueOf(123456789); BigInteger huangzihanB &#x3D; BigInteger.valueOf(987654321); BigInteger huangzihanC &#x3D; huangzihanA.add(huangzihanB); System.out.println(huangzihanC); BigInteger huangzihanD &#x3D; huangzihanC.multiply(huangzihanB.add(BigInteger.valueOf(2))); System.out.println(huangzihanD); &#125; &#125; 运行结果1111111110 1097393691124828530 程序示例 大数程序示例 运行结果你需要画多少个数字？ 5 你能画的最高数字是什么？ 10 你的几率是252分之一。祝你好运！","path":"2021/07/09/大数/","date":"07-09","excerpt":"大数java.math 如果基本的整数和浮点数精度不能够满足需求，那么可以使用java.math包中两个很有用的类：BigInteger和BigDecimal。这两个类可以处理包含任意长度数字序列的数值。 BigInteger类 BigInteger类实现任意精度的整数运算 BigDecimal类 BigDecimal类实现任意精度的浮点数运算。 静态的valueOf方法 使用静态的valueOf方法可以将普通的数值转换为大数： BigInteger a &#x3D; BigInteger.valueOf(100); 程序示例import java.math.BigInteger; public class HuangZiHanTest &#123; public static void main(String[] args) &#123; int huangzihan100 &#x3D; 100; int huangzihan1314 &#x3D; 1314; int huangzihan123456789 &#x3D; 123456789; BigInteger huangzihanValueOf100 &#x3D; BigInteger.valueOf(100); BigInteger huangzihanValueOf1314 &#x3D; BigInteger.valueOf(1314); BigInteger huangzihanValueOf123456789 &#x3D; BigInteger.valueOf(123456789); System.out.println(huangzihan100); System.out.println(huangzihan1314); System.out.println(huangzihan123456789); System.out.println(); System.out.println(huangzihanValueOf100); System.out.println(huangzihanValueOf1314); System.out.println(huangzihanValueOf123456789); &#125; &#125;","tags":[]},{"title":"控制流程","text":"控制流程 与任何程序设计语言一样，Java使用条件语句和循环结构确定控制流程。当需要对某个表达式的多个值进行检测时，可以使用switch语句。 块作用域块 在深入学习控制结构之前，需要了解块（block）的概念。 块（即复合语句）是指由若干条Java语句组成的语句，并用一对大括号括起来。块确定了变量的作用域。一个块可以嵌套在另一个块中。下面就是嵌套在main方法块中的一个块。 public static void main(String[] args) &#123; int n; ... &#123; int k; &#125; &#125;&#x2F;&#x2F;k is only defined up to here 但是，不能在嵌套的两个块中声明同名的变量。例如，下面的代码就错误，而无法通过编译： public static void main(String[] args) &#123; int n; ... &#123; int k; int n; &#x2F;&#x2F;ERROR--can&#39;t redefine n in inner block ... &#125; &#125; 条件语句 在Java中，条件语句的形式为 if(condition) statement 这里的条件必须用小括号括起来。 块语句（block statement） 与绝大多数程序设计语言一样，Java常常希望在某个条件为真时执行多条语句。在这种情况下，就可以使用块语句（block statement），形式为 &#123; statement1 statement2 ... &#125; 例如： if(yourSales &gt;&#x3D; target) &#123; performance&#x3D;&quot;Satisfactory&quot;; bonus&#x3D;100; &#125; if语句流程图 当yourSales大于或等于target时，将执行大括号中的所有语句（请参看图（if语句流程图））。 if语句流程图 注释复合语句 使用块（有时称为复合语句）可以在Java程序结构中原本只能放置一条（简单）语句的地方放置多条语句。 if或else语句流程图 在Java中，更一般的条件语句如下所示（请参看图（if或else语句流程图））： if(condition) statement1 else statement2 if或else语句流程图 例如： if(yourSales &gt;&#x3D; target) &#123; performance &#x3D; &quot;Satisfactory&quot;; bonus &#x3D; 100+0.01*(yourSales - target); &#125; else &#123; performance &#x3D; &quot;Unsatisfactory&quot;; bonus &#x3D; 0; &#125; 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; int tall &#x3D;177; int weight &#x3D;160; String huangzihan_performance; &#x2F;&#x2F;double bonus; if(tall &gt;&#x3D; weight) &#123; huangzihan_performance &#x3D; &quot;黄子涵是帅哥！&quot;; &#x2F;&#x2F;bonus &#x3D; 100+0.01*(tall - weight); System.out.println(huangzihan_performance); &#125; else &#123; huangzihan_performance &#x3D; &quot;黄子涵不是帅哥！&quot;; &#x2F;&#x2F;bonus &#x3D; 0; &#125; &#125; &#125; 运行结果黄子涵是帅哥！ else与if配对 其中else部分总是可选的。else子句与最邻近的if构成一组。因此，在语句if else与if配对程序示例一 中else与第2个if配对。当然，使用大括号会让这段代码更加清晰： else与if配对程序示例二 程序示例 else与if配对程序示例三 运行结果0 黄子涵是帅哥！ if或else if（多分支）流程图 反复使用if…else if…很常见（请参看图（if或else if（多分支）流程图））。例如： if或else if（多分支）流程图 if(yourSales &gt;&#x3D; 2* target) &#123; performance &#x3D; &quot;Excellent&quot;; bonus &#x3D; 1000; &#125; else if (yourSales &gt;&#x3D; 1.5* target) &#123; performance &#x3D; &quot;Fine&quot;; bonus &#x3D; 500; &#125; else if (yourSales &gt;&#x3D; target) &#123; performance &#x3D; &quot;Satisfactory&quot;; bonus &#x3D; 100; &#125; else &#123; System.out.println(&quot;You&#39;re fired&quot;); &#125; 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; int huangzihan_tall&#x3D;177; int huangzihan_weight&#x3D;160; String huangzihan_performance; int bonus; if(huangzihan_tall &gt;&#x3D; 2* huangzihan_weight) &#123; huangzihan_performance &#x3D; &quot;黄子涵不是帅哥！&quot;; bonus &#x3D; 1000; System.out.println(bonus); System.out.println(huangzihan_performance); &#125; else if (huangzihan_tall &gt;&#x3D; 1.5* huangzihan_weight) &#123; huangzihan_performance &#x3D; &quot;黄子涵可能是帅哥！&quot;; bonus &#x3D; 500; System.out.println(bonus); System.out.println(huangzihan_performance); &#125; else if (huangzihan_tall &gt;&#x3D; huangzihan_weight) &#123; huangzihan_performance &#x3D; &quot;黄子涵肯定是帅哥！&quot;; bonus &#x3D; 100; System.out.println(bonus); System.out.println(huangzihan_performance); &#125; else &#123; System.out.println(&quot;你眼光很好！&quot;); &#125; &#125; &#125; 运行结果100 黄子涵肯定是帅哥！ 循环 当条件为true时，while循环执行一条语句（也可以是一个块语句）。一般形式如下 while(condition) statement while语句的流程图 如果开始时循环条件的值就为false，那么while循环一次也不执行（请参看图（while语句的流程图））。 while语句的流程图 while循环语句在最前面检测循环条件。因此，循环体中的代码有可能一次都不执行。如果希望循环体至少执行一次，需要使用do/while循环将检测放在最后。它的语法如下： do statement while (condition); 这种循环语句先执行语句（通常是一个语句块），然后再检测循环条件。如果为true，就重复执行语句，然后再次检测循环条件，以此类推。 do或while流程图 do或while流程图 程序示例 do或while流程图程序示例一 运行结果你需要多少钱退休？ 987654321 你每年捐多少钱？ 12345.6789 利率（%）： 6.78 你可以在131年后退休。 程序示例&#x2F;* * 此程序演示&lt;code&gt;do&#x2F;while&lt;&#x2F;code&gt;循环。 * 版本：1.01 * 作者：黄子涵 * 时间：2021年7月7日 * *&#x2F; import java.util.Scanner; public class HuangZiHanTest &#123; public static void main(String[] args) &#123; Scanner in &#x3D; new Scanner(System.in); System.out.println(&quot;你每年捐多少钱？&quot;); double huangzihan_payment &#x3D; in.nextDouble(); System.out.println(&quot;利率（%）：&quot;); double huangzihan_interestRate &#x3D; in.nextDouble(); double huangzihan_balance &#x3D; 0; int huangzihan_years &#x3D; 0; String huangzihan_input; do &#123; huangzihan_balance +&#x3D; huangzihan_payment; double huangzihanInterest &#x3D; huangzihan_balance * huangzihan_interestRate &#x2F; 100; huangzihan_balance +&#x3D; huangzihanInterest; huangzihan_years++; System.out.printf(&quot;第%d年后，您的余额为%,.2f%n&quot;,huangzihan_years,huangzihan_balance); System.out.println(&quot;准备退休吗？（是&#x2F;否）&quot;); huangzihan_input &#x3D; in.next(); &#125; while(huangzihan_input.equals(&quot;否&quot;)); &#125; &#125; 运行结果你每年捐多少钱？ 98765.4321 利率（%）： 6.78 第1年后，您的余额为105,461.73 准备退休吗？（是&#x2F;否） 否 第2年后，您的余额为218,073.76 准备退休吗？（是&#x2F;否） 否 第3年后，您的余额为338,320.89 准备退休吗？（是&#x2F;否） 否 第4年后，您的余额为466,720.78 准备退休吗？（是&#x2F;否） 否 第5年后，您的余额为603,826.17 准备退休吗？（是&#x2F;否） 是 确定循环for循环 for循环语句是支持迭代的一种通用结构，由一个计数器或类似的变量控制迭代次数，每次迭代后这个变量将会更新。如图（for语句流程图）所示，下面的循环将数字1 ~ 10输出到屏幕上。 for语句流程图 for循环程序示例一 for语句的第1部分通常是对计数器初始化；第2部分给出每次新一轮循环执行前要检测的循环条件；第3部分指定如何更新计数器。 for语句的3个部分应该对同一个计数器变量进行初始化、检测和更新。 程序示例 for循环程序示例二 运行结果1 2 3 4 5 6 7 8 9 10 警告检测两个浮点数是否相等 在循环中，检测两个浮点数是否相等需要格外小心。下面的for循环 for(double x &#x3D; 0; × !&#x3D; 10; x +&#x3D; 0.1) ... 可能永远不会结束。由于舍入的误差，可能永远达不到精确的最终值。例如，在上面的循环中，因为0.1无法精确地用二进制表示，所以，x将从9.999 999 999 999 98跳到10.099 999 999 999 98。 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; for(double huangzihan_x &#x3D; 0; huangzihan_x !&#x3D; 10; huangzihan_x +&#x3D; 0.1) &#123; System.out.println(&quot;黄子涵是帅哥！&quot;); &#125; &#125; &#125; 运行结果黄子涵是帅哥！ 黄子涵是帅哥！ 黄子涵是帅哥！ ... ... ... 变量的作用域 当在for语句的第1部分中声明了一个变量之后，这个变量的作用域就扩展到这个for循环体的末尾。 变量的作用域程序示例一 程序示例 变量的作用域程序示例二 运行结果1 2 3 4 5 6 7 8 9 10 黄子涵是帅哥！ 在循环之外声明变量 特别指出，如果在for语句内部定义一个变量，这个变量就不能在循环体之外使用。因此，如果希望在for循环体之外使用循环计数器的最终值，就要确保这个变量在循环之外声明！ 在循环之外声明变量程序示例一 程序示例 在循环之外声明变量程序示例二 运行结果黄子涵是帅哥！ 黄子涵是帅哥！ 黄子涵是帅哥！ 黄子涵是帅哥！ 黄子涵是帅哥！ 黄子涵是帅哥！ 黄子涵是帅哥！ 黄子涵是帅哥！ 黄子涵是帅哥！ 黄子涵是帅哥！ 11 不同的for循环中定义同名的变量 另一方面，可以在不同的for循环中定义同名的变量： 不同的for循环中定义同名的变量程序示例一 程序示例 不同的for循环中定义同名的变量程序示例二 运行结果黄子涵是帅哥吗？ 黄子涵是帅哥吗？ 黄子涵是帅哥吗？ 黄子涵是帅哥吗？ 黄子涵是帅哥吗？ 黄子涵是帅哥吗？ 黄子涵是帅哥吗？ 黄子涵是帅哥吗？ 黄子涵是帅哥吗？ 黄子涵是帅哥吗？ 肯定啊！ 肯定啊！ 肯定啊！ 肯定啊！ 肯定啊！ 肯定啊！ 肯定啊！ 肯定啊！ 肯定啊！ 肯定啊！ for循环是while循环的一种简化形式 for循环语句只不过是while循环的一种简化形式。例如， for(int i &#x3D; 10; i &gt; 0; i--) System.out.println(&quot;Counting down . . .&quot;+i); 可以重写为： int i &#x3D; 10; while(i &gt; 0) &#123; System.out.println(&quot;Counting down . . .&quot; + i); i --; &#125; 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; for(int huangzihan_i &#x3D; 10; huangzihan_i &gt; 0; huangzihan_i--) &#123; System.out.println(&quot;黄子涵是帅哥 . . .&quot;+huangzihan_i); &#125; System.out.println(); int huangzihan_i &#x3D; 10; while(huangzihan_i &gt; 0) &#123; System.out.println(&quot;黄子涵是帅哥 . . .&quot; + huangzihan_i); huangzihan_i --; &#125; &#125; &#125; 运行结果黄子涵是帅哥 . . .10 黄子涵是帅哥 . . .9 黄子涵是帅哥 . . .8 黄子涵是帅哥 . . .7 黄子涵是帅哥 . . .6 黄子涵是帅哥 . . .5 黄子涵是帅哥 . . .4 黄子涵是帅哥 . . .3 黄子涵是帅哥 . . .2 黄子涵是帅哥 . . .1 黄子涵是帅哥 . . .10 黄子涵是帅哥 . . .9 黄子涵是帅哥 . . .8 黄子涵是帅哥 . . .7 黄子涵是帅哥 . . .6 黄子涵是帅哥 . . .5 黄子涵是帅哥 . . .4 黄子涵是帅哥 . . .3 黄子涵是帅哥 . . .2 黄子涵是帅哥 . . .1 n个数字中抽取k个数字 这个程序用来计算抽奖中奖的概率。例如，如果必须从1 ~ 50的数字中取6个数字来抽奖，那么会有（50×49×48×47×46×45）/（1×2×3×4×5×6）种可能的结果，所以中奖的概率是1/15 890 700。祝你好运！ 一般情况下，如果从n个数字中抽取k个数字，就会有 n*（n-1）*（n-2）*...*（n-k+1） ------------------------------ 1*2*3*4*...*k 种可能。下面的for循环语句可以计算这个值： n个数字中抽取k个数字程序示例一 程序示例 for循环程序示例三 运行结果你需要画多少个数字？ 5 你能画的最高数字是多少？ 10 你的赔率是1&#x2F;252。祝你好运！ 多重选择：switch语句 在处理多个选项时，使用if/else结构显得有些笨拙。 for语句流程图 例如，如果建立一个如图（for语句流程图）所示的包含4个选项的菜单系统，可以使用下列代码： for语句流程图 Scanner in &#x3D; new Scanner(System.in); System.out.print(&quot;Select an option(1,2,3,4)&quot;); int choice &#x3D; in.nextInt(); Switch(choice) &#123; case 1: . . . break; case 2: . . . break; case 3: . . . break; case 4: . . . break; default: &#x2F;&#x2F;bad input . . . break; &#125; 程序示例import java.util.Scanner; public class HuangZiHanTest &#123; public static void main(String[] args) &#123; while(true) &#123; Scanner huangzihan_in &#x3D; new Scanner(System.in); System.out.print(&quot;选择一个数字（1,2,3）&quot;); int huangzihan_choice&#x3D;huangzihan_in.nextInt(); switch(huangzihan_choice) &#123; case 1: System.out.println(&quot;黄子涵真帅！&quot;); break; case 2: System.out.println(&quot;黄子涵真高！&quot;); break; case 3: System.out.println(&quot;黄子涵真有钱！&quot;); break; &#125; &#125; &#125; &#125; 运行结果选择一个数字（1,2,3） 1 黄子涵真帅！ 选择一个数字（1,2,3） 2 黄子涵真高！ 选择一个数字（1,2,3） 3 黄子涵真有钱！ 选择一个数字（1,2,3） default子句 switch语句将从与选项值相匹配的case标签开始执行，直到遇到break语句，或者执行到switch语句的结束处为止。如果没有相匹配的case标签，而有default子句，就执行这个子句。 警告 有可能触发多个case分支。如果在case分支语句的末尾没有break语句，那么就会接着执行下一个case分支语句。这种情况相当危险，常常会引发错误。为此，我们在程序中从不使用switch语句。 -XLint:fallthrough 如果你比我们更喜欢switch语句，编译代码时可以考虑加上-XLint:fallthrough选项，如下所示： javac -XLint:fallthrough Test.java 这样一来，如果某个分支最后缺少一个break语句，编译器就会给出一个警告消息。 直通式（fallthrough） 如果你确实正是想使用这种“直通式”（fallthrough）行为，可以为其外围方法加一个注解@SuppressWarnings(&quot;fallthrough&quot;)。这样就不会对这个方法生成警告了。（注解是为编译器或处理Java源文件或类文件的工具提供信息的一种机制。） case标签 case标签可以是： 类型为char、byte、short或int的常量表达式。 枚举常量。 从Java7开始，case标签还可以是字符串字面量。 例如： String input &#x3D; . . .; switch(input.toLowerCase()) &#123; case &quot;yes&quot;: &#x2F;&#x2F;OK since Java 7 . . . break; . . . &#125; toLowerCase()描述使用默认区域设置的规则将此字符串中的所有字符转换为小写。这相当于调用toLowerCase(Locale.getDefault())。 注此方法对区域设置敏感，如果用于要在本地独立解释的字符串，则可能会产生意外结果。例如，编程语言标识符、协议密钥和HTMLtags。例如，土耳其语locale中的&quot;TITLE&quot;.toLowerCase()返回“t\\u005Cu0131tle”，其中”\\u005Cu0131”是LATIN SMALL LETTER DOTLESS I 字符。若要获得不区分区域设置的字符串的正确结果，请使用toLowerCase(Locale.ROOT)。 返回值字符串，转换为小写。 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; while(true) &#123; String huangzihan_input&#x3D;&quot;是&quot;; switch(huangzihan_input.toLowerCase()) &#123; case &quot;是&quot;: System.out.println(&quot;黄子涵是帅哥！&quot;); break; case &quot;否&quot;: System.out.println(&quot;黄子涵不是帅哥！&quot;); break; &#125; &#125; &#125; &#125; 运行结果黄子涵是帅哥！ 黄子涵是帅哥！ 黄子涵是帅哥！ ...... ...... ...... 黄子涵是帅哥！ 黄子涵是帅哥！ 黄子涵是帅哥！ ...... ...... ...... 当在switch语句中使用枚举常量时，不必在每个标签中指明枚举名，可以由switch的表达式值推导得出。例如： Size sz &#x3D; . . .; Switch(sz) &#123; case SMALL: &#x2F;&#x2F;no need to use Size.SMALL break; . . . &#125; 中断控制流程的语句 尽管Java的设计者将goto作为保留字，但实际上并没有打算在语言中使用它。通常，使用goto语句被认为是一种拙劣的程序设计风格。当然，也有一些程序员认为反对goto的呼声似乎有些过分（例如，Donald Knuth就曾写过一篇名为《Structured Programming with goto statements》的著名文章）。这篇文章说，无限制地使用goto语句确实很容易导致错误，但在有些情况下，偶尔使用goto跳出循环还是有益处的。Java设计者同意这种看法，甚至在Java语言中增加了一条新的语句：带标签的break，以此来支持这种程序设计风格。 不带标签的break语句 下面首先看一下不带标签的break语句。与用于退出switch语句的break语句一样，它也可以用于退出循环语句。例如， 不带标签的break语句程序示例一 程序示例 不带标签的break语句程序示例二 运行结果50 12.0 62 1 50 28.0 140 2 50 47.0 237 3 50 71.0 358 4 50 102.0 510 5 50 140.0 700 6 50 187.0 937 7 50 246.0 1233 8 在循环开始时，如果years&gt;100，或者在循环体中balance≥goal，则退出循环语句。当然，也可以在不使用break的情况下计算years的值，如下所示： 不带标签的break语句程序示例三 程序示例 不带标签的break语句程序示例 运行结果50 12.0 62 1 50 28.0 140 2 50 47.0 237 3 50 71.0 358 4 50 102.0 510 5 50 140.0 700 6 50 187.0 937 7 50 246.0 1233 8 50 320.0 1603 8 但是需要注意，在这个版本中，检测了两次balance&lt;goal。为了避免重复检测，有些程序员更加偏爱使用break语句。 带标签的break语句 Java还提供了一种带标签的break语句，用于跳出多重嵌套的循环语句。有时候，在嵌套很深的循环语句中会发生一些不可预料的事情。此时可能更加希望完全跳出所有嵌套循环之外。如果只是为各层循环检测添加一些额外的条件，这会很不方便。 这里有一个示例说明了break语句的工作状态。请注意，标签必须放在希望跳出的最外层循环之前，并且必须紧跟一个冒号。 带标签的break语句程序示例一 如果输入有误，执行带标签的break会跳转到带标签的语句块末尾。与任何使用break语句的代码一样，然后需要检测循环是正常结束，还是由break跳出。 注释 事实上，可以将标签应用到任何语句，甚至可以将其应用到if语句或者块语句，如下所示： label: &#123; . . . if(condition) break label; &#x2F;&#x2F;exits block . . . &#125; &#x2F;&#x2F; jumps here when the break statement executes 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; String huangzihan&#x3D;&quot;黄子涵是帅哥！&quot;; label: &#123; if(huangzihan&#x3D;&#x3D;&quot;黄子涵是帅哥！&quot;) &#123; System.out.println(&quot;帅哥，黄子涵！&quot;); break label; &#125; &#125; System.out.println(&quot;黄子涵是帅哥！&quot;); &#125; &#125; 运行结果帅哥，黄子涵！ 黄子涵是帅哥！ 因此，如果确实希望使用goto语句，而且一个代码块恰好在你想要跳到的位置之前结束，就可以使用break语句！当然，并不提倡使用这种方式。另外需要注意，只能跳出语句块，而不能跳入语句块。 continue语句 最后，还有一个continue语句。与break语句一样，它将中断正常的控制流程。continue语句将控制转移到最内层循环的首部。例如： continue语句程序示例一 如果n&lt;0，则continue语句越过了当前循环体的剩余部分，立刻跳到循环首部。 程序示例 continue语句程序示例二 运行结果输入一个数字： 2 huangzihan_sum&#x3D;2 输入一个数字： 3 huangzihan_sum&#x3D;5 输入一个数字： -1 输入一个数字： 0 huangzihan_sum&#x3D;5 输入一个数字： 4 huangzihan_sum&#x3D;9 输入一个数字： -5 输入一个数字： 6 huangzihan_sum&#x3D;15 continue语句用于for循环中 如果将continue语句用于for循环中，就可以跳到for循环的“更新”部分。例如，下面这个循环： continue语句用于for循环中程序示例一 如果n&lt;0，则continue语句将跳到count++语句。 还有一种带标签的continue语句，将跳到与标签匹配的循环的首部。 程序示例 continue语句用于for循环中程序示例二 运行结果输入一个数字，-1退出: 2 huangzihan_count&#x3D;1 huangzihan_sum&#x3D;2 输入一个数字，-1退出: -1 输入一个数字，-1退出: 3 huangzihan_count&#x3D;3 huangzihan_sum&#x3D;5 输入一个数字，-1退出: -1 输入一个数字，-1退出: 4 huangzihan_count&#x3D;5 huangzihan_sum&#x3D;9 提示 许多程序员发现很容易混淆break和continue语句。这些语句完全是可选的，即不使用它们也可以表达同样的逻辑含义。","path":"2021/07/08/控制流程/","date":"07-08","excerpt":"控制流程 与任何程序设计语言一样，Java使用条件语句和循环结构确定控制流程。当需要对某个表达式的多个值进行检测时，可以使用switch语句。 块作用域块 在深入学习控制结构之前，需要了解块（block）的概念。 块（即复合语句）是指由若干条Java语句组成的语句，并用一对大括号括起来。块确定了变量的作用域。一个块可以嵌套在另一个块中。下面就是嵌套在main方法块中的一个块。 public static void main(String[] args) &#123; int n; ... &#123; int k; &#125; &#125;&#x2F;&#x2F;k is only defined up to here 但是，不能在嵌套的两个块中声明同名的变量。例如，下面的代码就错误，而无法通过编译： public static void main(String[] args) &#123; int n; ... &#123; int k; int n; &#x2F;&#x2F;ERROR--can&#39;t redefine n in inner block ... &#125; &#125;","tags":[]},{"title":"字符串","text":"字符串String 从概念上讲，Java字符串就是Unicode字符序列。例如，字符串”Java\\u2122”由5个Unicode字符J、a、v、a和™组成。Java没有内置的字符串类型，而是在标准Java类库中提供了一个预定义类，很自然地叫做String。每个用双引号括起来的字符串都是String类的一个实例： String e&#x3D;&quot; &quot;; &#x2F;&#x2F;an empty string String greeting&#x3D;&quot;Hello&quot;; 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; String huangzihan_e&#x3D;&quot; &quot;; &#x2F;&#x2F;an empty string String huangzihan_greeting&#x3D;&quot;huangzihan_Hello&quot;; System.out.println(huangzihan_e); System.out.println(huangzihan_greeting); System.out.println(&quot;Java\\u2122&quot;); &#125; &#125; 运行结果 huangzihan_Hello Java™ 子串substring方法 String类的substring方法可以从一个较大的字符串提取出一个子串。例如： String greeting &#x3D;&quot;Hello&quot;; String s &#x3D; greeting.substring(0,3); 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; String huangzihan_greeting &#x3D;&quot;huangzihan_Hello&quot;; String huangzihan_s &#x3D; huangzihan_greeting.substring(0,10); System.out.println(huangzihan_s); &#125; &#125; 运行结果huangzihan 创建一个由字符“huangzihan”组成的字符串。 注释 类似于C和C++，Java字符串中的代码单元和代码点从0开始计数。 substring方法的第二个参数是不想复制的第一个位置。这里要复制位置为0、1、2、3、4、5、6、7、8、9（从0到9，包括0和9）的字符。在substring中从0开始计数，直到9为止，但不包含9。 substring的工作方式有一个优点：容易计算子串的长度。字符串s.substring(a,b)的长度为b-a。例如，子串“huangzihan”的长度为10-0=10。 拼接+号连接（拼接） 与绝大多数程序设计语言一样，Java语言允许使用 + 号连接（拼接）两个字符串。 String expletive&#x3D;&quot;Expletive&quot;; String PG13&#x3D;&quot;deleted&quot;; String message&#x3D;expletive+PG13; 上述代码将“Expletivedeleted”赋给变量message（注意，单词之间没有空格，+号完全按照给定的次序将两个字符串拼接起来）。 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; String huangzihan_expletive&#x3D;&quot;huang&quot;; String huangzihan_PG13&#x3D;&quot;zihan&quot;; String huangzihan_message&#x3D;huangzihan_expletive+huangzihan_PG13; System.out.println(huangzihan_message); &#125; &#125; 运行结果huangzihan 字符串与非字符串拼接 当将一个字符串与一个非字符串的值进行拼接时，后者会转换成字符串。例如： int age&#x3D;13; String rating&#x3D;&quot;PG&quot;+age; 将rating设置为“PG13”。这种特性通常用在输出语句中。例如： System.out.println(&quot;The answer is &quot;+answer); 这是一条合法的语句，并且会打印出所希望的结果（因为单词is后面加了一个空格，输出时也会加上这个空格）。 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; int huangzihan_age&#x3D;13; String huangzihan_rating&#x3D;&quot;帅&quot;+huangzihan_age; System.out.println(&quot;黄子涵是&quot;+huangzihan_rating); &#125; &#125; 运行结果黄子涵是帅13 静态join方法 如果需要把多个字符串放在一起，用一个界定符分隔，可以使用静态join方法： String all&#x3D;String.join(&quot;&#x2F;&quot;,&quot;S&quot;,&quot;M&quot;,&quot;L&quot;,&quot;XL&quot;); &#x2F;&#x2F;all is the string &quot;S&#x2F;M&#x2F;L&#x2F;XL&quot; 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; String huangzihan_all&#x3D;String.join(&quot;&#x2F;&quot;,&quot;huang&quot;,&quot;zi&quot;,&quot;han&quot;); &#x2F;&#x2F;all is the string &quot;S&#x2F;M&#x2F;L&#x2F;XL&quot; System.out.println(huangzihan_all); &#125; &#125; 运行结果huang&#x2F;zi&#x2F;han repeat方法 在Java 11中，还提供了一个repeat方法： String repeated&#x3D;&quot;Java&quot;.repeat(3); &#x2F;&#x2F;repeated is &quot;JavaJavaJava&quot; 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; String huangzihan_repeated&#x3D;&quot;Huangzihan&quot;.repeat(3); &#x2F;&#x2F;repeated is &quot;HuangzihanHuangzihanHuangzihan&quot; System.out.println(huangzihan_repeated); &#125; &#125; 运行结果HuangzihanHuangzihanHuangzihan 不可变字符串修改字符串中某个字符 String类没有提供修改字符串中某个字符的方法。如果希望将greeting的内容修改为“Help!”，不能直接将greeting的最后两个位置的字符修改为’p‘和’!‘。对于C程序员来说，这会让他们茫然无措。如何修改这个字符串呢？在Java中实现这项操作非常容易。可以提取想要保留的子串，再与希望替换的字符拼接： greeting &#x3D; greeting.substring(0,3)+&quot;p!&quot;; 上面这条语句将greeting变量的当前值修改为“Help!”。 由于不能修改Java字符串中的单个字符，所以在Java文档中将String类对象称为是不可变的（immutable），如同数字3永远是数字3一样，字符串“Hello”永远包含字符H、e、l、l和0的代码单元序列。你不能修改这些值，不过，可以修改字符串变量greeting，让它引用另外一个字符串，这就如同可以让原本存放3的数值变量改成存放4一样。 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; String huangzihan_greeting &#x3D;&quot;黄子涵_huangzihan&quot;; huangzihan_greeting &#x3D; huangzihan_greeting.substring(0,3)+&quot;是帅哥!&quot;; System.out.println(huangzihan_greeting); &#125; &#125; 运行结果黄子涵是帅哥! 字符串共享 这样做是否会降低运行效率呢？看起来好像修改一个代码单元要比从头创建一个新字符串更加简洁。答案是：也对，也不对。的确，通过拼接“Hel”和“p!”来创建一个新字符串的效率确实不高。但是，不可变字符串却有一个优点：编译器可以让字符串共享。 为了弄清具体的工作方式，可以想象将各种字符串存放在公共的存储池中。字符串变量指向存储池中相应的位置。如果复制一个字符串变量，原始字符串与复制的字符串共享相同的字符。 总而言之，Java的设计者认为共享带来的高效率远远胜过于提取子串、拼接字符串所带来的低效率。可以看看你自己的程序，我们发现：大多数情况下都不会修改字符串，而只是需要对字符串进行比较（有一种例外情况，将来自于文件或键盘的单个字符或较短的字符串组装成字符串。）。 检测字符串是否相等equals方法 可以使用equals方法检测两个字符串是否相等。对于表达式： s.equals(t) 如果字符串s与字符串t相等，则返回true；否则，返回false。需要注意的是，s与t可以是字符串变量，也可以是字符串字面量。例如，以下表达式是合法的： &quot;Hello&quot;.equals(greeting) 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; String shuaige&#x3D;&quot;是帅哥！&quot;; boolean huangzihan&#x3D;&quot;黄子涵&quot;.equals(shuaige); System.out.println(huangzihan); &#125; &#125; 运行结果false equalsIgnoreCase方法 要想检测两个字符串是否相等，而不区分大小写，可以使用equalsIgnoreCase方法。 &quot;Hello&quot;.equalsIgnoreCase(&quot;hello&quot;) 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; boolean huangzihan; huangzihan&#x3D;&quot;黄子涵&quot;.equalsIgnoreCase(&quot;是帅哥！&quot;); System.out.println(huangzihan); System.out.println(); System.out.println(&quot;你这让我很伤心！&quot;); &#125; &#125; 运行结果false 你这让我很伤心！ 不要使用==检测字符串是否相等 一定不要使用==运算符检测两个字符串是否相等！这个运算符只能够确定两个字符串是否存放在同一个位置上。当然，如果字符串在同一个位置上，它们必然相等。但是，完全有可能将内容相同的多个字符串副本放置在不同的位置上。 可能将内容相同的多个字符串副本放置在不同的位置上。 String greeting &#x3D;&quot;Hello&quot;; &#x2F;&#x2F;initialize greeting to a string if(greeting&#x3D;&#x3D;&quot;Hello&quot;) ... &#x2F;&#x2F;probably true if(greeting.substring(0,3) &#x3D;&#x3D; &quot;Hel&quot;) ... &#x2F;&#x2F;probably false 如果虚拟机始终将相同的字符串共享，就可以使用==运算符检测是否相等。但实际上只有字符串字面量是共享的，而+或substring等操作得到的字符串并不共享。因此，千万不要使用==运算符测试字符串的相等性，以免在程序中出现这种最糟糕的bug，看起来这种bug就像随机产生的间歇性错误。 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; String huangzihan_greeting &#x3D;&quot;黄子涵&quot;; &#x2F;&#x2F;initialize greeting to a string if(huangzihan_greeting&#x3D;&#x3D;&quot;黄子涵&quot;) System.out.println(&quot;黄子涵&quot;); &#x2F;&#x2F;probably true if(huangzihan_greeting.substring(0,2) &#x3D;&#x3D; &quot;黄子涵&quot;) System.out.println(&quot;肯定&quot;); &#x2F;&#x2F;probably false if(huangzihan_greeting.substring(0,3) &#x3D;&#x3D; &quot;黄子涵&quot;) System.out.println(&quot;是帅哥！&quot;); &#x2F;&#x2F;probably false &#125; &#125; 运行结果黄子涵 是帅哥！ 空串与Null串检查字符串是否为空 空串 “ “ 是长度为0的字符串。可以调用以下代码检查一个字符串是否为空： if(str.length() &#x3D;&#x3D; 0) 或 if(str.equals(&quot; &quot;)) 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; String huangzihan&#x3D;&quot;&quot;; if(huangzihan.length() &#x3D;&#x3D; 0) System.out.print(&quot;黄子涵&quot;); if(huangzihan.equals(&quot;&quot;)) System.out.print(&quot;是帅哥！&quot;); &#125; &#125; 运行结果黄子涵是帅哥！ 空串 空串是一个Java对象，有自己的串长度（0）和内容（空）。不过，String变量还可以存放一个特殊的值，名为null，表示目前没有任何对象与该变量关联。要检查一个字符串是否为null，要使用以下条件： 这里不是很懂！！！if(str &#x3D;&#x3D; null) 有时要检查一个字符串既不是null也不是空串，这种情况下就需要使用以下条件： if(str !&#x3D; null &amp;&amp; str.length() !&#x3D;0) 首先要检查str不为null。 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; String huang&#x3D;&quot;huangzihan&quot;; String zihan&#x3D;&quot;&quot;; if(zihan &#x3D;&#x3D; null) &#x2F;&#x2F;这里有问题！！！ System.out.print(&quot;黄子涵&quot;); if(huang !&#x3D; null &amp;&amp; huang.length() !&#x3D;0) System.out.print(&quot;是帅哥！&quot;); &#125; &#125; 运行结果是帅哥！ 码点与代码单元代码单元 Java字符串由char值序列组成。char数据类型是一个采用UTF-16编码表示Unicode码点的代码单元。最常用的Unicode字符使用一个代码单元就可以表示，而辅助字符需要一对代码单元表示。 length方法 length方法将返回采用UTF-16编码表示给定字符串所需要的代码单元数量。例如： String greeting&#x3D;&quot;Hello&quot;; int n&#x3D;greeting.length(); &#x2F;&#x2F;is 5 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; String huangzihan_greeting&#x3D;&quot;黄子涵是帅哥！&quot;; int huangzihan_n&#x3D;huangzihan_greeting.length(); &#x2F;&#x2F;is 5 System.out.println(huangzihan_n); &#125; &#125; 运行结果7 码点数量 要想得到实际的长度，即码点数量，可以调用： int cpCount &#x3D; greeting.codePointCount(0,greeting.length()); 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; String greeting&#x3D;&quot;黄子涵是帅哥！&quot;; int cpCount &#x3D; greeting.codePointCount(0,greeting.length()); System.out.println(cpCount); &#125; &#125; 运行结果7 s.charAt(n) 调用s.charAt(n)将返回位置n的代码单元，n介于0 ~ s.length()-1之间。例如： char first &#x3D; greeting.charAt(0); &#x2F;&#x2F;first is &#39;H&#39; char last &#x3D; greeting.charAt(4); &#x2F;&#x2F;last is &#39;o&#39; 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; String huangzihan_greeting&#x3D;&quot;黄子涵是帅哥！&quot;; char huangzihan_first &#x3D; huangzihan_greeting.charAt(0); &#x2F;&#x2F;first is &#39;H&#39; char huangzihan_last &#x3D; huangzihan_greeting.charAt(6); &#x2F;&#x2F;last is &#39;o&#39; System.out.println(huangzihan_first); System.out.println(huangzihan_last); &#125; &#125; 运行结果黄 ！ 第i个码点（这里不太懂！！！） 要想得到第i个码点，应该使用下列语句 int index &#x3D; greeting.offsetByCodePoints(0,i); int cp &#x3D; greeting.codePointAt(index); 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; String huangzihan_greeting&#x3D;&quot;黄子涵是帅哥！&quot;; int i&#x3D;6; int huangzihan_index &#x3D; huangzihan_greeting.offsetByCodePoints(0,i); System.out.println(huangzihan_index); int huangzihan_cp &#x3D; huangzihan_greeting.codePointAt(huangzihan_index); System.out.println(huangzihan_cp); &#125; &#125; 运行结果6 65281 注释 不要以为可以忽略包含U+FFFF以上代码单元的奇怪字符，喜欢emoji表情符号的用户可能会在字符串中加入类似（U+1F37A，啤酒杯）的字符。 遍历字符串 如果想要遍历一个字符串，并且依次查看每一个码点，可以使用下列语句： int cp &#x3D; sentence.codePointAt(i); if(Character.isSupplementaryCodePoint(cp)) i +&#x3D; 2; else i++; isSupplementaryCodePoint()方法描述确定指定的字符（Unicode码点）是否在补充字符范围内。 参数码点要测试的字符（Unicode码点） 返回值如果指定的代码点介于MIN_SUPPLEMENTARY_CODE_POINT和MAX_CODE_POINT （含）之间，则为true；否则为false。 程序示例 遍历字符串程序示例 运行结果40644 23376 28085 26159 24069 21733 65281 40644 23376 28085 26159 24069 21733 65281 反向遍历 可以使用下列语句实现反向遍历： i--; if(Character.isSurrogate(sentence.charAt(i)))i--; int cp&#x3D;sentence.codePointAt(i); 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; int codePoint0&#x3D;0; int codePoint1&#x3D;1; int codePoint2&#x3D;2; int codePoint3&#x3D;3; int codePoint4&#x3D;4; int codePoint5&#x3D;5; int codePoint6&#x3D;6; String sentence&#x3D;&quot;黄子涵是帅哥！&quot;; int huangzihan_cp0&#x3D;sentence.charAt(codePoint0); int huangzihan_cp1&#x3D;sentence.charAt(codePoint1); int huangzihan_cp2&#x3D;sentence.charAt(codePoint2); int huangzihan_cp3&#x3D;sentence.charAt(codePoint3); int huangzihan_cp4&#x3D;sentence.charAt(codePoint4); int huangzihan_cp5&#x3D;sentence.charAt(codePoint5); int huangzihan_cp6&#x3D;sentence.charAt(codePoint6); System.out.println(huangzihan_cp0); &#x2F;&#x2F;黄的Unicode编码是\\u9ec4，对应的十进制是40644 System.out.println(huangzihan_cp1); &#x2F;&#x2F;子的Unicode编码是\\u5b50，对应的十进制是23376 System.out.println(huangzihan_cp2); &#x2F;&#x2F;涵的Unicode编码是\\u6db5，对应的十进制是28085 System.out.println(huangzihan_cp3); &#x2F;&#x2F;是的Unicode编码是\\u662f，对应的十进制是26159 System.out.println(huangzihan_cp4); &#x2F;&#x2F;帅的Unicode编码是\\u5e05，对应的十进制是24069 System.out.println(huangzihan_cp5); &#x2F;&#x2F;哥的Unicode编码是\\u54e5，对应的十进制是21733 System.out.println(huangzihan_cp6); &#x2F;&#x2F;！的Unicode编码是\\uff01，对应的十进制是65281 System.out.println(); for(int codePoint&#x3D;6;codePoint&gt;0;codePoint--) &#123; int huangzihan&#x3D;sentence.charAt(codePoint); System.out.println(huangzihan); &#125; &#125; &#125; 运行结果40644 23376 28085 26159 24069 21733 65281 65281 21733 24069 26159 28085 23376 isSurrogate()方法描述确定给定的字符值是否是Unicode代理代码单元。 这些值本身并不表示字符，而是用于表示UTF-16编码中的补充字符。 字符值是代理代码单元当且仅当它是低代理代码单元还是高代理代码单元时。 参数ch要测试的char值 返回值如果char值介于MIN_SURROGATE和MAX_SURROGATE之间，则返回true；否则为false。 codePoints方法 显然，这很麻烦。更容易的办法是使用codePoints方法，它会生成一个int值的“流”，每个int值对应一个码点。可以将它转换为一个数组，再完成遍历。 int[] codePoints &#x3D; str.codePoints().toArray(); 程序示例import java.util.stream.IntStream; public class HuangZiHanTest &#123; public static void main(String[] args) &#123; String huangzihan&#x3D;&quot;黄子涵是帅哥！&quot;; IntStream huangzihanCodePoints&#x3D;huangzihan.codePoints(); int[] huangzihzanToArray &#x3D; huangzihan.codePoints().toArray(); System.out.println(huangzihanCodePoints); System.out.println(huangzihzanToArray); &#125; &#125; 运行结果java.util.stream.IntPipeline$Head@1fb3ebeb [I@548c4f57 码点数组转换为字符串 反之，要把一个码点数组转换为一个字符串，可以使用构造器。 String str&#x3D;new String(codePoints,0,codePoints.length); 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; char[] huangzihanCodePoints &#x3D;&#123;&#39;黄&#39;,&#39;子&#39;,&#39;涵&#39;,&#39;是&#39;,&#39;帅&#39;,&#39;哥&#39;,&#39;！&#39;&#125;; String huangzihan&#x3D;new String(huangzihanCodePoints,0,huangzihanCodePoints.length); System.out.println(huangzihan); &#125; &#125; 运行结果黄子涵是帅哥！ 注释 虚拟机不一定把字符串实现为代码单元序列。在Java 9中，只包含单字节代码单元的字符串使用byte数组实现，所有其他字符串使用char数组。 String API Java中的String类包含了50多个方法。令人惊讶的是它们绝大多数都很有用，可以想见使用的频率非常高。下面的API注释汇总了一部分最常用的方法。 本书中给出的API注释可以帮助你理解Java应用编程接口（API）。每一个API的注释都以类名开始，如java.lang.String。类名之后是一个或多个方法的名字、解释和参数描述。 在这里，一般不列出某个类的所有方法，而是选择一些最常用的方法，并以简洁的方式给予描述。完整的方法列表请参看联机文档。 这里还会列出所介绍的类的版本号。如果某个方法是在这个版本之后添加的，就会给出一个单独的版本号。 阅读联机API文档 正如前面所看到的，String类包含许多方法。而且，在标准库中有几千个类，方法数量更加惊人。要想记住所有的类和方法是一件不太不可能的事情。因此，学会使用联机API文档十分重要，从中可以查阅标准类库中的所有类和方法。可以从Oracle下载API文档，并保存在本地。也可以在浏览器中访问https://docs.oracle.com/javase/10/docs/api/overview-summary.html。 在Java 10中，API文档有一个搜索框（见图（Java API文档））。较老的版本则有一些窗框，分别包含包列表和类列表。仍然可以点击Frames菜单项得到这些列表。例如，要获得有关String类方法的更多信息，可以在搜索框中键入“String”，选择类型java.lang.String，或者在窗框中找到String链接，然后点击这个链接。你会看到这个类的描述，如图（String类的描述）所示。 Java API文档 String类的描述 接下来，向下滚动，直到看见按字母顺序排列的所有方法的小结（请参看图（String类方法的小结））。点击任何一个方法名便可以查看这个方法的详细描述（参见图（一个String方法的详细描述））。例如，如果点击compare TolgnoreCase链接，就会看到compareToIgnoreCase方法的描述。 String类方法的小结 一个String方法的详细描述 构建字符串 有些时候，需要由较短的字符串构建字符串，例如，按键或来自文件中的单词。如果采用字符串拼接的方式来达到这个目的，效率会比较低。每次拼接字符串时，都会构建一个新的String对象，既耗时，又浪费空间。使用StringBuilder类就可以避免这个问题的发生。 构建空字符串构建器 如果需要用许多小段的字符串来构建一个字符串，那么应该按照下列步骤进行。首先，构建一个空的字符串构建器： StringBuilder builder &#x3D; new StringBuilder(); append方法 当每次需要添加一部分内容时，就调用append方法。 builder.append(ch); &#x2F;&#x2F;appends a single character builder.append(str); &#x2F;&#x2F;appends a string toString方法 在字符串构建完成时就调用toString方法，将可以得到一个String对象，其中包含了构建器中的字符序列。 String completedString &#x3D; builder.toString(); 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; StringBuilder HuangzihaBuilder&#x3D;new StringBuilder(); char HuangzihanCharY&#x3D;&#39;Y&#39;; char HuangzihanCharE&#x3D;&#39;E&#39;; char HuangzihanCharS&#x3D;&#39;S&#39;; char HuangzihanChar&#x3D;&#39;!&#39;; String HuangzihanString&#x3D;&quot;黄子涵是帅哥！&quot;; HuangzihaBuilder.append(HuangzihanCharY); HuangzihaBuilder.append(HuangzihanCharE); HuangzihaBuilder.append(HuangzihanCharS); HuangzihaBuilder.append(HuangzihanChar); HuangzihaBuilder.append(HuangzihanString); String HuangzihanToString&#x3D;HuangzihaBuilder.toString(); System.out.println(HuangzihanToString); &#125; &#125; 运行结果YES!黄子涵是帅哥！ 注释 StringBuilder类在Java 5中引入。这个类的前身是StringBuffer，它的效率稍有些低，但允许采用多线程的方式添加或删除字符。如果所有字符串编辑操作都在单个线程中执行（通常都是这样），则应该使用StringBuilder。这两个类的API是一样的。","path":"2021/07/07/字符串/","date":"07-07","excerpt":"字符串String 从概念上讲，Java字符串就是Unicode字符序列。例如，字符串”Java\\u2122”由5个Unicode字符J、a、v、a和™组成。Java没有内置的字符串类型，而是在标准Java类库中提供了一个预定义类，很自然地叫做String。每个用双引号括起来的字符串都是String类的一个实例： String e&#x3D;&quot; &quot;; &#x2F;&#x2F;an empty string String greeting&#x3D;&quot;Hello&quot;; 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; String huangzihan_e&#x3D;&quot; &quot;; &#x2F;&#x2F;an empty string String huangzihan_greeting&#x3D;&quot;huangzihan_Hello&quot;; System.out.println(huangzihan_e); System.out.println(huangzihan_greeting); System.out.println(&quot;Java\\u2122&quot;); &#125; &#125; 运行结果 huangzihan_Hello Java™","tags":[{"name":"字符串","slug":"字符串","permalink":"http://www.huangzihan.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"Java","slug":"Java","permalink":"http://www.huangzihan.top/tags/Java/"},{"name":"String","slug":"String","permalink":"http://www.huangzihan.top/tags/String/"},{"name":"substring方法","slug":"substring方法","permalink":"http://www.huangzihan.top/tags/substring%E6%96%B9%E6%B3%95/"},{"name":"equals方法","slug":"equals方法","permalink":"http://www.huangzihan.top/tags/equals%E6%96%B9%E6%B3%95/"}]},{"title":"输入与输出","text":"输入与输出读取输入Scanner对象 将输出打印到“标准输出流”（即控制台窗口）是一件非常容易的事情，只要调用System.out.println即可。然而，读取“标准输入流”System.in就没有那么简单了。要想通过控制台进行输入，首先需要构造一个与“标准输入流”System.in关联的Scanner对象。 Scanner in &#x3D; new Scanner(System.in); nextline方法 现在，就可以使用Scanner类的各种方法读取输入了。例如，nextline方法将读取一行输入。 System.out.print(&quot;What is your name?&quot;); String name &#x3D; in.nextline(); next方法 在这里，使用nextLine方法是因为在输入行中有可能包含空格。要想读取一个单词（以空白符作为分隔符），可以调用 String firstName &#x3D; in.next(); nextInt方法 要想读取一个整数，就调用nextInt方法。 System.out.print(&quot;How old are you?&quot;); int age &#x3D; in.nextInt(); nextDouble方法 与此类似，要想读取下一个浮点数，就调用nextDouble方法。 最后，在程序的最前面添加一行代码： import java.util.*; Scanner类定义在java.util包中。当使用的类不是定义在基本java.lang包中时，一定要使用import指令导入相应的包。 注释 因为输入是可见的，所以Scanner类不适用于从控制台读取密码。Java 6特别引入了Console类来实现这个目的。要想读取一个密码，可以使用下列代码： Console cons &#x3D; System.console(); String username &#x3D; cons.readLine(&quot;User name:&quot;); char[] passwd &#x3D; cons.readPassword(&quot;Password:&quot;); 为安全起见，返回的密码存放在一个字符数组中，而不是字符串中。在对密码处理完成之后，应该马上用一个填充值覆盖数组元素。 采用Console对象处理输入不如采用Scanner方便。必须每次读取一行输入，而没有能够读取单个单词或数值的方法。 程序示例import java .util.*; public class HuangZiHanTest &#123; public static void main(String[] args) &#123; Scanner huangzihan_in&#x3D;new Scanner(System.in); System.out.println(&quot;你叫什么名字？&quot;); String huangzihan_name&#x3D;huangzihan_in.nextLine(); System.out.println(&quot;你今年几岁？&quot;); int huangzihan_age&#x3D;huangzihan_in.nextInt(); System.out.println(&quot;你多高？（m）&quot;); double huangzihan_tall&#x3D;huangzihan_in.nextDouble(); System.out.println(&quot;你好，&quot;+huangzihan_name+&quot;，今年你&quot;+huangzihan_age+&quot;岁，身高&quot;+huangzihan_tall+&quot;m。&quot;); &#125; &#125; 运行结果你叫什么名字？ 黄子涵 你今年几岁？ 27 你多高？（m） 1.77 你好，黄子涵，今年你27岁，身高1.77m。 格式化输出Systen.out.print(x) 可以使用语句Systen.out.print(x)将数值x输出到控制台。这条命令将以x的类型所允许的最大非0数位个数打印输出x。例如： double x &#x3D; 10000.0&#x2F;3.0; System.out.print(x); 打印 3333.3333333333335 如果希望显示美元、美分数，这就会有问题。 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; double huangzihan_x &#x3D; 10000.0&#x2F;3.0; System.out.print(huangzihan_x); &#125; &#125; 运行结果3333.3333333333335 printf方法 在早期的Java版本中，格式化数值曾引起过一些争议。庆幸的是，Java 5沿用了C语言函数库中的printf方法。例如，调用 System.out.printf(&quot;%8.2f&quot;,x); 会以一个字段宽度（fieldwidth）打印x：这包括8个字符，另外精度为小数点后2个字符。也就是说，这会打印一个前导的空格和7个字符，如下所示： 3333.33 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; double huangzihan_x &#x3D; 10000.0&#x2F;3.0; System.out.println(huangzihan_x); System.out.println(); System.out.printf(&quot;%8.2f&quot;,huangzihan_x); &#125; &#125; 运行结果3333.3333333333335 3333.33 printf提供多个参数 可以为printf提供多个参数，例如： System.out.printf(&quot;Hello,%s,Next year,you&#39;ll be %d&quot;,name,age); 每一个以%字符开始的格式说明符都用相应的参数替换。格式说明符尾部的转换符指示要格式化的数值的类型：f表示浮点数，s表示字符串，d表示十进制整数。表（用于printf的转换符）列出了所有转换符。 程序示例import java .util.*; public class HuangZiHanTest &#123; public static void main(String[] args) &#123; Scanner huangzihan_in&#x3D;new Scanner(System.in); System.out.println(&quot;你叫什么名字？&quot;); String huangzihan_name&#x3D;huangzihan_in.nextLine(); System.out.println(&quot;你今年几岁？&quot;); int huangzihan_age&#x3D;huangzihan_in.nextInt(); System.out.println(&quot;你多高？（m）&quot;); double huangzihan_tall&#x3D;huangzihan_in.nextDouble(); System.out.println(&quot;你好，&quot;+huangzihan_name+&quot;，今年你&quot;+huangzihan_age+&quot;岁，身高&quot;+huangzihan_tall+&quot;m。&quot;); System.out.printf(&quot;你好,%s,今年,你%d岁啦！&quot;,huangzihan_name,huangzihan_age); &#125; &#125; 运行结果你叫什么名字？ 黄子涵 你今年几岁？ 27 你多高？（m） 1.77 你好，黄子涵，今年你27岁，身高1.77m。 你好,黄子涵,今年,你27岁啦！ 用于printf的转换符 转换符 类型 示例 d 十进制整数 159 x 十六进制整数 9f o 八进制整数 237 f 定点浮点数 15.9 e 指数浮点数 1.59e+01 g 通用浮点数（e和f中较短的一个） - a 十六进制浮点数 0x1.fccdp3 s 字符串 Hello c 字符 H b 布尔 true h 散列码 42628b2 tx或Tx 日期时间（T强制大写） 已经过时 % 百分号 % n 与平台有关的行分隔符 - 用于printf的标志 另外，还可以指定控制格式化输出外观的各种标志。表（用于printf的标志）列出了所有的标志。例如，逗号标志可以增加分组分隔符。即 System.out.printf(&quot;%,.2f&quot;,10000.0&#x2F;3.0); 会打印 3,333.33 可以使用多个标志，例如，”%,(.2f”会使用分组分隔符并将负数括在括号内。 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; double huangzihan_x &#x3D; 10000.0&#x2F;3.0; System.out.println(huangzihan_x); System.out.println(); System.out.printf(&quot;%8.2f&quot;,huangzihan_x); System.out.println(); System.out.printf(&quot;%,.2f&quot;,10000.0&#x2F;3.0); &#125; &#125; 运行结果3333.3333333333335 3333.33 3,333.33 用于printf的标志 用于printf的标志 注释String.format方法 可以使用s转换符格式化任意的对象。对于实现了Formattable接口的任意对象，将调用这个对象的formatTo方法；否则调用toString方法将这个对象转换为字符串。 可以使用静态的String.format方法创建一个格式化的字符串，而不打印输出： String message &#x3D; String.format(&quot;Hello,%s.Next year,you&#39;ll be %d&quot;,name,age); 基于完整性的考虑，下面简略地介绍printf方法中日期与时间的格式化选项。不过你可能会在遗留代码中看到Date类和相关的格式化选项。这个格式包括两个字母，以t开始，以表（日期和时间的转换符）中的任意字母结束。 程序示例import java .util.*; public class HuangZiHanTest &#123; public static void main(String[] args) &#123; Scanner huangzihan_in&#x3D;new Scanner(System.in); System.out.println(&quot;你叫什么名字？&quot;); String huangzihan_name&#x3D;huangzihan_in.nextLine(); System.out.println(&quot;你今年几岁？&quot;); int huangzihan_age&#x3D;huangzihan_in.nextInt(); System.out.println(&quot;你多高？（m）&quot;); double huangzihan_tall&#x3D;huangzihan_in.nextDouble(); System.out.println(&quot;你好，&quot;+huangzihan_name+&quot;，今年你&quot;+huangzihan_age+&quot;岁，身高&quot;+huangzihan_tall+&quot;m。&quot;); System.out.printf(&quot;你好,%s,今年,你%d岁啦！&quot;,huangzihan_name,huangzihan_age); System.out.println(); String huangzihan_message &#x3D; String.format(&quot;你好,%s.今年,你%d岁啦！&quot;,huangzihan_name,huangzihan_age); System.out.println(huangzihan_message); &#125; &#125; 运行结果你叫什么名字？ 黄子涵 你今年几岁？ 27 你多高？（m） 1.77 你好，黄子涵，今年你27岁，身高1.77m。 你好,黄子涵,今年,你27岁啦！ 你好,黄子涵.今年,你27岁啦！ 打印当前的日期和时间 例如， System.out.printf(&quot;%tc&quot;,new Date()); 这条语句将用下面的格式打印当前的日期和时间： Mon Feb 09 18:05:19 PST 2015 程序示例import java.util.Date; public class HuangZiHanTest &#123; public static void main(String[] args) &#123; System.out.printf(&quot;%tc&quot;,new Date()); &#125; &#125; 运行结果周六 7月 03 16:58:14 CST 2021 日期和时间的转换符 日期和时间的转换符一 日期和时间的转换符二 日期和时间的转换符三 索引 从表（日期和时间的转换符）可以看到，某些格式只给出了指定日期的部分信息。例如，只有日期或月份。如果需要多次提供日期来分别格式化每一部分就太笨拙了。为此，可以用一个格式字符串指示要格式化的参数索引。索引必须紧跟在%后面，并以$终止。例如， System.out.printf(&quot;%1$s %2$tB %2$te,%2$tY&quot;,&quot;Due date:&quot;,new Date()); 会打印 Due date:February 9,2015 还可以选择使用&lt;标志。它指示前面格式说明中的参数将被再次使用。也就是说，以下语句将产生与前面语句同样的输出结果： 参数索引程序示例二 警告：参数索引值从1开始，而不是从0开始，%1$…对第1个参数格式化。这就避免了与0标志混淆。 程序示例 参数索引程序示例一 运行结果截止日期: 七月 3,2021 截止日期: 七月 3,2021 现在，我们已经了解了printf方法的所有特性。图（格式说明符）给出了格式说明符的语法图。 格式说明符 注释 数字和日期的格式化规则是特定于本地化环境的。例如，在德国，分组分隔符是点号而不是逗号，另外Monday被格式化为Montag。 文件输入与输出读取文件 要想读取一个文件，需要构造一个Scanner对象，如下所示： Scanner in &#x3D;new Scanner(Path.of(&quot;myfile.txt&quot;),StandardCharsets.UTF_8); 如果文件名中包含反斜杠符号，就要记住在每个反斜杠之前再加一个额外的反斜杠转义： &quot;c:\\\\mydirectory\\myfile.txt&quot; 注释 在这里指定了UTF-8字符编码，这对于互联网上的文件很常见（不过并不是普遍适用）。读取一个文本文件时，要知道它的字符编码。如果省略字符编码，则会使用运行这个Java程序的机器的“默认编码”。这不是一个好主意，如果在不同的机器上运行这个程序，可能会有不同的表现。 现在，就可以利用前面介绍的任何一个Scanner方法对文件进行读取。 Printwriter对象 要想写入文件，就需要构造一个Printwriter对象。在构造器（constructor）中，需要提供文件名和字符编码： PrintWriter out &#x3D; new PrintWriter(&quot;myfile.txt&quot;,StandardCharsets.UTF_8); 如果文件不存在，创建该文件。可以像输出到System.out一样使用print、println以及printf命令。 警告 可以构造一个带有字符串参数的Scanner，但这个Scanner会把字符串解释为数据，而不是文件名。例如，如果调用： Scanner in &#x3D; new Scanner(&quot;myfile.txt&quot;); &#x2F;&#x2F;ERROR？ 这个scanner会将参数看作包含10个字符（’m’、’y’、’f’等）的数据。 注释 当指定一个相对文件名时，例如，”myfile.txt””mydirectory/myfile.txt”或”../myfile.txt”，文件位于相对于Java虚拟机启动目录的位置。如果在命令行方式下执行以下命令启动程序： java MyProg 启动目录就是命令解释器的当前目录。然而，如果使用集成开发环境，那么启动目录将由IDE控制。可以使用下面的调用找到这个目录的位置： String dir&#x3D;System.getProperty(&quot;user.dir&quot;); 如果觉得定位文件太麻烦，可以考虑使用绝对路径名，例如： &quot;C:\\\\mydirectory\\\\myfile.txt&quot; 或者 &quot;&#x2F;home&#x2F;me&#x2F;mydirectory&#x2F;myfile.txt&quot; 正如读者所看到的，访问文件与使用System.in和System.out一样容易。要记住一点：如果用一个不存在的文件构造一个Scanner，或者用一个无法创建的文件名构造PrintWriter，就会产生异常。Java编译器认为这些异常比“被零除”异常更严重。至于现在，只需要告诉编译器：你已经知道有可能出现“输入/输出”异常。这需要在main方法中用throws子句标记，如下所示： public static void main(String[] args) throws IOException &#123; Scanner in&#x3D;new Scanner(Path.of(&quot;myfile.txt&quot;),StandardCharsets.UTF_8); ... &#125; &#96;&#96;&#96; ### 注释 &gt; 当采用命令行方式启动一个程序时，可以利用shell的重定向语法将任意文件关联到**System.in**和**System.out**： &#96;&#96;&#96;C&#x2F;C++ java MyProg &lt;myfile.txt&gt; output.txt 这样，就不必担心处理IOException异常了。","path":"2021/07/03/输入与输出/","date":"07-03","excerpt":"输入与输出读取输入Scanner对象 将输出打印到“标准输出流”（即控制台窗口）是一件非常容易的事情，只要调用System.out.println即可。然而，读取“标准输入流”System.in就没有那么简单了。要想通过控制台进行输入，首先需要构造一个与“标准输入流”System.in关联的Scanner对象。 Scanner in &#x3D; new Scanner(System.in); nextline方法 现在，就可以使用Scanner类的各种方法读取输入了。例如，nextline方法将读取一行输入。 System.out.print(&quot;What is your name?&quot;); String name &#x3D; in.nextline(); next方法 在这里，使用nextLine方法是因为在输入行中有可能包含空格。要想读取一个单词（以空白符作为分隔符），可以调用 String firstName &#x3D; in.next();","tags":[]},{"title":"运算符","text":"运算符 运算符用于连接值。 算术运算符四则运算 在Java中，使用算术运算符+、一、*、/表示加、减、乘、除运算。当参与/运算的两个操作数都是整数时，表示整数除法；否则，表示浮点除法。整数的求余操作（有时称为取模）用%表示。例如，15/2等于7，15%2等于1，15.0/2等于7.5。需要注意，整数被0除将会产生一个异常，而浮点数被0除将会得到无穷大或NaN结果。 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; System.out.println(15&#x2F;2); System.out.println(15%2); System.out.println(15.0&#x2F;2); &#125; &#125; 运行结果7 1 7.5 整数除0程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; System.out.println(1&#x2F;0); &#125; &#125; 运行结果Exception in thread &quot;main&quot; java.lang.ArithmeticException: &#x2F; by zero at HuangZiHanTest.main(HuangZiHanTest.java:8) 浮点数被0除程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; System.out.println(1.0&#x2F;0); &#125; &#125; 运行结果Infinity 注释 可移植性是Java语言的设计目标之一。无论在哪个虚拟机上运行，同一运算应该得到同样的结果。对于浮点数的算术运算，实现这样的可移植性是相当困难的。double类型使用64位存储一个数值，而有些处理器则使用80位浮点寄存器。这些寄存器增加了中间过程的计算精度。例如，以下运算： double w&#x3D;x*y&#x2F;z; 很多Intel处理器计算x×y，并且将结果存储在80位的寄存器中，再除以z并将结果截断为64位。这样可以得到一个更加精确的计算结果，并且还能够避免产生指数溢出。但是，这个结果可能与始终使用64位计算的结果不一样。因此，Java虚拟机的最初规范规定所有的中间计算都必须进行截断。这种做法遭到了数字社区的反对。截断计算不仅可能导致溢出，而且由于截断操作需要消耗时间，所以在计算速度上实际上要比精确计算慢。为此，Java程序设计语言承认了最优性能与理想的可再生性之间存在的冲突，并给予了改进。在默认情况下，现在虚拟机设计者允许对中间计算结果采用扩展的精度。但是，对于使用strictfp关键字标记的方法必须使用严格的浮点计算来生成可再生的结果。 例如，可以把main方法标记为 public static **strictfp** void main(String[] args) 那么，main方法中的所有指令都将使用严格的浮点计算。如果将一个类标记为strictfp，这个类中的所有方法都要使用严格的浮点计算。 具体的计算细节取决于Intel处理器的行为。在默认情况下，中间结果允许使用扩展的指数，但不允许使用扩展的尾数（Intel芯片支持截断尾数时并不损失性能）。因此，这两种方式的区别仅仅是采用默认方式不会产生溢出，而采用严格的计算有可能产生溢出。 数学函数与常量 在Math类中，包含了各种各样的数学函数。在编写不同类别的程序时，可能需要的函数也不同。 sqrt方法 要想计算一个数值的平方根，可以使用sqrt方法： double x&#x3D;4; double y&#x3D;Math.sqrt(x); System.out.println(y); &#x2F;&#x2F;prints 2.0 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; double huangzihan_x&#x3D;4; double huangzihan_y&#x3D;Math.sqrt(huangzihan_x); System.out.println(huangzihan_y); &#x2F;&#x2F;prints 2.0 &#125; &#125; 运行结果2.0 注释静态方法 println方法和sqrt方法存在微小的差异。println方法处理System.out对象。但是，Math类中的sqrt方法并不处理任何对象，这样的方法被称为静态方法。 幂运算 在Java中，没有幂运算，因此需要借助于Math类的pow方法。以下语句： double y&#x3D;Math.pow(x,a); 将y的值设置为x的a次幂（xe）。pow方法有两个double类型的参数，其返回结果也为double类型。 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; double huangzihan_x&#x3D;2.0; double huangzihan_a&#x3D;3.0; double huangzihan_y&#x3D;Math.pow(huangzihan_x,huangzihan_a); System.out.println(huangzihan_y); &#125; &#125; 运行结果8.0 floorMod方法 floorMod方法的目的是解决一个长期存在的有关整数余数的问题。考虑表达式n%2。所有人都知道，如果n是偶数，这个表达式为0；如果n是奇数，表达式则为1。当然，除非n是负数。如果n为负，这个表达式则为-1。为什么呢？设计最早的计算机时，必须有人制定规则，明确整数除法和求余对负数操作数该如何处理。数学家们几百年来都知道这样一个最优（或称“欧几里得”）规则：余数总是要≥0。不过，最早制定规则的人并没有翻开数学书好好研究，而是提出了一些看似合理但实际上很不方便的规则。 下面考虑这样一个问题：计算一个时钟时针的位置。这里要做一个时间调整，而且要归一化为一个0 ~ 11之间的数。这很简单：(position + adjustment)%12。不过，如果这个调整为负会怎么样呢？你可能会得到一个负数。所以要引入一个分支，或者使用((position +adjustment)%12+12)%12。不管怎样都很麻烦。 floorMod方法就让这个问题变得容易了：floorMod(position+adjustment,12)总会得到一个0 ~ 11之间的数。（遗憾的是，对于负除数，floorMod会得到负数结果，不过这种情况在实际中很少出现。） Math类 Math类提供了一些常用的三角函数： Math.sin Math.cos Math.tan Math.atan Math.atan2 还有指数函数以及它的反函数——自然对数以及以10为底的对数： Math.exp Math.log Math.log10 最后，Java还提供了两个用于表示π和e常量的最接近的近似值： Math.PI Math.E 提示 不必在数学方法名和常量名前添加前缀“Math”，只要在源文件的顶部加上下面这行代码就可以了。 import static java.lang.Math.*; 例如： System.out.println(&quot;The square root of\\u03c0 is&quot;+sqrt(PI)); 程序示例import static java.lang.Math.*; public class HuangZiHanTest &#123; public static void main(String[] args) &#123; System.out.println(&quot;平方根\\u03c0为：&quot;+sqrt(PI)); &#125; &#125; 运行结果平方根π为：1.7724538509055159 注释 在Math类中，为了达到最佳的性能，所有的方法都使用计算机浮点单元中的例程。如果得到一个完全可预测的结果比运行速度更重要的话，那么就应该使用StrictMath类。它实现了“可自由分发的数学库（Freely Distributable Math Library，FDLIBM）”的算法（www.netlib.org/fdlibm），确保在所有平台上得到相同的结果。 注释 Math类提供了一些方法使整数有更好的运算安全性。如果一个计算溢出，数学运算符只是悄悄地返回错误的结果而不做任何提醒。例如，10亿乘以3（1000000000*3）的计算结果将是-1294967296，因为最大的int值也只是刚刚超过20亿。不过，如果调用Math.multiplyExact(1000000000,3)，就会生成一个异常。你可以捕获这个异常或者让程序终止，而不是允许它给出一个错误的结果然后悄无声息地继续运行。另外还有一些方法（addExact、subtractExact、incrementExact、decrementExact和negateExact）也可以正确地处理int和long参数。 数值类型之间的转换数值类型之间的合法转换 我们经常需要将一种数值类型转换为另一种数值类型。图（数值类型之间的合法转换）给出了数值类型之间的合法转换。 数值类型之间的合法转换 在图（数值类型之间的合法转换）中有6个实线箭头，表示无信息丢失的转换；另外有3个虚线箭头，表示可能有精度损失的转换。例如，123456789是一个大整数，它所包含的位数比float类型所能够表示的位数多。当将这个整数转换为float类型时，将会得到正确的大小，但是会损失一些精度。 int n&#x3D;123456789; float f&#x3D;n; &#x2F;&#x2F;f is 1.23456792E8 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; int huangzihan_n&#x3D;123456789; float huangzihan_f&#x3D;huangzihan_n; &#x2F;&#x2F;f is 1.23456792E8 System.out.println(huangzihan_f); &#125; &#125; 运行结果1.23456792E8 二元运算符连接两个值 当用一个二元运算符连接两个值时（例如n+f，n是整数，f是浮点数），先要将两个操作数转换为同一种类型，然后再进行计算。 如果两个操作数中有一个是double类型，另一个操作数就会转换为double类型。 否则，如果其中一个操作数是float类型，另一个操作数将会转换为float类型。 否则，如果其中一个操作数是long类型，另一个操作数将会转换为long类型。 否则，两个操作数都将被转换为int类型。 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; int huangzihan_i&#x3D;123; float huangzihan_f&#x3D;12; double huangzihan_d&#x3D;12.34; long huangzihan_l&#x3D;1234; System.out.println(huangzihan_i+huangzihan_d); System.out.println(huangzihan_i+huangzihan_f); System.out.println(huangzihan_i+huangzihan_l); System.out.println(huangzihan_i+huangzihan_i); &#125; &#125; 运行结果135.34 135.0 1357 246 强制类型转换强制类型转换的例子 int类型的值将会自动地转换为double类型。但另一方面，有时也需要将double转换成int。在Java中，允许进行这种数值之间的类型转换，当然，有可能会丢失一些信息。这种可能损失信息的转换要通过强制类型转换（cast）来完成。强制类型转换的语法格式是在圆括号中给出想要转换的目标类型，后面紧跟待转换的变量名。例如： double x&#x3D;9.997; int nx&#x3D;(int) x; 这样，变量nx的值为9，因为强制类型转换通过截断小数部分将浮点值转换为整型。 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; double huangzihan_x&#x3D;9.997; int huangzihan_y&#x3D;(int) huangzihan_x; System.out.println(huangzihan_y); &#125; &#125; 运行结果9 浮点数舍入运算 如果想对浮点数进行舍入运算，以便得到最接近的整数（在很多情况下，这种操作更有用），那就需要使用Math.round方法： double x&#x3D;9.997; int nx&#x3D;(int) Math.round(x); 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; double huangzihan_z&#x3D;9.997; int huangzihan_x&#x3D;(int) Math.round(huangzihan_z); long huangzihan_y&#x3D;Math.round(huangzihan_z); System.out.println(huangzihan_x); System.out.println(huangzihan_y); &#125; &#125; 运行结果10 现在，变量nx的值为10。当调用round的时候，仍然需要使用强制类型转换（int）。其原因是round方法返回的结果为long类型，由于存在信息丢失的可能性，所以只有使用显式的强制类型转换才能够将long类型转换成int类型。 警告 如果试图将一个数值从一种类型强制转换为另一种类型，而又超出了目标类型的表示范围，结果就会截断成一个完全不同的值。例如，(byte)300的实际值为44。 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; int huangzihan&#x3D;(byte)300; System.out.println(huangzihan); &#125; &#125; 运行结果44 结合赋值和运算符 可以在赋值中使用二元运算符，这是一种很方便的简写形式。例如， x +&#x3D; 4; 等价于： x &#x3D; x + 4; （一般来说，要把运算符放在=号左边，如*=或%=）。 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; int huangzihan_x&#x3D;4; huangzihan_x+&#x3D;4; System.out.println(huangzihan_x); int huangzihan_y&#x3D;4; huangzihan_y&#x3D;huangzihan_y+4; System.out.println(huangzihan_y); &#125; &#125; 运行结果8 8 注释 如果运算符得到一个值，其类型与左侧操作数的类型不同，就会发生强制类型转换。例如，如果x是一个int，则以下语句 x +&#x3D; 3.5; 是合法的，将把x设置为(int)(x+3.5)。 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; int huangzihan_x&#x3D;4; huangzihan_x +&#x3D; 3.5; System.out.println(huangzihan_x); int huangzihan_y&#x3D;4; huangzihan_y +&#x3D; 3.5; System.out.println(huangzihan_y); &#125; &#125; 运行结果7 7 自增与自减运算符 当然，程序员都知道加1、减1是数值变量最常见的操作。在Java中，借鉴了C和C++中的做法，也提供了自增、自减运算符：n++将变量n的当前值加1，n—则将n的值减1。例如，以下代码： int n&#x3D;12; n++; 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; int huangzihan_n&#x3D;12; huangzihan_n++; System.out.println(huangzihan_n); &#125; &#125; 运行结果13 将n的值改为13。由于这些运算符改变的是变量的值，所以它们不能应用于数值本身。例如，4++就不是一个合法的语句。 前后缀形式 实际上，这些运算符有两种形式；上面介绍的是运算符放在操作数后面的“后缀”形式。还有一种“前缀”形式：++n。后缀和前缀形式都会使变量值加1或减1。但用在表达式中时，二者就有区别了。前缀形式会先完成加1；而后缀形式会使用变量原来的值。 int m&#x3D;7; int n&#x3D;7; int a&#x3D;2 * ++m; &#x2F;&#x2F;now a is 16，m is 8 int b&#x3D;2 * n++; &#x2F;&#x2F;now b is 14，n is 8 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; int huangzihan_m&#x3D;7; int huangzihan_n&#x3D;7; int huangzihan_a&#x3D;2 * ++huangzihan_m; &#x2F;&#x2F;now huangzihan_a is 16，huangzihan_m is 8 int huangzihan_b&#x3D;2 * huangzihan_n++; &#x2F;&#x2F;now huangzihan_b is 14，huangzihan_n is 8 System.out.println(huangzihan_a); System.out.println(huangzihan_b); &#125; &#125; 运行结果16 14 建议不要在表达式中使用++，因为这样的代码很容易让人困惑，而且会带来烦人的bug。 关系和boolean运算符检测相等性 Java包含丰富的关系运算符。要检测相等性，可以使用两个等号==。例如， 3&#x3D;&#x3D;7 的值为false。 另外可以使用!=检测不相等。例如， 3!&#x3D;7 的值为true。 最后，还有经常使用的&lt;（小于）、&gt;（大于）、&lt;=（小于等于）和&gt;=（大于等于）运算符。 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; System.out.println(3&#x3D;&#x3D;7); System.out.println(3!&#x3D;7); &#125; &#125; 运行结果false true &amp;&amp;运算符 Java沿用了C++的做法，使用&amp;&amp;表示逻辑“与”运算符，使用||表示逻辑“或”运算符。从!=运算符可以想到，感叹号!就是逻辑非运算符。&amp;&amp;和||运算符是按照“短路”方式来求值的：如果第一个操作数已经能够确定表达式的值，第二个操作数就不必计算了。如果用&amp;&amp;运算符合并两个表达式， expression1 &amp;&amp; expression2 而且已经计算得到第一个表达式的真值为false，那么结果就不可能为true。因此，第二个表达式就不必计算了。可以利用这一点来避免错误。例如，在下面的表达式中： x !&#x3D; 0 &amp;&amp; 1&#x2F;x &gt; x+y &#x2F;&#x2F;no division by 0 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; int huangzihan_x&#x3D;1; int huangzihan_y&#x3D;2; boolean huangzihan_z; huangzihan_z&#x3D;huangzihan_x !&#x3D; 0 &amp;&amp; 1&#x2F;huangzihan_x &gt; huangzihan_x+huangzihan_y; &#x2F;&#x2F;no division by 0 System.out.println(huangzihan_z); &#125; &#125; 运行结果false 如果x等于0，那么第二部分就不会计算。因此，如果x为0，也就不会计算1/x，除以0的错误就不会出现。 类似地，如果第一个表达式为true，expression1||expression2的值就自动为true，而无须计算第二个表达式。 三元操作符?: 最后一点，Java支持三元操作符?:，这个操作符有时很有用。如果条件为true，下面的表达式 condition?expression1:expression2 就为第一个表达式的值，否则计算为第二个表达式的值。例如， 三元操作符 会返回x和y中较小的一个。 程序示例 三元运算符程序示例 运行结果1 位运算符掩码技术 处理整型类型时，可以直接对组成整数的各个位完成操作。这意味着可以使用掩码技术得到整数中的各个位。位运算符包括： 位运算符 这些运算符按位模式处理。例如，如果n是一个整数变量，而且用二进制表示的n从右边数第4位为1，则 int fourthBitFromRight&#x3D;(n&amp;0b1000)&#x2F;0b1000; 会返回1，否则返回0。利用&amp;并结合使用适当的2的幂，可以把其他位掩掉，而只留下其中的某一位。 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; int huangzihan_n&#x3D;1; System.out.println(huangzihan_n&amp;0b1000); int fourthBitFromRight&#x3D;(huangzihan_n&amp;0b1000)&#x2F;0b1000; System.out.println(fourthBitFromRight); &#125; &#125; 运行结果0 0 注释 应用在布尔值上时，&amp;和|运算符也会得到一个布尔值。这些运算符&amp;&amp;与和||运算符很类似，不过&amp;和|运算符不采用“短路”方式来求值，也就是说，得到计算结果之前两个操作数都需要计算。 左移右移运算符 另外，还有&gt;&gt;和&lt;&lt;运算符可以将位模式左移或右移。需要建立位模式来完成位掩码时，这两个运算符会很方便： 左移右移运算符程序示例一 程序示例 左移右移运算符程序示例二 运行结果0 0 最后，&gt;&gt;&gt;运算符会用0填充高位，这与&gt;&gt;不同，它会用符号位填充高位。不存在&lt;&lt;&lt;运算符。 警告 警告 程序示例 左移右移运算符程序示例三 运行结果8 8 括号与运算符级别 表（运算符优先级）给出了运算符的优先级。如果不使用圆括号，就按照给出的运算符优先级次序进行计算。同一个级别的运算符按照从左到右的次序进行计算（但右结合运算符除外，如表中所示）。例如，由于&amp;&amp;的优先级比||的优先级高，所以表达式 a &amp;&amp; b || c 等价于 (a &amp;&amp; b) || c 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; boolean huangzihan_a&#x3D;true; boolean huangzihan_b&#x3D;false; boolean huangzihan_c&#x3D;true; System.out.println(huangzihan_a &amp;&amp; huangzihan_b || huangzihan_c); System.out.println(); boolean huangzihan_d&#x3D;true; boolean huangzihan_e&#x3D;false; boolean huangzihan_f&#x3D;true; System.out.println((huangzihan_d &amp;&amp; huangzihan_e) || huangzihan_f); &#125; &#125; 运行结果false false true true 又因为+=是右结合运算符，所以表达式 a +&#x3D; b +&#x3D; c 等价于 a +&#x3D; (b +&#x3D; c) 也就是将b += c的结果（加上c之后的b）加到a上。 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; int huangzihan_a&#x3D;1; int huangzihan_b&#x3D;2; int huangzihan_c&#x3D;3; System.out.println(huangzihan_a +&#x3D; huangzihan_b +&#x3D; huangzihan_c); System.out.println(); int huangzihan_d&#x3D;1; int huangzihan_e&#x3D;2; int huangzihan_f&#x3D;3; System.out.println(huangzihan_d +&#x3D; (huangzihan_e +&#x3D; huangzihan_f)); &#125; &#125; 运行结果6 6 运算符优先级 运算符优先级","path":"2021/07/03/运算符/","date":"07-03","excerpt":"运算符 运算符用于连接值。 算术运算符四则运算 在Java中，使用算术运算符+、一、*、/表示加、减、乘、除运算。当参与/运算的两个操作数都是整数时，表示整数除法；否则，表示浮点除法。整数的求余操作（有时称为取模）用%表示。例如，15/2等于7，15%2等于1，15.0/2等于7.5。需要注意，整数被0除将会产生一个异常，而浮点数被0除将会得到无穷大或NaN结果。 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; System.out.println(15&#x2F;2); System.out.println(15%2); System.out.println(15.0&#x2F;2); &#125; &#125; 运行结果7 1 7.5","tags":[{"name":"Java","slug":"Java","permalink":"http://www.huangzihan.top/tags/Java/"},{"name":"运算符","slug":"运算符","permalink":"http://www.huangzihan.top/tags/%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"name":"floorMod方法","slug":"floorMod方法","permalink":"http://www.huangzihan.top/tags/floorMod%E6%96%B9%E6%B3%95/"},{"name":"sqrt方法","slug":"sqrt方法","permalink":"http://www.huangzihan.top/tags/sqrt%E6%96%B9%E6%B3%95/"},{"name":"静态方法","slug":"静态方法","permalink":"http://www.huangzihan.top/tags/%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/"},{"name":"Math类","slug":"Math类","permalink":"http://www.huangzihan.top/tags/Math%E7%B1%BB/"},{"name":"强制类型转换","slug":"强制类型转换","permalink":"http://www.huangzihan.top/tags/%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"},{"name":"三元操作符","slug":"三元操作符","permalink":"http://www.huangzihan.top/tags/%E4%B8%89%E5%85%83%E6%93%8D%E4%BD%9C%E7%AC%A6/"},{"name":"掩码技术","slug":"掩码技术","permalink":"http://www.huangzihan.top/tags/%E6%8E%A9%E7%A0%81%E6%8A%80%E6%9C%AF/"}]},{"title":"面向对象程序设计概述","text":"面向对象程序设计概述 面向对象程序设计（object-oriented programming，OOP）是当今主流的程序设计范型，它取代了20世纪70年代的“结构化”或过程式编程技术。由于Java是面向对象的，所以你必须熟悉OOP才能够很好地使用Java。 对象 面向对象的程序是由对象组成的，每个对象包含对用户公开的特定功能部分和隐藏的实现部分。程序中的很多对象来自标准库，还有一些是自定义的。究竟是自己构造对象，还是从外界购买对象完全取决于开发项目的预算和时间。但是，从根本上说，只要对象能够满足要求，就不必关心其功能到底是如何实现的。 结构化程序设计 传统的结构化程序设计通过设计一系列的过程（即算法）来求解问题。一旦确定了这些过程，就要开始考虑存储数据的适当方式。这就是Pascal语言的设计者Niklaus Wirth将其著作命名为《算法+数据结构=程序》（Algorithms+DataStructures=Programs，Prentice Hall，1975）的原因。需要注意的是，在Wirth的这个书名中，算法是第一位的，数据结构第二位的，这就明确地表述了程序员的工作方式。首先要确定如何操作数据，然何组织数据的结构，以便于操作数据。而OOP却调换了这个次序，将数据放在第一位，然后再考虑操作数据的算法。 面对过程与面向对象的程序设计对比 对于一些规模较小的问题，将其分解为过程的开发方式比较理想。面向对象更加适合解决规模较大的问题。要想实现一个简单的Web浏览器可能需要大约2000个过过程程，这些过程可能需要对一组全局数据进行操作。采用面向对象的设计风格，可能只据需要大约100个类，每个类平均包含20个方法（如图（面对过程与面向对象的程序设计对比）所示）。后者更易于程序员掌握，也容易找到bug。假设给定对象的数据出错了，在访问这个数据项的20个方法中查找错误要比在2000个过程中查找容易得多。 面对过程与面向对象的程序设计对比 类类的实例 类（class）是构造对象的模板或蓝图。我们可以将类想象成制作小甜饼的模具，将对象想象为小甜饼。由类构造（construct）对象的过程称为创建类的实例（instance）。 正如前面所看到的，用Java编写的所有代码都位于某个类里面。标准Java库提供了几千个类，可用于各种目的，如用户界面设计、日期、日历和网络编程。尽管如此，在Java中还是需要创建一些自己的类，以便描述你的应用程序所对应的问题领域中的对象。 封装 封装（encapsulation，有时称为数据隐藏）是处理对象的一个重要概念。从形式上看，封装就是将数据和行为组合在一个包中，并对对象的使用者隐藏具体的实现方式。 实例字段和方法 对象中的数据称为实例字段（instancefield），操作数据的过程称为方法（method）。作为一个类的实例，特定对象都有一组特定的实例字段值。这些值的集合就是这个对象的当前状态（state）。无论何时，只要在对象上调用一个方法，它的状态就有可能发生改变。 实现封装的关键在于，绝对不能让类中的方法直接访问其他类的实例字段。程序只能通过对象的方法与对象数据进行交互。封装给对象赋予了“黑盒”特征，这是提高重用性和可靠性的关键。这意味着一个类可以完全改变存储数据的方式，只要仍旧使用同样的方法操作数据，其他对象就不会知道也不用关心这个类所发生的变化。 Object类 OOP的另一个原则会让用户自定义Java类变得更为容易，这就是：可以通过扩展其他类来构建新类。事实上，在Java中，所有的类都源自一个“神通广大的超类”，它就是0bject。所有其他类都扩展自这个Object类。 继承 在扩展一个已有的类时，这个扩展后的新类具有被扩展的类的全部属性和方法。你只需要在新类中提供适用于这个新类的新方法和数据字段就可以了。通过扩展一个类来建立另外一个类的过程称为继承（inheritance）。 对象对象的三个主要特性 要想使用OOP，一定要清楚对象的三个主要特性： 对象的行为（behavior）——可以对对象完成哪些操作，或者可以对对象应用哪些方法？ 对象的状态（state）——当调用那些方法时，对象会如何响应？ 对象的标识（identity）——如何区分具有相同行为与状态的不同对象？ 同一个类的所有对象实例，由于支持相同的行为而具有家族式的相似性。对象的行为是用可调用的方法来定义的。 此外，每个对象都保存着描述当前状况的信息。这就是对象的状态。对象的状态可能会随着时间而发生改变，但这种改变不会是自发的。对象状态的改变必须通过调用方法实现（如果不经过方法调用就可以改变对象状态，只能说明破坏了封装性）。 但是，对象的状态并不能完全描述一个对象。每个对象都有一个唯一的标识（identity，或称身份）。例如，在一个订单处理系统中，任何两个订单都存在着不同之处，即使所订购的货物完全相同，它们也是不同的订单。需要注意，作为同一个类的实例，每个对象的标识总是不同的，状态也往往存在着差异。 对象的这些关键特性会彼此相互影响。例如，对象的状态影响它的行为（如果一个订单“已送货”或“已付款”，就应该拒绝调用要求增删订单中商品的方法。反过来，如果订单是“空的”，即还没有预订任何商品，这个订单就不应该“送货”）。 识别类 传统的过程式程序中，必须从顶部的main函数开始编写程序。在面向对象程序设计时没有所谓的“顶部”。学习OOP的初学者因而常常会感觉无从下手。答案是：首先从识别类开始，然后再为各个类添加方法。 识别类的一个简单经验是在分析问题的过程中寻找名词，而方法对应着动词。 例如，在订单处理系统中，有这样一些名词： 商品（Item）； 订单（Order）； 送货地址（Shipping address）； 付款（Payment）； 账户（Account）。 从这些名词就可以得到类Item、Order等。 接下来查看动词。商品被添加到订单中，订单会发货或取消，另外可以对订单完成付款。对于每一个动词，如“添加”“发货”“取消”以及“完成付款”，都要识别出负责完成相应动作的对象。例如，当一个新的商品添加到订单中时，那个订单对象就是负责的对象，因为它知道如何存储商品以及如何对商品进行排序。也就是说，add应该是Order类的一个方法，它要取一个Item对象作为参数。 当然，这种“名词与动词”原则只是一种经验，在创建类的时候，只有经验才能帮助你确定哪些名词和动词重要。 类之间的关系类的三种关系 在类之间，最常见的关系有 依赖（“uses-a”）； 聚合（“has-a”）； 继承（“is-a”）。 依赖 依赖（dependence），即“uses-a”关系，是一种最明显的、最常见的关系。例如，Order类使用Account类是因为Order对象需要访问Account对象查看信用状态。但是Item类不依赖于Account类，因为Item对象不需要考虑客户账户。因此，如果一个类的方法使用或操纵另一个类的对象，我们就说一个类依赖于另一个类。 应该尽可能地将相互依赖的类减至最少。这里的关键是，如果类A不知道B的存在，它就不会关心B的任何改变（这意味着B的改变不会导致A产生任何bug）。用软件工程的术语来说，就是尽可能减少类之间的耦合。 聚合 聚合（aggregation），即“has-a”关系，很容易理解，因为这种关系很具体。例如，一个Order对象包含一些Item对象。包容关系意味着类A的对象包含类B的对象。 注释 有些方法学家不喜欢聚合这个概念，而更加喜欢使用更一般的“关联”关系。从建模的角度看，这是可以理解的。但对于程序员来说，“has-a”关系更加形象。我们喜欢使用聚合还有另一个原因：关联的标准记法不是很清楚，请参看表（表达类关系的UML符号）。 表达类关系的UML符号 继承 继承（inheritance），即“is-a”关系，表示一个更特殊的类与一个更一般的类之间的关系。例如，Rushorder类由Order类继承而来。在更特殊的RushOrder类中包含了一些用于优先处理的特殊方法，还提供了一个计算运费的不同方法；而其他的方法，如添加商品、生成账单等都是从Order类继承来的。一般而言，如果类A扩展类B，类A不但包含从类B继承的方法，还会有一些额外的功能。 UML 很多程序员采用UML（Unified ModelingLanguage，统一建模语言）绘制类图，用来描述类之间的关系。图（类图）就是这样一个例子。类用矩形表示，类之间的关系用带有各种修饰的箭头表示。表（表达类关系的UML符号）给出了UML中最常见的箭头样式。 类图","path":"2021/07/02/面向对象程序设计概述/","date":"07-02","excerpt":"面向对象程序设计概述 面向对象程序设计（object-oriented programming，OOP）是当今主流的程序设计范型，它取代了20世纪70年代的“结构化”或过程式编程技术。由于Java是面向对象的，所以你必须熟悉OOP才能够很好地使用Java。 对象 面向对象的程序是由对象组成的，每个对象包含对用户公开的特定功能部分和隐藏的实现部分。程序中的很多对象来自标准库，还有一些是自定义的。究竟是自己构造对象，还是从外界购买对象完全取决于开发项目的预算和时间。但是，从根本上说，只要对象能够满足要求，就不必关心其功能到底是如何实现的。 结构化程序设计 传统的结构化程序设计通过设计一系列的过程（即算法）来求解问题。一旦确定了这些过程，就要开始考虑存储数据的适当方式。这就是Pascal语言的设计者Niklaus Wirth将其著作命名为《算法+数据结构=程序》（Algorithms+DataStructures=Programs，Prentice Hall，1975）的原因。需要注意的是，在Wirth的这个书名中，算法是第一位的，数据结构第二位的，这就明确地表述了程序员的工作方式。首先要确定如何操作数据，然何组织数据的结构，以便于操作数据。而OOP却调换了这个次序，将数据放在第一位，然后再考虑操作数据的算法。 面对过程与面向对象的程序设计对比 对于一些规模较小的问题，将其分解为过程的开发方式比较理想。面向对象更加适合解决规模较大的问题。要想实现一个简单的Web浏览器可能需要大约2000个过过程程，这些过程可能需要对一组全局数据进行操作。采用面向对象的设计风格，可能只据需要大约100个类，每个类平均包含20个方法（如图（面对过程与面向对象的程序设计对比）所示）。后者更易于程序员掌握，也容易找到bug。假设给定对象的数据出错了，在访问这个数据项的20个方法中查找错误要比在2000个过程中查找容易得多。 面对过程与面向对象的程序设计对比","tags":[]},{"title":"变量与常量","text":"变量与常量 与所有程序设计语言一样，Java也使用变量来存储值。常量就是值不变的变量。在下面几节中，你会了解如何声明变量和常量。 声明变量 在Java中，每个变量都有一个类型（type）。在声明变量时，先指定变量的类型，然后是变量名。这里列举一些声明变量的示例： double salary; int vacationDays; long earthPopulation; boolean done; 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; double salary; int vacationDays; long earthPopulation; boolean done; &#125; &#125; 运行结果 可以看到，每个声明都以分号结束。由于声明是一条完整的Java语句，而所有Java语句都以分号结束，所以这里的分号是必需的。 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; double salary int vacationDays; long earthPopulation; boolean done; &#125; &#125; 运行结果Exception in thread &quot;main&quot; java.lang.Error: Unresolved compilation problem: Syntax error, insert &quot;;&quot; to complete BlockStatements at HuangZiHanTest.main(HuangZiHanTest.java:6) 变量名命名规则 变量名必须是一个以字母开头并由字母或数字构成的序列。需要注意，与大多数程序设计语言相比，Java中“字母”和“数字”的范围更大。字母包括’A’ ~ ‘Z’、’a’ ~ ‘z’、’_’、’$’或在某种语言中表示字母的任何Unicode字符。例如：希腊人可以用π同样，数字包括’0’ ~’9’和在某种语言中表示数字的任何Unicode字符。但’+’和’©’这样的符号不能出现在变量名中，空格也不行。变量名中所有的字符都是有意义的，并且大小写敏感。变量名的长度基本上没有限制。 变量名对大小写敏感程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; int Huangzihan&#x3D;3; &#x2F;&#x2F;System.out.println(huangzihan); System.out.println(Huangzihan); &#125; &#125; 运行结果3 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; int Huangzihan&#x3D;3; System.out.println(huangzihan); System.out.println(Huangzihan); &#125; &#125; 运行结果Exception in thread &quot;main&quot; java.lang.Error: Unresolved compilation problem: huangzihan cannot be resolved to a variable at HuangZiHanTest.main(HuangZiHanTest.java:7) 提示 如果想要知道哪些Unicode字符属于Java中的“字母”，可以使用Character类的isJavaIdentifierStart和isJavaIdentifierPart方法来检查。 提示 尽管$是一个合法的Java字符，但不要在你自己的代码中使用这个字符。它只用在Java编译器或其他工具生成的名字中。 不能使用Java保留字作为变量名 另外，不能使用Java保留字作为变量名。 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; int class&#x3D;3; &#125; &#125; 运行结果Exception in thread &quot;main&quot; java.lang.Error: Unresolved compilation problems: Syntax error on token &quot;int&quot;, . expected after this token The left-hand side of an assignment must be a variable at HuangZiHanTest.main(HuangZiHanTest.java:6) 在Java 9中，单下划线_不能作为变量名。不过，将来的版本可能使用作为通配符。 可以在一行中声明多个变量： int i,j; &#x2F;&#x2F;both are integers 不过，不提倡使用这种风格。逐一声明每一个变量可以提高程序的可读性。 注释 如前所述，变量名对大小写敏感，例如，hireday和hireDay是两个不同的变量名。一般来讲，在对两个不同的变量进行命名时，最好不要只存在大小写上的差异。不过，在有些时候，可能确实很难给变量取一个好的名字。于是，许多程序员将变量名命名为类型名，例如： Box box; &#x2F;&#x2F;&quot;Box&quot; is the type and &quot;box&quot; is the variable nane 还有一些程序员更加喜欢在变量名前加上前缀“a”： Box aBox; 变量初始化变量未初始化的结果 声明一个变量之后，必须用赋值语句对变量进行显式初始化，千万不要使用未初始化的变量的值。例如，Java编译器认为下面的语句序列是错误的： int vacationDays; System.out.println(vacationDays); &#x2F;&#x2F;ERROR--variable not initialized 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; int vacationDays; System.out.println(vacationDays); &#x2F;&#x2F;ERROR--variable not initialized &#125; &#125; 运行结果Exception in thread &quot;main&quot; java.lang.Error: Unresolved compilation problem: The local variable vacationDays may not have been initialized at HuangZiHanTest.main(HuangZiHanTest.java:7) 变量名初始化的方式 要想对一个已经声明过的变量进行赋值，就需要将变量名放在等号（=）左侧，再把一个适当取值的Java表达式放在等号的右侧。 int vacationDays; vacationDays&#x3D;12; 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; int vacationDays; vacationDays&#x3D;12; System.out.println(vacationDays); &#x2F;&#x2F;ERROR--variable not initialized &#125; &#125; 运行结果12 变量的声明和初始化放在同一行 也可以将变量的声明和初始化放在同一行中。例如： int vacationDays&#x3D;12; 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; int vacationDays&#x3D;12; System.out.println(vacationDays); &#125; &#125; 运行结果12 声明放在代码中的任何地方 最后，在Java中可以将声明放在代码中的任何地方。例如，以下代码在Java中都是合法的： double salary&#x3D;65000.0; System.out.println(salary); int vacationDays&#x3D;12; &#x2F;&#x2F;OK to declare a variable here 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; double salary&#x3D;65000.0; System.out.println(salary); int vacationDays&#x3D;12; &#x2F;&#x2F;OK to declare a variable here System.out.println(vacationDays); &#125; &#125; 运行结果65000.0 12 在Java中，变量的声明尽可能地靠近变量第一次使用的地方，这是一种良好的程序编写风格。 注释关键字var 从Java 10开始，对于局部变量，如果可以从变量的初始值推断出它的类型，就不再需要声明类型。只需要使用关键字var而无须指定类型： var vacationDays&#x3D;12; &#x2F;&#x2F;vacationDays is an int var greeting&#x3D;&quot;Hello&quot;; &#x2F;&#x2F;greeting is a String 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; var vacationDays&#x3D;12; &#x2F;&#x2F;vacationDays is an int var greeting&#x3D;&quot;Hello&quot;; &#x2F;&#x2F;greeting is a String System.out.println(greeting); System.out.println(vacationDays); &#125; &#125; 运行结果Hello 12 常量关键字final 在Java中，利用关键字final指示常量。例如： 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; final double US_DOLLAR_EXCHANGE_RATE&#x3D;6.45; double dollarStarts&#x3D;123456.123456; double dollarEnds&#x3D;654321.654321; System.out.println(&quot;黄子涵以后的年薪:&quot;+dollarStarts*US_DOLLAR_EXCHANGE_RATE+&quot; 到 &quot;+dollarEnds*US_DOLLAR_EXCHANGE_RATE); &#125; &#125; 运行结果黄子涵以后的年薪:796291.9962912 到 4220374.67037045 关键字final表示这个变量只能被赋值一次。一旦被赋值之后，就不能够再更改了。习惯上，常量名使用全大写。 类常量（class constant） 在Java中，经常希望某个常量可以在一个类的多个方法中使用，通常将这些常量称为类常量（class constant）。可以使用关键字static final设置一个类常量。下面是类常量的示例： 程序示例public class HuangZiHanTest &#123; public static final double US_DOLLAR_EXCHANGE_RATE&#x3D;6.45; public static void main(String[] args) &#123; double dollarStarts&#x3D;123456.123456; double dollarEnds&#x3D;654321.654321; System.out.println(&quot;黄子涵以后的年薪:&quot;+dollarStarts*US_DOLLAR_EXCHANGE_RATE+&quot; 到 &quot;+dollarEnds*US_DOLLAR_EXCHANGE_RATE); &#125; &#125; 运行结果黄子涵以后的年薪:796291.9962912 到 4220374.67037045 需要注意，类常量的定义位于main方法的外部。因此，在同一个类的其他方法中也可以使用这个常量。而且，如果一个常量被声明为public，那么其他类的方法也可以使用这个常量。如这个示例中的US_DOLLAR_EXCHANGE_RATE。 枚举类型 有时候，变量的取值只在一个有限的集合内。例如，销售的服装或比萨只有小、中、大和超大这四种尺寸。当然，可以将这些尺寸分别编码为1、2、3、4或S、M、L、X。但这种设置很容易出错。很可能在变量中保存的是一个错误的值（如0或m）。 自定义枚举类型 针对这种情况，可以自定义枚举类型。枚举类型包括有限个命名的值。例如， enum Size&#123;SMALL,MEDIUM,LARGE,EXTRA_LARGE&#125;; 现在，可以声明这种类型的变量： Size s&#x3D;Size.MEDIUM; Size类型的变量只能存储这个类型声明中给定的某个枚举值，或者特殊值null，null表示这个变量没有设置任何值。","path":"2021/07/01/变量与常量/","date":"07-01","excerpt":"变量与常量 与所有程序设计语言一样，Java也使用变量来存储值。常量就是值不变的变量。在下面几节中，你会了解如何声明变量和常量。 声明变量 在Java中，每个变量都有一个类型（type）。在声明变量时，先指定变量的类型，然后是变量名。这里列举一些声明变量的示例： double salary; int vacationDays; long earthPopulation; boolean done; 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; double salary; int vacationDays; long earthPopulation; boolean done; &#125; &#125; 运行结果 可以看到，每个声明都以分号结束。由于声明是一条完整的Java语句，而所有Java语句都以分号结束，所以这里的分号是必需的。","tags":[]},{"title":"数据类型","text":"数据类型强类型语言 Java是一种强类型语言。这就意味着必须为每一个变量声明一种类型。在Java中，一共有8种基本类型（primitive type），其中有4种整型、2种浮点类型、1种字符类型char（用于表示Unicode编码的代码单元）和1种用于表示真值的boolean类型。 整型 整型用于表示没有小数部分的数值，允许是负数。Java提供了4种整型，具体内容如下： Java整型 类型 存储需求 取值范围 int 4字节 -2 147 483 648 ~ 2 147 483 647（刚刚超过20亿） short 2字节 -32 768 ~ 32 767 long 8字节 -9 223 372 036 854 775 808 ~ 9 223 372 036 854 775 807 byte 1字节 -128 ~ 127 在通常情况下，int类型最常用。但如果想要表示整个地球的居住人口，就需要使用long类型了。byte和short类型主要用于特定的应用场合，例如，底层的文件处理或者存储空间很宝贵时的大数组。 在Java中，整型的范围与运行Java代码的机器无关。这就解决了软件从一个平台移植到另一个平台，或者在同一个平台中的不同操作系统之间进行移植给程序员带来的诸多问题。与此相反，C和C++程序会针对不同的处理器选择最为高效的整型，这样就会造成一个在32位处理器上运行很好的C程序在16位系统上运行时却发生整数溢出。由于Java程序必须保证在所有机器上都能够得到相同的运行结果，所以各种数据类型的取值范围必须固定。 长整型数值有一个后缀L或l（如4000000000L）。十六进制数值有一个前缀0x或0X（如0xCAFE）。八进制有一个前缀0，例如，010对应十进制中的8。很显然，八进制表示法比较容易混淆，所以建议最好不要使用八进制常数。 从Java7开始，加上前缀0b或0B就可以写二进制数。例如，0b1001就是9。另外，同样是从Java7开始，还可以为数字字面量加下划线，如用1_000_000（或0b1111_0100_0010_0100_0000）表示100万。这些下划线只是为了让人更易读。Java编译器会去除这些下划线。 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; System.out.println(1_000_000); System.out.println(0b1111_0100_0010_0100_0000); &#125; &#125; 运行结果1000000 1000000 如果要使用不可能为负的整数值而且确实需要额外的一位（bit），也可以把有符号整数值解释为无符号数，但是要非常仔细。例如，一个byte值b可以不表示范围-128到127，如果你想表示0到255的范围，也可以存储在一个byte中。基于二进制算术运算的性质，只要不溢出，加法、减法和乘法都能正常计算。但对于其他运算，需要调用Byte.toUnsignedInt(b)来得到一个0到255的int值，然后处理这个整数值，再把它转换回byte。Integer和Long类都提供了处理无符号除法和求余数的方法。 浮点类型 浮点类型用于表示有小数部分的数值。 两种浮点类型 在Java中有两种浮点类型，具体内容如下表所示： 类型 存储需求 取值范围 float 4字节 大约 ±3.402 823 47E（有效位数为6 ~ 7位） double 8字节 大约 ±1.797 693 134 862 315 70E+308（有效位数为15位） double表示这种类型的数值精度是float类型的两倍（有人称之为双精度数值）。在很多情况下，float类型的精度（6 ~ 7位有效数字）并不能满足需求。实际上，只有很少的情况适合使用float类型，例如，需要单精度数的库，或者需要存储大量数据时。 float类型的数值有一个后缀F或f（例如，3.14F）。没有后缀F的浮点数值（如3.14）总是默认为double类型。当然，也可以在浮点数值后面添加后缀D或d（例如，3.14D）。 注释 可以使用十六进制表示浮点数值。例如，0.125=2^(-3)可以表示成0x1.0p-3。在十六进制表示法中，使用p表示指数，而不是e。（e是一个十六进制数位。）注意，尾数采用十六进制，指数采用十进制。指数的基数是2，而不是10。 三个特殊的浮点数值 所有的浮点数值计算都遵循IEEE 754规范。具体来说，下面是用于表示溢出和出错情况的三个特殊的浮点数值： 正无穷大 负无穷大 NaN（不是一个数字） 例如，一个正整数除以0的结果为正无穷大。计算0/0或者负数的平方根结果为NaN。 注释 常量Double.POSITIVE_INFINITY、Double.NEGATIVE_INFINITY和Double.NaN（以及相应的Float类型的常量）分别表示这三个特殊的值，但在实际应用中很少遇到。特别要说明的是，不能如下检测一个特定值是否等于Double.NaN： if(x&#x3D;&#x3D;Double.NaN) &#x2F;&#x2F;is never true 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; double x&#x3D;3.14; if(x&#x3D;&#x3D;Double.NaN) &#123; System.out.println(&quot;黄子涵&quot;); &#125; &#125; &#125; 运行结果 所有“非数值”的值都认为是不相同的。不过，可以如下使用Double.isNaN方法来判断： if(Double.isNaN(x)) &#x2F;&#x2F;check whether x is &quot;not a number&quot; 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; double x&#x3D;3.14; if(Double.isNaN(x)) &#123; System.out.println(&quot;黄子涵&quot;); &#125; &#125; &#125; 运行结果 警告 浮点数值不适用于无法接受舍入误差的金融计算。例如，命令System.out.println(2.0-1.1)将打印出0.8999999999999999，而不是人们期望的0.9。这种舍入误差的主要原因是浮点数值采用二进制系统表示，而在二进制系统中无法精确地表示分数1/10。这就好像十进制无法精确地表示分数1/3一样。如果在数值计算中不允许有任何舍入误差，就应该使用BigDecimal类。 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; System.out.println(2.0-1.1); &#125; &#125; 运行结果0.8999999999999999 char类型 char类型原本用于表示单个字符。不过，现在情况已经有所变化。如今，有些Unicode字符可以用一个char值描述，另外一些Unicode字符则需要两个char值。 char类型的字面量值要用单引号括起来。例如：’A’是编码值为65的字符常量。它与”A”不同，”A”是包含一个字符A的字符串。char类型的值可以表示为十六进制值，其范围从\\u0000到\\uFFFF。例如，\\u2122表示商标符号（™），\\u03C0表示希腊字母（π）。 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; System.out.println(&#39;A&#39;); System.out.println(&quot;A&quot;); &#125; &#125; 运行结果A A 除了转义序列\\u之外，还有一些用于表示特殊字符的转义序列，请参看表（特殊字符的转义序列）。所有这些转义序列都可以出现在加引号的字符字面量或字符串中。例如，’\\u2122’或’Hello\\n’。转义序列\\u还可以出现在加引号的字符常量或字符串之外（而其他所有转义序列不可以）。例如： public static void main(String\\u005B\\ue05D args) 就完全符合语法规则，\\u0058和\\u005D分别是[和]的编码。 程序示例public class HuangZiHanTest &#123; public static void main(String\\u005B\\u005D args) &#123; &#125; &#125; 运行结果 特殊字符的转义序列 转义序列 名称 Unicode值 \\b 退格 \\u0008 \\t 制表 \\u0009 \\n 换行 \\u000a \\r 回车 \\u000d \\&quot; 双引号 \\u0022 \\&#39; 单引号 \\u0027 \\\\ 反斜杆 \\u005c 警告 Unicode转义序列会在解析代码之前得到处理。例如，”\\u0022+\\u0022”并不是一个由引号（U+0022）包围加号构成的字符串。实际上，\\u0022会在解析之前转换为”，这会得到””+””，也就是一个空串。 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; System.out.println(&quot;\\u0022+\\u0022&quot;); &#125; &#125; 运行结果 注释中的\\u 更隐秘地，一定要当心注释中的\\u。注释 &#x2F;&#x2F; \\u000A is a newline 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; System.out.println(&quot;黄子涵&quot;); &#x2F;&#x2F; \\u000A is a newline &#125; &#125; 运行结果Exception in thread &quot;main&quot; java.lang.Error: Unresolved compilation problems: is cannot be resolved to a type Syntax error on token &quot;newline&quot;, ; expected at HuangZiHanTest.main(HuangZiHanTest.java:6) 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; System.out.println(&quot;黄子涵&quot;); &#x2F;&#x2F; \\u000A &#x2F;&#x2F;is a newline &#125; &#125; 运行结果黄子涵 会产生一个语法错误，因为读程序时\\u00A0会替换为一个换行符。类似地，下面这个注释 &#x2F;&#x2F;look inside c:\\users 也会产生一个语法错误，因为u后面并没有跟着4个十六进制数。 程序示例public class HuangZiHanTest &#123; public static void main(String[] args) &#123; System.out.println(&quot;黄子涵&quot;); &#x2F;&#x2F;look inside c:\\users &#125; &#125; 运行结果Exception in thread &quot;main&quot; java.lang.Error: Unresolved compilation problem: Invalid unicode at HuangZiHanTest.main(HuangZiHanTest.java:6) Unicode和char类型 要想弄清char类型，就必须了解Unicode编码机制。Unicode打破了传统字符编码机制的限制。 编码标准 在Unicode出现之前，已经有许多种不同的标准：美国的ASCII、西欧语言中的ISO 8859-1、俄罗斯的KOI-8、中国的GB 18030和BIG-5等。这样就产生了下面两个问题：一个是对于任意给定的代码值，在不同的编码方案下有可能对应不同的字母；二是采用大字符集的语言其编码长度有可能不同。例如，有些常用的字符采用单字节编码，而另一些字符则需要两个或多个字节。 设计Unicode编码的目的 设计Unicode编码的目的就是要解决这些问题。在20世纪80年代开始启动统一工作时，人们认为两个字节的代码宽度足以对世界上各种语言的所有字符进行编码，并有足够的空间留给未来扩展，当时所有人都这么想。在1991年发布了Unicode 1.0，当时仅占用65 536个代码值中不到一半的部分。在设计Java时决定采用16位的Unicode字符集，这比使用8位字符集的其他程序设计语言有了很大的改进。 十分遗憾的是，经过一段时间后，不可避免的事情发生了。Unicode字符超过了65 536个，其主要原因是增加了大量的汉语、日语和韩语中的表意文字。现在，16位的char类型已经不能满足描述所有Unicode字符的需要了。 码点 下面利用一些专用术语来解释Java语言从Java 5开始如何解决这个问题。码点（code point）是指与一个编码表中的某个字符对应的代码值。在Unicode标准中，码点采用十六进制书写，并加上前缀U+，例如U+0041就是拉丁字母A的码点。Unicode的码点可以分成17个代码平面（code plane）。 基本多语言平面 第一个代码平面称为基本多语言平面（basic multilingual plane），包括码点从U+0000到U+FFFF的“经典”Unicode代码；其余的16个平面的码点为从U+10000到U+10FFFF，包括辅助字符（supplementary character）。 代码单元 UTF-16编码采用不同长度的编码表示所有Unicode码点。在基本多语言平面中，每个字符用16位表示，通常称为代码单元（code unit）； 替代区域 而辅助字符编码为一对连续的代码单元。采用这种编码对表示的各个值落入基本多语言平面中未用的2048个值范围内，通常称为替代区域（surrogate area）（U+D800 ~ U+DBFF用于第一个代码单元，U+DC00 ~ U+DFFF用于第二个代码单元）。这样设计十分巧妙，我们可以从中迅速知道一个代码单元是一个字符的编码，还是一个辅助字符的第一或第二部分。 在Java中，char类型描述了UTF-16编码中的一个代码单元。 强烈建议不要在程序中使用char类型，除非确实需要处理UTF-16代码单元。最好将字符串作为抽象数据类型处理。 boolean类型 boolean（布尔）类型有两个值：false和true，用来判定逻辑条件。整型值和布尔值之间不能进行相互转换。","path":"2021/07/01/数据类型/","date":"07-01","excerpt":"数据类型强类型语言 Java是一种强类型语言。这就意味着必须为每一个变量声明一种类型。在Java中，一共有8种基本类型（primitive type），其中有4种整型、2种浮点类型、1种字符类型char（用于表示Unicode编码的代码单元）和1种用于表示真值的boolean类型。 整型 整型用于表示没有小数部分的数值，允许是负数。Java提供了4种整型，具体内容如下： Java整型 类型 存储需求 取值范围 int 4字节 -2 147 483 648 ~ 2 147 483 647（刚刚超过20亿） short 2字节 -32 768 ~ 32 767 long 8字节 -9 223 372 036 854 775 808 ~ 9 223 372 036 854 775 807 byte 1字节 -128 ~ 127 在通常情况下，int类型最常用。但如果想要表示整个地球的居住人口，就需要使用long类型了。byte和short类型主要用于特定的应用场合，例如，底层的文件处理或者存储空间很宝贵时的大数组。 在Java中，整型的范围与运行Java代码的机器无关。这就解决了软件从一个平台移植到另一个平台，或者在同一个平台中的不同操作系统之间进行移植给程序员带来的诸多问题。与此相反，C和C++程序会针对不同的处理器选择最为高效的整型，这样就会造成一个在32位处理器上运行很好的C程序在16位系统上运行时却发生整数溢出。由于Java程序必须保证在所有机器上都能够得到相同的运行结果，所以各种数据类型的取值范围必须固定。 长整型数值有一个后缀L或l（如4000000000L）。十六进制数值有一个前缀0x或0X（如0xCAFE）。八进制有一个前缀0，例如，010对应十进制中的8。很显然，八进制表示法比较容易混淆，所以建议最好不要使用八进制常数。","tags":[]},{"title":"注释","text":"注释 与大多数程序设计语言一样，Java中的注释也不会出现在可执行程序中。因此，可以在源程序中根据需要添加任意多的注释，而不必担心可执行代码会膨胀。在Java中，有3种标记注释的方式。最常用的方式是使用//，其注释内容从//开始到本行结尾。 当需要更长的注释时，既可以在每行的注释前面标记//，也可以使用/*和*/注释界定符将一段比较长的注释括起来。 最后，第3种注释可以用来自动地生成文档。这种注释以/**开始，以*/结束。 程序示例&#x2F;** * version 1.01 2021-06-30 * @author 黄子涵 *&#x2F; public class HuangZiHanFirstSample &#x2F;&#x2F;类名区分大小写 &#123; public static void main(String[] args) &#123; System.out.println(&quot;我是黄子涵！&quot;); &#x2F;&#x2F;println方法可以换行 System.out.println(); System.out.println(&quot;黄子涵是帅哥！&quot;); System.out.println(); &#x2F;&#x2F;空行输出 System.out.print(&quot;我是黄子涵！&quot;); System.out.print(&quot;黄子涵是帅哥！&quot;); &#x2F;&#x2F;print方法不换行 &#125; &#125; 运行结果我是黄子涵！ 黄子涵是帅哥！ 我是黄子涵！黄子涵是帅哥！","path":"2021/06/30/注释/","date":"06-30","excerpt":"","tags":[]},{"title":"一个简单的Java应用程序","text":"一个简单的Java应用程序首次运行结果 下面看一个最简单的Java应用程序，它只发送一条消息到控制台窗口中： 程序示例public class HuangZiHanFirstSample &#123; public static void main(String[] args) &#123; System.out.println(&quot;我是黄子涵！&quot;); &#125; &#125; 运行结果我是黄子涵！ 修改大小写之后的运行结果 这个程序虽然很简单，但所有的Java应用程序都具有这种结构，因此还是值得花一些时间来研究的。首先，Java区分大小写。如果出现了大小写拼写错误（例如，将main拼写成Main），程序将无法运行。 程序示例public class HuangZiHanFirstSample &#123; public static void Main(String[] args) &#123; System.out.println(&quot;我是黄子涵！&quot;); &#125; &#125; 运行结果错误: 在类 HuangZiHanFirstSample 中找不到 main 方法, 请将 main 方法定义为: public static void main(String[] args) 否则 JavaFX 应用程序类必须扩展javafx.application.Application 关键字public 下面逐行地查看这段源代码。关键字public称为访问修饰符（access modifier），这些修饰符用于控制程序的其他部分对这段代码的访问级别。 关键字class 关键字class表明Java程序中的全部内容都包含在类中。只需要将类作为程序逻辑的一个容器，程序逻辑定义了应用程序的行为。类是构建所有Java应用程序和applet的构建块。Java应用程序中的全部内容都必须放置在类中。 类名及其命名规则类名必须以字母开头 关键字class后面紧跟类名。Java中定义类名的规则很宽松。名字必须以字母开头，后面可以跟字母和数字的任意组合。长度基本上没有限制。 类名必须以字母开头 不能使用Java保留字作为类名 但是不能使用Java保留字（例如，public 或class）作为类名。 不能使用Java保留字作为类名 类名的标准命名规范骆驼命名法（camel case） 标准的命名规范为（类名 HuangZiHanFirstSample就遵循了这个规范）：类名是以大写字母开头的名词。如果名字由多个单词组成，每个单词的第一个字母都应该大写（这种在一个单词中间使用大写字母的方式称为骆驼命名法（camel case）。以其自身为例，应该写成（CamelCase）。 源代码的文件名公共类名的关系 源代码的文件名必须与公共类的名字相同，并用.java作为扩展名。因此，存储这段源代码的文件名必须为HuangZiHanFirstSample.java（再次提醒大家注意，大小写是非常重要的，千万不能写成firstsample.java）。 类字节码 如果已经正确地命名了这个文件，并且源代码中没有任何录入错误，在编译这段源代码之后就会得到一个包含这个类字节码的文件。Java编译器将字节码文件自动地命名为HuangZiHanFirstSample.class，并存储在源文件的同一个目录下。 源文件的同一目录下的字节码文件 main方法 运行已编译的程序时，Java虚拟机总是从指定类中的main方法的代码开始执行（这里的“方法”就是Java中的“函数”），因此为了代码能够执行，在类的源文件中必须包含一个main方法。当然，也可以将用户自定义的方法添加到类中，并在main方法中调用这些方法。每个Java应用程序都必须有一个main方法。 源文件中的main方法 main方法的声明格式public class ClassName &#123; public static void main(String[] args) &#123; program statements &#125; &#125; 源代码中的块 需要注意源代码中的大括号{}。在Java中，像在C/C++中一样，用大括号划分程序的各个部分（通常称为块）。Java中任何方法的代码都用“{”开始，用“}”结束。 源代码中的块 方法体&#123; System.out.println(&quot;我是黄子涵！&quot;); &#125; 一对大括号表示方法体的开始与结束，在这个方法中只包含一条语句。与大多数程序设计语言一样，可以将Java语句看成是语言中的句子。在Java中，每个句子必须用分号结束。特别需要说明，回车不是语句的结束标志，因此，如果需要可以将一条语句写在多行上。 调用方法 在上面这个main方法体中只包含了一条语句，其功能是将一个文本行输出到控制台上。 在这里，我们使用System.out对象并调用了它的println方法。注意，点号（.）用于调用方法。Java使用的通用语法是 object.method(parameters) 这等价于函数调用。 println方法 在这个示例中，调用了println方法并传递给它一个字符串参数。这个方法将传递给它的字符串参数显示在控制台上。然后，终止这个输出行，使得每次调用println都会在新的一行上显示输出。需要注意一点，Java与C/C++一样，都采用双引号界定字符串。 程序示例public class HuangZiHanFirstSample &#123; public static void main(String[] args) &#123; System.out.println(&quot;我是黄子涵！&quot;); System.out.println(&quot;黄子涵是帅哥！&quot;); &#125; &#125; 运行结果我是黄子涵！ 黄子涵是帅哥！ println方法打印空行 与其他程序设计语言中的函数一样，Java中的方法可以没有参数，也可以有一个或多个参数（有的程序员把参数叫做实参）。即使一个方法没有参数，也需要使用空括号。例如，不带参数的println方法只打印一个空行。使用下面的语句来调用： System.out.println(); 程序示例public class HuangZiHanFirstSample &#123; public static void main(String[] args) &#123; System.out.println(&quot;我是黄子涵！&quot;); System.out.println(); System.out.println(&quot;黄子涵是帅哥！&quot;); &#125; &#125; 运行结果我是黄子涵！ 黄子涵是帅哥！ System.out还有一个print方法，它不在输出之后增加换行符。例如，System.out.print(&quot;Hello&quot;)打印“Hello”之后不换行，后面的输出紧跟在字母“o”之后。 程序示例public class HuangZiHanFirstSample &#123; public static void main(String[] args) &#123; System.out.println(&quot;我是黄子涵！&quot;); System.out.println(); System.out.println(&quot;黄子涵是帅哥！&quot;); System.out.println(); System.out.print(&quot;我是黄子涵！&quot;); System.out.print(&quot;黄子涵是帅哥！&quot;); &#125; &#125; 运行结果我是黄子涵！ 黄子涵是帅哥！ 我是黄子涵！黄子涵是帅哥！","path":"2021/06/30/一个简单的Java应用程序/","date":"06-30","excerpt":"一个简单的Java应用程序首次运行结果 下面看一个最简单的Java应用程序，它只发送一条消息到控制台窗口中： 程序示例public class HuangZiHanFirstSample &#123; public static void main(String[] args) &#123; System.out.println(&quot;我是黄子涵！&quot;); &#125; &#125; 运行结果我是黄子涵！","tags":[]},{"title":"活动的基本用法","text":"活动的基本用法 由于Android Studio在一个工作区间内只允许打开一个项目，所以我们需要将当前的项目关闭，点击导航栏File——&gt;Close Project。然后再新建一个Android项目，项目名可以叫作Huangzihan， 包名我们就使用默认值com.example.huangzihan。新建项目的步骤我们已经学习过了，我们选择Add No Activity，因为这次我们准备手动创建活动，如图（选择不添加活动）所示。 选择不添加活动 点击Finish，等待Gradle构建完成后，项目就创建成功了。 手动创建活动初始项目结构 项目创建成功后，仍然会默认使用Android模式的项目结构，这里我们手动改成Project模式。目前Huangzihan项目中虽然还是会自 动生成很多文件，但是app/src/main/java/com.example.huangzihan目录应该是空的了，如图（初始项目结构）所示。 初始项目结构 新建活动对话框 现在右击com.example.huangzihan包—&gt;New—&gt;Activity——&gt;Empty Activity，会弹出一个创建活动的对话框，我们将类命名为First Activity，并且不要勾选Generate LayoutFile和Launcher Activity这两个选项，如图（新建活动对话框）所示。 新建活动对话框 勾选Generate Layout File 勾选Generate Layout File表示会自动为FirstActivity创建一个对应的布局文件 勾选Launcher Activity 勾选Launcher Activity表示会自动将FirstActivity设置为当前项目的主活动，这里由于第一次手动创建活动，这些自动生成的东西暂时都不要勾选。 勾选Backwards Compatibility 勾选Backwards Compatibility表示会为项目启用向下兼容的模式，这个选项要勾上。 点击Finish完成创建。你需要知道，项目中的任何活动都应该重写Activity的onCreate()方法，而目前我们的FirstActivity中已经重写了这个方法，这是由Android Studio自动帮我们完成的，代码如下所示： package com.example.huangzihan; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; public class FirstActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); &#125; &#125; 可以看到，onCreate()方法非常简单，就是调用了父类的onCreat()方法。当然这只是默认的实现，后面还需要在里面加入很多自己的逻辑。 创建和加载布局新建布局资源文件 前面我们说过，Android程序的设计讲究逻辑和视图分离，最好每一个活动都能对应一个布局，布局就是用来显示界面内容的，因此我们现在就来手动创建一个布局文件。 右击app/src/main/res目录—&gt;New——&gt;Directory，会弹出一个新建目录的窗口，这里先创建一个名为layout的目录。然后对着layout目录右键——&gt;Layout resourcefile，又会弹出一个新建布局资源文件的窗口，我们将这个布局文件命名为first_layout，根元素就默认选择为LinearLayout，如图（新建布局资源文件）所示。 新建布局资源文件 布局编辑器 点击OK完成布局的创建，这时候你会看到如图（布局编辑器）所示的布局编辑器。 布局编辑器 这是Android Studio为我们提供的可视化布局编辑器，你可以在屏幕的中央区域预览当前的布局。在窗口的最下方有两个切换卡，左边是Design，右边是Text。Design是当前的可视化布局编辑器，在这里你不仅可以预览当前的布局，还可以通过拖放的方式编辑布局。而Text则是通过XML文件的方式来编辑布局的，现在点击一下Text切换卡，可以看到如下代码： 布局编辑器程序示例 添加Button元素 由于我们刚才在创建布局文件时选择了LinearLayout作为根元素，因此现在布局文件中已经有一个LinearLayout元素了。那我们现在对这个布局稍做编辑，添加一个按钮，如下所示： 添加Button元素程序示例 android:id android:id是给当前的元素定义一个唯一标识符，之后可以在代码中对这个元素进行操作。 @+id/button 你可能会对@+id/button这种语法感到陌生，但如果把加号去掉，变成@id/button，这样你就会觉得有些熟悉了吧，这不就是在XML中引用资源的语法吗？只不过是把string替换成了id。是的，如果你需要在XML中引用一个id，就使用@id/id_name这种语法，而如果你需要在XML中定义一个id，则要使用@+id/id_name这种语法。 android:layout_width 随后android:layout_width指定了当前元素的宽度，这里使用match_parent表示让当前元素和父元素一样宽。 android:layout_height android:layout_height指定了当前元素的高度，这里使用wrap_content表示当前元素的高度只要能刚好包含里面的内容就行。 android:text android:text指定了元素中显示的文字内容。 预览当前布局 按钮已经添加完了，可以通过右侧工具栏的Preview来预览一下当前布局，如图（预览当前布局）所示。 预览当前布局 在活动中加载布局 可以看到，按钮已经成功显示出来了，这样一个简单的布局就编写完成了。那么接下来我们要做的，就是在活动中加载这个布局。 重新回到FirstActivity，在onCreate()方法中加入如下代码: package com.example.huangzihan; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; public class FirstActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.first_layout); &#125; &#125; 可以看到，这里调用了setContentView()方法来给当前的活动加载一个布局，而在setContentView()方法中，我们一般都会传入一个布局文件的id。项目中添加的任何资源都会在R文件中生成一个相应的资源id，因此我们刚才创建的first_layout.xml布局的id现在应该是已经添加到R文件中了。在代码中去引用布局文件的方法你也已经学过了，只需要调用R.layout.first_layout就可以得到first_layout.xml布局的id，然后将这个值传入setContentView()方法即可。 在AndroidManifest文件中注册 所有的活动都要在AndroidManifest.xml中进行注册才能生效，而实际上First Activity已经在AndroidManifest.xml中注册过了，我们打开app/src/main/Android-Manifest.xml文件瞧一瞧，代码如下所示： 在AndroidManifest文件中注册程序示例一 &lt;activity&gt;标签 可以看到，活动的注册声明要放在标签内，这里是通过标签来对活动进行注册的。那么又是谁帮我们自动完成了对FirstActivity的注册呢？当然是Android Studio，之前在使用Eclipse创建活动或其他系统组件时，很多人都会忘记要去Android Manifest.xml中注册一下，从而导致程序运行崩溃，很显然Android Studio在这方面做得更加人性化。 .FirstActivity 在&lt;activity&gt;标签中我们使用了android:name来指定具体注册哪一个活动，那么这里填入的.FirstActivity是什么意思呢？其实这不过就是com.example.activitytest.FirstActivity的缩写而已。 &lt;manifest&gt;标签 由于在最外层的&lt;manifest&gt;标签中已经通过package属性指定了程序的包名是com.example.activitytest，因此在注册活动时这一部分就可以省略了，直接使用.FirstActivity就足够了。不过，仅仅是这样注册了活动，我们的程序仍然是不能运行的，因为还没有为程序配置主活动，也就是说，当程序运行起来的时候，不知道要首先启动哪个活动。配置主活动的方法其实就是在&lt;activity&gt;标签的内部加入&lt;intent-filter&gt;标签，并在这个标签里添加&lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;和&lt;category android: name=&quot;android.intent.category.LAUNCHER&quot; /&gt;这两句声明即可。 android:label 除此之外，我们还可以使用android:label指定活动中标题栏的内容，标题栏是显示在活动最顶部的，待会儿运行的时候你就会看到。需要注意的是，给主活动指定的label不仅会成为标题栏中的内容，还会成为启动器（Launcher）中应用程序显示的名称。 修改后的AndroidManifest.xml文件，代码如下所示： 在AndroidManifest文件中注册程序示例二 活动的首次运行结果 这样的话，FirstActivity就成为我们这个程序的主活动了，即点击桌面应用程序图标时首先打开的就是这个活动。另外需要注意，如果你的应用程序中没有声明任何一个活动作为主活动，这个程序仍然是可以正常安装的，只是你无法在启动器中看到或者打开这个程序。这种程序一般都是作为第三方服务供其他应用在内部进行调用的，如支付宝快捷支付服务。好了，现在一切都已准备就绪，让我们来运行一下程序吧，结果如图（首次运行结果）所示。 首次运行结果 在界面的最顶部是一个标题栏，里面显示着我们刚才在注册活动时指定的内容。标题栏的下面就是在布局文件first_layout.xml中编写的界面，可以看到我们刚刚定义的按钮。现在你已经成功掌握了手动创建活动的方法，下面让我们继续看一看你在活动中还能做哪些事情吧。 在活动中使用Toast Toast是Android系统提供的一种非常好的提醒方式，在程序中可以使用它将一些短小的信息通知给用户，这些信息会在一段时间后自动消失，并且不会占用任何屏幕空间，我们现在就尝试一下如何在活动中使用Toast。 首先需要定义一个弹出Toast的触发点，正好界面上有个按钮，那我们就让点击这个按钮的时候弹出一个Toast吧。在onCreate()方法中添加如下代码： package com.example.huangzihan; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.Toast; public class FirstActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.first_layout); Button button1&#x3D;(Button) findViewById(R.id.黄子涵的按钮); button1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(FirstActivity.this, &quot;你点击了黄子涵的按钮&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; &#125; 在活动中，可以通过findViewById()方法获取到在布局文件中定义的元素，这里我们传入R.id.黄子涵的按钮，来得到按钮的实例，这个值是刚才在first_layout.xml中通过android:id属性指定的。findViewById()方法返回的是一个View对象，我们需要向下转型将它转成Button对象。得到按钮的实例之后，我们通过调用setOnClickListener()方法为按钮注册一个监听器，点击按钮时就会执行监听器中的onClick()方法。因此，弹出Toast的功能当然是要在onClick()方法中编写了。 Toast的用法 Toast的用法非常简单，通过静态方法makeText()创建出一个Toast对象，然后调用show()将Toast显示出来就可以了。 makeText()方法的3个参数 makeText()方法需要传入3个参数。第一个参数是Context，也就是Toast要求的上下文，由于活动本身就是一个Context对象，因此这里直接传入FirstActivity.this即可。第二个参数是Toast显示的文本内容，第三个参数是Toast显示的时长，有两个内置常量可以选择Toast.LENGTH_SHORT和Toast.LENGTH_LONG。 Toast运行效果 现在重新运行程序，并点击一下按钮，效果如图（Toast运行效果）所示。 Toast运行效果 在活动中使用Menu 手机毕竟和电脑不同，它的屏幕空间非常有限，因此充分地利用屏幕空间在手机界面设计中就显得非常重要了。如果你的活动中有大量的菜单需要显示，这个时候界面设计就会比较尴尬，因为仅这些菜单就可能占用屏幕将近三分之一的空间，这该怎么办呢？不用担心，Android给我们提供了一种方式，可以让菜单都能得到展示的同时，还能不占用任何屏幕空间。 新建Menu资源文件 首先在res目录下新建一个menu文件夹，右击res目录——&gt;New——&gt;Directory，输入文件夹名menu，点击OK。接着在这个文件夹下再新建一个名叫main的菜单文件，右击menu文件夹——&gt;New——&gt;Menu resource file，如图（新建Menu资源文件）所示。 新建Menu资源文件 文件名输入main，点击OK完成创建。然后在main.xml中添加如下代码： &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt; &lt;menu xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;&gt; &lt;item android:id&#x3D;&quot;@+id&#x2F;add_item&quot; android:title&#x3D;&quot;黄子涵_添加&quot;&#x2F;&gt; &lt;item android:id&#x3D;&quot;@+id&#x2F;remove_item&quot; android:title&#x3D;&quot;黄子涵_移除&quot;&#x2F;&gt; &lt;&#x2F;menu&gt; 这里我们创建了两个菜单项，其中&lt;item&gt;标签就是用来创建具体的某一个菜单项，然后通过android:id给这个菜单项指定一个唯一的标识符，通过android:title给这个菜单项指定一个名称。 重写onCreateOptionsMenu()方法 接着重新回到FirstActivity中来重写onCreateOptionsMenu()方法，重写方法可以使用Ctrl+O快捷键（Mac系统是control+O），如图（重写onCreateOptionMenu( )方法）所示。 重写onCreateOptionMenu( )方法 然后在onCreateOptionsMenu()方法中编写如下代码： public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.main,menu); return true; &#125; 通过getMenuInflater()方法能够得到MenuInflater对象，再调用它的inflate()方法就可以给当前活动创建菜单了。inflate()方法接收两个参数，第一个参数用于指定我们通过哪一个资源文件来创建菜单，这里当然传入R.menu.main。第二个参数用于指定我们的菜单项将添加到哪一个Menu对象当中，这里直接使用onCreateOptionsMenu()方法中传入的menu参数。然后给这个方法返回true，表示允许创建的菜单显示出来，如果返回了false，创建的菜单将无法显示。 当然，仅仅让菜单显示出来是不够的，我们定义菜单不仅是为了看的，关键是要菜单真正可用才行，因此还要再定义菜单响应事件。在FirstActivity中重写onOptionsItemSelected()方法: public boolean onOptionsItemSelected(@NonNull MenuItem item) &#123; switch (item.getItemId()) &#123; case R.id.add_item: Toast.makeText(this, &quot;你点击了黄子涵的添加&quot;, Toast.LENGTH_SHORT).show(); break; case R.id.remove_item: Toast.makeText(this, &quot;你点击了黄子涵的移除&quot;, Toast.LENGTH_SHORT).show(); break; default: &#125; return true; &#125; 在onOptionsItemSelected()方法中，通过调用item.getItemId()来判断我们点击的是哪一个菜单项，然后给每个菜单项加入自己的逻辑处理，这里我们就活学活用，弹出一个刚刚学会的Toast。 重新运行程序，你会发现在标题栏的右侧多了一个三点的符号，这个就是菜单按钮了，如图（带菜单按钮的活动）所示。 带菜单按钮的活动 可以看到，菜单里的菜单项默认是不会显示出来的，只有点击一下菜单按钮才会弹出里面具体的内容，因此它不会占用任何活动的空间，如图（）所示。 弹出菜单项的界面 然后如果你点击了Add菜单项就会弹出“你点击了黄子涵的添加”提示（如图（点击了黄子涵的添加）所示），如果点击了Remove菜单项就会弹出“你点击了黄子涵的移除”提示。 点击了黄子涵的添加 销毁一个活动 按一下Back键就可以销毁当前的活动了。不过如果你不想通过按 键的方式，而是希望在程序中通过代码来销毁活动，当然也可以，Activity类提供了一个finish()方法，我们在活动中调用一下这个方法就可以销毁当前活动了。修改按钮监听器中的代码，如下所示： public void onClick(View v) &#123; finish(); &#x2F;&#x2F;Toast.makeText(FirstActivity.this, &quot;你点击了黄子涵的按钮&quot;, Toast.LENGTH_SHORT).show(); &#125; 重新运行程序，这时点击一下按钮，当前的活动就被成功销毁了，效果和按下Back键是一样的。","path":"2021/06/29/活动的基本用法/","date":"06-29","excerpt":"活动的基本用法 由于Android Studio在一个工作区间内只允许打开一个项目，所以我们需要将当前的项目关闭，点击导航栏File——&gt;Close Project。然后再新建一个Android项目，项目名可以叫作Huangzihan， 包名我们就使用默认值com.example.huangzihan。新建项目的步骤我们已经学习过了，我们选择Add No Activity，因为这次我们准备手动创建活动，如图（选择不添加活动）所示。 选择不添加活动 点击Finish，等待Gradle构建完成后，项目就创建成功了。 手动创建活动初始项目结构 项目创建成功后，仍然会默认使用Android模式的项目结构，这里我们手动改成Project模式。目前Huangzihan项目中虽然还是会自 动生成很多文件，但是app/src/main/java/com.example.huangzihan目录应该是空的了，如图（初始项目结构）所示。 初始项目结构","tags":[]},{"title":"res目录下的结构","text":"res目录下的结构 如果你展开res目录看一下，其实里面的东西还是挺多的，很容易让人看得眼花缭乱，如图（res目录下的结构）所示。 res目录下的结构 看到这么多的文件夹也不用害怕，其实归纳一下，res目录就变得非常简单了。 drawable开头的文件夹 所有以drawable开头的文件夹都是用来放图片的 mipmap开头的文件夹 所有以mipmap开头的文件夹都是用来放应用图标的 values开头的文件夹 所有以values开头的文件夹都是用来放字符串、样式、颜色等配置的 layout文件夹 layout文件夹是用来放布局文件的 之所以有这么多mipmap开头的文件夹，其实主要是为了让程序能够更好地兼容各种设备。drawable文件夹也是相同的道理，虽然Android Studio没有帮我们自动生成，但是我们应该自己创建drawable-hdpi、drawable-xhdpi、drawable-xxhdpi等文件夹。在制作程序的时候最好能够给同张图片提供几个不同分辨率的版本，分别放在这些文件夹下，然后当程序运行的时候，会自动根据当前运行设备分辨率的高低选择加载哪个文件夹下的图片。当然这只是理想情况，更多的时候美工只会提供给我们一份图片，这时你就把所有图片都放在drawable-xxhdpi文件夹下就好了。 知道了res目录下每个文件夹的含义，我们再来看一下如何去使用这些资源吧。打开res/values/strings.xml文件，内容如下所示： layout文件夹 使用res目录下的资源 可以看到，这里定义了一个应用程序名的字符串，我们有以下两种方式来引用它 在代码中通过R.string.hello_world可以获得该字符串的引用 在XML中通过@string/hello_world可以获得该字符串的引用 基本的语法就是上面这两种方式，其中string部分是可以替换的，如果是引用的图片资源就可以替换成drawable，如果是引用的应用图标就可以替换成mipmap，如果是引用的布局文件就可以替换成Layout，以此类推。 下面举一个简单的例子来帮助你理解，打开AndroidManifest.xml文件，找到如下代码: 使用res目录下的资源 其中, 项目的应用图标就是通过android:icon属性来指定的，应用的名称则是通过android:Label属性指定的。可以看到，这里对资源引用的方式正是XML中引用资源的语法。 如果你想修改应用的图标或者名称，相信已经知道该怎么办了吧。","path":"2021/06/26/res目录下的结构/","date":"06-26","excerpt":"res目录下的结构 如果你展开res目录看一下，其实里面的东西还是挺多的，很容易让人看得眼花缭乱，如图（res目录下的结构）所示。 res目录下的结构 看到这么多的文件夹也不用害怕，其实归纳一下，res目录就变得非常简单了。 drawable开头的文件夹 所有以drawable开头的文件夹都是用来放图片的 mipmap开头的文件夹 所有以mipmap开头的文件夹都是用来放应用图标的 values开头的文件夹 所有以values开头的文件夹都是用来放字符串、样式、颜色等配置的","tags":[]},{"title":"使用Android的日志工具Log","text":"掌握日志工具的使用使用Android的日志工具Log Android中的日志工具类是Log（android.util.Log），这个类中提供了如下5个方法来供我们打印日志。 Log.v() 用于打印那些最为琐碎的、意义最小的日志信息。对应级别 verbose，是Android日志里面级别最低的一种。 Log.d() 用于打印一些调试信息，这些信息对你调试程序和分析问题应该是有帮助的。对应级别debug，比verbose高一级。 Log.i() 用于打印一些比较重要的数据，这些数据应该是你非常想看到的、可以帮你分析用户行为数据。对应级别info，比debug高一级。 Log.W() 用于打印一些警告信息，提示程序在这个地方可能会有潜在的风险，最好去修复一下这些出现警告的地方。对应级别 warn，比info高一级。 Log.e() 用于打印程序中的错误信息，比如程序进入到了catch语句当中。当有错误信息打印出来的时候，一般都代表你的程序出现严重问题了，必须尽快修复。对应级别error， 比 warn高一级。 其实很简单，一共就5个方法，当然每个方法还会有不同的重载，但肯定不是什么难理解的地方了。我们现在就在项目中试一试日志工具好不好用吧。 打开项目，在onCreate()方法中添加一行打印日志的语句，如下所示： package com.example.myapplication; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Log.d(&quot;HelloworldActivity&quot;,&quot;onCreate exeecute&quot;); &#125; &#125; Log.d()方法的参数 Log.d()方法中传入了两个参数:第一个参数是tag，一般传入当前的类名就好，主要用于对打印信息进行过滤；第二个参数是msg，即想要打印的具体的内容。 logcat中的打印信息 运行一下项目，点击顶部工具栏上的运行按钮，或者使用快捷键Shift+Fl0（Mac系统是control+R），等程序运行完毕，点击Android Studio底部工具栏的Android Monitor，在logcat中就可以看到打印信息了，如图（logcat中的打印信息）所示。 logcat中的打印信息 不仅可以看到打印日志的内容和tag名，就连程序的包名、打印的时间以及应用程序的进程号都可以看到。 为什么使用Log而不使用System.out 很多的Java新手都非常喜欢使用System.out.println()方法来打印日志，不知道你是不是也喜欢这么做。不过在真正的项目开发中，是极度不建议使用System.out.println()方法的！如果在公司的项目中经常使用这个方法，就很有可能要挨骂了。 System.out.println()方法的缺点 为什么System.out.println()方法会这么遭大家唾弃呢？这个方法除了使用方便一点之外，其他就一无是处了。方便在哪儿呢？在Eclipse中你只需要输入syso，然后按下代码提示键，这个方法就会自动出来了，相信这也是很多Java新手对它钟情的原因，不过遗憾的是，Android Studio中已经不支持这种快捷输入了。那缺点又在哪儿了呢？这个就太多了，比如日志打印不可控制、打印时间无法确定、不能添加过滤器、日志没有级别区分…… 听我说了这些，你可能已经不太想用System.out.println()方法了，那么Log就把上面所说的缺点全部都改好了吗？虽然谈不上全部，但我觉得Log已经做得相当不错了。我现在就来带你看看Log和logcat配合的强大之处。 首先刚才提到的快捷输入，在Android Studio当中也是有的，比如你想打印一条debug级别的日志，那么只需要输入logd，然后按下Tab键，就会帮你自动补全一条完整的打印语句。输人logi，然后按下Tab键，会自动补全一条info级别的打印日志。输入logw，按下Tab键，会自动补全一条warn级别的打印日志，以此类推。另外，由于Log的所有打印方法都要求传入一个tag参数，每次写一遍显然太过麻烦。这里还有一个小技巧，我们在onCreate()方法的外面输入logt，然后按下Tab键，这时就会以当前的类名作为值自动生成一个TAG常量，如下所示: package com.example.myapplication; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; public class MainActivity extends AppCompatActivity &#123; private static final String TAG &#x3D; &quot;huangzihan&quot;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Log.d(&quot;HelloworldActivity&quot;,&quot;onCreate exeecute&quot;); &#125; &#125; logcat的过滤器 除了快捷输入之外，logcat中还能很轻松地添加过滤器，你可以在图（logcat中的过滤器）中看到我们目前所有的过滤器。 logcat中的过滤器 Show only selected application 表示只显示当前选中程序的日志, Firebase 谷歌提供的一个分析工具，我们可以不用管它 No Filters 相当于没有过滤器，会把所有的日志都显示出来。 自定义过滤器 那可不可以自定义过滤器呢？当然可以，我们现在就来添加一个过滤器试试。点击图（logcat中的过滤器）中的 Edit Filter Configuration，会弹出一个过滤器配置界面。我们给过滤器起名叫data，并且让它对名为data的tag进行过滤，如图（过滤器配置界面）所示 过滤器配置界面 点击OK，你就会发现你已经多出了一个data过滤器。当你点击这个过滤器的时候，你会发现刚才在onCreate()方法里打印的日志没了，这是因为data这个过滤器只会显示tag名称为data的日志。你可以尝试在onCreate()方法中把打印日志的语句改成Log.d(“data”,”onCreateexecute”)，然后再次运行程序，你就会在data过滤器下看到这行日志了。 不知道你有没有体会到使用过滤器的好处，可能现在还没有吧。不过当你的程序打印出成百上千行日志的时候，你就会迫切地需要过滤器了。 logcat中的日志级别 看完了过滤器，再来看一下logcat中的日志级别控制吧。logcat中主要有5个级别，分别对应着上一节介绍的5个方法，如图（logcat中的日志级别）所示。 logcat中的日志级别 verbose是最低等级。这意味着不管我们使用哪一个方法打印日志，这条日志都一定会显示出来。如果将级别选中为debug，只有使用debug及以上级别方法打印的日志オ会显示出来，以此类推。你可以做一下试验，当你把logcat中的级别选中为info、 warn或者error时，我们在onCreate()方法中打印的语句是不会显示的，因为我们打印日志时使用的是Log.d()方法。 日志级别控制的好处就是，你可以很快地找到你所关心的那些日志。相信如果让你从上千行日志中査找一条崩溃信息，你一定会抓狂的吧。而现在你只需要将日志级别选中为error，那些不相干的琐碎信息就不会再干扰你的视线了。 关键字过滤 最后我们再来看一下关键字过滤。如果使用过滤器加日志级别控制还是不能锁定到你想查看的日志内容的话，那么还可以通过关键字进行进一步的过滤，如图（关键字输入框）所示。 关键字输入框 我们可以在输入框里输入关键字的内容，这样只有符合关键字条件的日志才会显示出来，从而能够快速定位到任何你想査看的日志。另外还有一点需要注意，关键字过滤是支持正则表达式的，有了这个特性，我们就可以构建出更加丰富的过滤条件。","path":"2021/06/26/使用Android的日志工具Log/","date":"06-26","excerpt":"掌握日志工具的使用使用Android的日志工具Log Android中的日志工具类是Log（android.util.Log），这个类中提供了如下5个方法来供我们打印日志。 Log.v() 用于打印那些最为琐碎的、意义最小的日志信息。对应级别 verbose，是Android日志里面级别最低的一种。 Log.d() 用于打印一些调试信息，这些信息对你调试程序和分析问题应该是有帮助的。对应级别debug，比verbose高一级。 Log.i() 用于打印一些比较重要的数据，这些数据应该是你非常想看到的、可以帮你分析用户行为数据。对应级别info，比debug高一级。 Log.W() 用于打印一些警告信息，提示程序在这个地方可能会有潜在的风险，最好去修复一下这些出现警告的地方。对应级别 warn，比info高一级。 Log.e() 用于打印程序中的错误信息，比如程序进入到了catch语句当中。当有错误信息打印出来的时候，一般都代表你的程序出现严重问题了，必须尽快修复。对应级别error， 比 warn高一级。 其实很简单，一共就5个方法，当然每个方法还会有不同的重载，但肯定不是什么难理解的地方了。我们现在就在项目中试一试日志工具好不好用吧。","tags":[]},{"title":"详解build.gradle文件","text":"gradle 不同于Eclipse，Android Studio是采用Gradle来构建项目的。Gradle是一个非常先进的项目构建工具，它使用了一种基于Groovy的领域特定语言（DSL）来声明项目设置，摒弃了传统基于XML（如Ant和Maven）的各种烦琐配置。 两个build.gradle文件 一般项目中有两个build.gradle文件，一个是在最外层目录下的，一个是在app目录下的。这两个文件对构建Android Studio项目都起到了至关重要的作用，下面我们就来对这两个文件中的内容进行详细的分析。 最外层目录下的build.gradle文件 先来看一下最外层目录下的build.gradle文件，代码如下所示： &#x2F;&#x2F; Top-level build file where you can add configuration options common to all sub-projects&#x2F;modules. buildscript &#123; repositories &#123; google() jcenter() &#125; dependencies &#123; classpath &#39;com.android.tools.build:gradle:3.5.2&#39; &#x2F;&#x2F; NOTE: Do not place your application dependencies here; they belong &#x2F;&#x2F; in the individual module build.gradle files &#125; &#125; allprojects &#123; repositories &#123; google() jcenter() &#125; &#125; task clean(type: Delete) &#123; delete rootProject.buildDir &#125; 这些代码都是自动生成的，虽然语法结构看上去可能有点难以理解，但是如果我们忽略语法结构，只看最关键的部分，其实还是很好懂的。 jcenter 首先，两处repositories的闭包中都声明了jcenter()这行配置，那么这个jcenter是什么意思呢？其实它是一个代码托管仓库，很多Android开源项目都会选择将代码托管到jcenter上，声明了这行配置之后，我们就可以在项目中轻松引用任何jcenter上的开源项目了。 dependencies闭包 接下来，dependencies闭包中使用classpath声明了一个Gradle插件。为什么要声明这个插件呢？因为Gradle并不是专门为构建Android项目而开发的，Java、C++等很多种项目都可以使用Gradle来构建。因此如果我们要想使用它来构建Android项目，则需要声明com.android.tools.build:gradle:3.5.2这个插件。其中，最后面的部分是插件的版本号，现在显示的插件版本是3.5.2。 这样我们就将最外层目录下的build.gradle文件分析完了，通常情况下你并不需要修改这个文件中的内容，除非你想添加一些全局的项目构建配置。 app目录下的build.gradle文件 下面我们再来看一下app目录下的build.gradle文件，代码如下所示： apply plugin: &#39;com.android.application&#39; android &#123; compileSdkVersion 30 buildToolsVersion &quot;30.0.3&quot; defaultConfig &#123; applicationId &quot;com.example.myapplication&quot; minSdkVersion 15 targetSdkVersion 30 versionCode 1 versionName &quot;1.0&quot; testInstrumentationRunner &quot;androidx.test.runner.AndroidJUnitRunner&quot; &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile(&#39;proguard-android-optimize.txt&#39;), &#39;proguard-rules.pro&#39; &#125; &#125; &#125; dependencies &#123; implementation fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;]) implementation &#39;androidx.appcompat:appcompat:1.0.2&#39; implementation &#39;androidx.constraintlayout:constraintlayout:1.1.3&#39; testImplementation &#39;junit:junit:4.12&#39; androidTestImplementation &#39;androidx.test.ext:junit:1.1.0&#39; androidTestImplementation &#39;androidx.test.espresso:espresso-core:3.1.1&#39; &#125; com.android.application 这个文件中的内容就要相对复杂一些了，下面我们一行行地进行分析。首先第一行应用了一个插件，一般有两种值可选：com.android.application表示这是一个应用程序模块，com.android.library表示这是一个库模块。应用程序模块和库模块的最大区别在于，一个是可以直接运行的，一个只能作为代码库依附于别的应用程序模块来运行。 android闭包 接下来是一个大的android闭包，在这个闭包中我们可以配置项目构建的各种属性。其中，compileSdkVersion用于指定项目的编译版本，这里指定成24表示使用Android7.0系统的SDK编译。buildToolsVersion用于指定项目构建工具的版本，目前最新的版本就是30.0.3，如果有更新的版本时，Android Studio会进行提示。 defaultConfig闭包 然后我们看到，这里在android闭包中又嵌套了一个defaultConfig闭包，defaultConfig闭包中可以对项目的更多细节进行配置。 applicationId 用于指定项目的包名，前面我们在创建项目的时候其实已经指定过包名了，如果你想在后面对其进行修改，那么就是在这里修改的。 minSdkVersion 用于指定项目最低兼容的Android系统版本，这里指定成15表示最低兼容到Android4.0系统。 targetSdkVersion 指定的值表示你在该目标版本上已经做过了充分的测试，系统将会为你的应用程序启用一些最新的功能和特性。比如说Android6.0系统中引入了运行时权限这个功能，如果你将targetSdkVersion指定成23或者更高，那么系统就会为你的程序启用运行时权限功能，而如果你将targetSdkVersion指定成22，那么就说明你的程序最高只在Android5.1系统上做过充分的测试，Android6.0系统中引入的新功能自然就不会启用了。 versionCode 用于指定项目的版本号 versionName 用于指定项目的版本名 buildTypes闭包 分析完了defaultConfig闭包，接下来我们看一下buildTypes闭包。buildTypes闭包中用于指定生成安装文件的相关配置，通常只会有两个子闭包，一个是debug，一个是release。另外，debug闭包是可以忽略不写的，因此我们看到上面的代码中就只有一个release闭包。 debug闭包 debug闭包用于指定生成测试版安装文件的配置 release闭包 release闭包用于指定生成正式版安装文件的配置 minifyEnabled 用于指定是否对项目的代码进行混淆，true表示混淆，false表示不混淆 proguardFiles 用于指定混淆时使用的规则文件，这里的指定了两个文件，第一个proguard-android.txt是在Android SDK目录下的，里面是所有项目通用的混淆规则，第二个proguard-rules.pro是在当前项目的根目录下的，里面可以编写当前项目特有的混淆规则。需要注意的是，通过Android Studio直接运行项目生成的都是测试版安装文件。 dependencies闭包 这样整个android闭包中的内容就都分析完了，接下来还剩一个dependencies闭包。这个闭包的功能非常强大，它可以指定当前项目所有的依赖关系。 Android Studio项目的3种依赖方式 本地依赖 库依赖 远程依赖 本地依赖 本地依赖可以对本地的Jar包或目录添加依赖关系 库依赖 库依赖可以对项目中的库模块添加依赖关系 远程依赖 远程依赖则可以对jcenter库上的开源项目添加依赖关系 dependencies闭包中的配置compile fileTree 一个本地依赖声明，它表示将libs目录下所有.jar后缀的文件都添加到项目的构建路径当中。 compile（和书上有区别） 远程依赖声明，com.android.support:appcompat-v7：24.2.1就是一个标准的远程依赖库格式，其中com.android.support是域名部分，用于和其他公司的库做区分；appcompat-v7是组名称，用于和同一个公司中不同的库做区分；24.2.1是版本号，用于和同一个库不同的版本做区分。加上这句声明后，Gradle在构建项目时会首先检查一下本地是否已经有这个库的缓存，如果没有的话则会去自动联网下载，然后再添加到项目的构建路径当中。至于库依赖声明这里没有用到，它的基本格式是compile project 后面加上要依赖的库名称，比如说有一个库模块的名字叫helper，那么添加这个库的依赖关系只需要加入compile project（’：helper）这句声明即可。另外剩的一句testcompile是用于声明测试用例库的，这个我们暂时用不到，先忽略它就可以了。","path":"2021/06/26/详解build-gradle文件/","date":"06-26","excerpt":"gradle 不同于Eclipse，Android Studio是采用Gradle来构建项目的。Gradle是一个非常先进的项目构建工具，它使用了一种基于Groovy的领域特定语言（DSL）来声明项目设置，摒弃了传统基于XML（如Ant和Maven）的各种烦琐配置。 两个build.gradle文件 一般项目中有两个build.gradle文件，一个是在最外层目录下的，一个是在app目录下的。这两个文件对构建Android Studio项目都起到了至关重要的作用，下面我们就来对这两个文件中的内容进行详细的分析。 最外层目录下的build.gradle文件 先来看一下最外层目录下的build.gradle文件，代码如下所示： &#x2F;&#x2F; Top-level build file where you can add configuration options common to all sub-projects&#x2F;modules. buildscript &#123; repositories &#123; google() jcenter() &#125; dependencies &#123; classpath &#39;com.android.tools.build:gradle:3.5.2&#39; &#x2F;&#x2F; NOTE: Do not place your application dependencies here; they belong &#x2F;&#x2F; in the individual module build.gradle files &#125; &#125; allprojects &#123; repositories &#123; google() jcenter() &#125; &#125; task clean(type: Delete) &#123; delete rootProject.buildDir &#125; 这些代码都是自动生成的，虽然语法结构看上去可能有点难以理解，但是如果我们忽略语法结构，只看最关键的部分，其实还是很好懂的。","tags":[]},{"title":"分析你的第一个Android程序","text":"分析你的第一个Android程序Android模式的项目结构回到Android Studio当中，首先展开MyApplication项目，你会看到如图（Android模式的项目结构）所示的项目结构。 Android模式的项目结构 切换项目结构模式 任何一个新建的项目都会默认使用Android模式的项目结构，但这并不是项目真实的目录结构，而是被Android Studio转换过的。这种项目结构简洁明了，适合进行快速开发，但是对于新手来说可能并不易于理解。点击图（Android模式的项目结构）当中的Android区域可以切换项目结构模式，如图（切换项目结构模式）所示。 切换项目结构模式 Project模式的项目结构 这里我们将项目结构模式切换成Project，这就是项目真实的目录结构了，如图（Project模式的项目结构）所示。 Project模式的项目结构 开始看到这么多陌生的东西，你一定会感到有点头晕吧。别担心，我现在就对图（Project模式的项目结构）中的内容进行一一讲解，之后你再看这张图就不会感到那么吃力了。 .gradle和idea 这两个目录下放置的都是 Android Studio自动生成的一些文件，我们无须关心，也不要去手动编辑。 app 项目中的代码、资源等内容几乎都是放置在这个目录下的，我们后面的开发工作也基本都是在这个目录下进行的，待会儿还会对这个目录单独展开进行讲解。 build（没有发现这个文件夹） 这个目录你也不需要过多关心，它主要包含了一些在编译时自动生成的文件。 gradle 这个目录下包含了gradle wrapper的配置文件，使用gradlewrapper的方式不需要提前将gradle下载好，而是会自动根据本地的缓存情况决定是否需要联网下载gradle。Android Studio默认没有启用gradle wrapper 的方式，如果需要打开，可以点击 Android Studio导航栏——&gt;File——&gt;Settings——&gt;Build，Execution，Deployment——&gt;gradle，进行配置更改。 .gitignore 这个文件是用来将指定的目录或文件排除在版本控制之外的。 build.gradle 这是项目全局的gradle构建脚本，通常这个文件中的内容是不需要修改的。 gradle.properties 这个文件是全局的gradle配置文件，在这里配置的属性将会影响到项目中所有的gradle编译脚本。 gradlew和gradlew.bat 这两个文件是用来在命令行界面中执行gradle命令的，其中gradlew是在Linux或Mac系统中使用的，gradlew.bat是在Windows系统中使用的。 MyApplication.iml iml文件是所有Intellij IDEA项目都会自动生成的一个文件(Android Studio是基于 Intellij IDEA开发的），用于标识这是一个Intellij IDEA项目。我们不需要修改这个文件中的任何内容。 local.properties 这个文件用于指定本机中的Android SDK路径，通常内容都是自动生成的，我们并不需要修改除非你本机中的Android SDK位置发生了变化，那么就将这个文件中的路径改成新的位置即可。 settings.gradle 这个文件用于指定项目中所有引入的模块。由于MyApplication项目中就只有一个app模块，因此该文件中也就只引入了app这一个模块。通常情况下模块的引入都是自动完成的，需要我们手动去修改这个文件的场景可能比较少。 app目录下的结构 现在整个项目的外层目录结构已经介绍完了。你会发现，除了app目录之外，大多数的文件和目录都是自动生成的，我们并不需要进行修改。想必你已经猜到了，app目录下的内容才是我们以后的工作重点，展开之后结构如图（app目录下的结构）所示。 app目录下的结构 那么下面我们就来对app目录下的内容进行更为详细的分析。 build 这个目录和外层的build目录类似，主要也是包含了一些在编译时自动生成的文件，不过它里面的内容会更多更杂，我们不需要过多关心。 libs 如果你的项目中使用到了第三方jar包，就需要把这些jar包都放在libs目录下，放在这个目录下的jar包都会被自动添加到构建路径里去。 androidTest 此处是用来编写Android Test测试用例的，可以对项目进行一些自动化测试。 java 毫无疑问，java目录是放置我们所有Java代码的地方，展开该目录，你将看到我们刚才创建的Hello Worldactivity文件就在里面。 res 这个目录下的内容就有点多了。简单点说，就是你在项目中使用到的所有图片、布局、字符串等资源都要存放在这个目录下。当然这个目录下还有很多子目录，图片放在 drawable目录下，布局放在layout目录下，字符串放在values目录下,所以你不用担心会把整个res目录弄得乱糟糟的。 AndroidManifest.xml 这是你整个Android项目的配置文件，你在程序中定义的所有四大组件都需要在这个文件里注册，另外还可以在这个文件中给应用程序添加权限声明。由于这个文件以后会经常用到，我们用到的时候再做详细说明。 test 此处是用来编写Unit Test测试用例的，是对项目进行自动化测试的另一种方式。 gitignore 这个文件用于将app模块内的指定的目录或文件排除在版本控制之外，作用和外层的 .gitignore文件类似。 app.iml IntelliJ IDEA项目自动生成的文件，我们不需要关心或修改这个文件中的内容。 build.gradle 这是app模块的gradle构建脚本，这个文件中会指定很多项目构建相关的配置，我们稍后将会详细分析gradle构建脚本中的具体内容。 proguard-rules.pro 这个文件用于指定项目代码的混淆规则，当代码开发完成后打成安装包文件，如果不希望代码被别人破解，通常会将代码进行混淆，从而让破解者难以阅读。 这样整个项目的目录结构就都介绍完了，如果你还不能完全理解的话也很正常，毕竟里面有太多的东西你都还没接触过。不过不用担心，这并不会影响到你后面的学习。等你学完整本书再回来看这个目录结构图时，你会觉得特别地清晰和简单。 接下来我们一起分析一下MyApplication项目究竟是怎么运行起来的吧。首先打开AndroidManifest.xml文件，从中可以找到如下代码 proguard-rules.pro程序示例一 这段代码表示对MainActivity这个活动进行注册，没有在Androidmanifest.xml里注册的活动是不能使用的。其中intent-filter里的两行代码非常重要， proguard-rules.pro程序示例二 表示MainActivity是这个项目的主活动，在手机上点击应用图标，首先启动的就是这个活动。 那MainActivity具体又有什么作用呢？我在介绍Android四大组件的时候说过，活动是 Android应用程序的门面，凡是在应用中你看得到的东西，都是放在活动中的。因此我们看到的界面，其实就是MainActivity这个活动。那我们快去看一下它的代码吧，打开MainActivity，代码如下所示 public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; &#125; 首先我们可以看到, MainActivity是继承自AppCompatActivity的，这是一种向下兼容的Activity，可以将Activity在各个系统版本中增加的特性和功能最低兼容到Android2.1系统。Activity是Android系统提供的一个活动基类，我们项目中所有的活动都必须继承它或者它的子类才能拥有活动的特性（Appcompatactivity是Activity的子类)。然后可以看到MainActivity中有一个onCreate()方法，这个方法是一个活动被创建时必定要执行的方法, 其中只有两行代码，并且没有Hello World!的字样。 Android程序的设计讲究逻辑和视图分离，因此是不推荐在活动中直接编写界面的，更加通用的一种做法是，在布局文件中编写界面，然后在活动中引入进来。可以看到，在onCreate()方法的第二行调用了setContentvlew()方法，就是这个方法给当前的活动引入了一个activity_main layout布局，那HelloWorld!一定就是在这里定义的了!我们快打开这个文件看一看。 布局文件都是定义在res/layout目录下的，当你展开layout目录，你会看到activity_main.xml这个文件。打开该文件并切换到Text视图,代码如下所示: proguard-rules.pro程序示例三 现在还看不懂？没关系，后面我会对布局进行详细讲解的，你现在只需要看到上面代码中有一个TextView，这是Android系统提供的一个控件，用于在布局中显示文字的。然后你终于在Text View中看到了HelloWorld!的字样！哈哈！终于找到了，原来就是通过android:text=” Hello World!”这句代码定义的。","path":"2021/06/06/分析你的第一个Android程序/","date":"06-06","excerpt":"分析你的第一个Android程序Android模式的项目结构回到Android Studio当中，首先展开MyApplication项目，你会看到如图（Android模式的项目结构）所示的项目结构。 Android模式的项目结构 切换项目结构模式 任何一个新建的项目都会默认使用Android模式的项目结构，但这并不是项目真实的目录结构，而是被Android Studio转换过的。这种项目结构简洁明了，适合进行快速开发，但是对于新手来说可能并不易于理解。点击图（Android模式的项目结构）当中的Android区域可以切换项目结构模式，如图（切换项目结构模式）所示。 切换项目结构模式","tags":[]},{"title":"如何阅读一本书","text":"蒙田说：“初学者的无知在于未学，而学者的无知在于学后。”第一种的无知是连字母都没有学过，当然无法阅读。第二种的无知却是读错了许多书。英国诗人亚历山大·蒲伯称这种人是书呆子，无知的阅读者。 希腊人给这种集阅读与愚蠢于一身的人一种特别称呼，这也可运用在任何年纪，好读书却读不懂的人身上。他们就叫“半瓶醋”。 为什麽许多人认为，比起辅助型学习，思考与非辅助型或研究型的自我发现学习更有关联，是因为他们假定阅读与倾听是丝毫不需要花力气的事。 我们称之为层次，而不称为种类的原因是，严格来说，种类是样样都不相同的，而层次却是再高的层次也包含了较低层次的特性。 佛兰西斯·培根曾经说过：“有些书可以浅尝即止，有些书是要生吞活剥，祇有少数的书是要咀嚼与消化的。” 大学的文凭应该代表著一般大学生毕业生的阅读水平，不但能够阅读任何一种普通的资料，还能针对任何一种主题做个人的研究。 无限制的受教育机会是一个社会能提供给人们最有价值的服务。 略读或粗读是检视阅读的第一个子层次。你脑中的目标是要发现这本书值不值得多花时间仔细阅读。其次，就算你决定了不再多花时间仔细阅读这本书，略读也能告诉你许多跟这本书有关的事。 不要忽略最后两三页，因为可能有作者整理的观点。 无论如何，任何複杂的工具其实都比不上你的一双手来得有用，你可以利用双手训练自己的眼睛，跟著章节段落移动得越来越快，你可以自己做这样的训练：将大拇指与食指、中指合併在一起，用这个“指针”顺著一行一行的字移动下去，速度要比你眼睛感觉的还要快一点。 理解力，是比回答书本内容一些简单问题还要多一点的东西。那种有限的理解力，不过是小学生回答“这是在说什麽？”之类问题的程度而已。一个读者要能够正确地回答许多更进一步的问题，才表示有更高一层的理解力。 在阅读一本书的时候，慢不该慢到不值得，快不该快到有损于满足与理解。 最后，在第一次阅读一本难读的书时，不要企图瞭解每一个字句。 任何一种超越基础阅读的阅读层次，核心就在你要努力提出问题（然后你儘可能地找出答案）。 人们在读一本好书的时候会打瞌睡，并不是读书的本身在让他们疲倦，而是因为他们欠缺有效运用自我提昇的技巧，在挫败中产生了沮丧，因而才感到厌倦。 俗话说：“你必须读出言外之意，才会有更大的收穫。” 阅读，如果是主动的，就是一种思考，而思考倾向于用语言表达出来——不管是用讲的还是写的。一个人如果说他知道他在想些什麽，却说不出来，通常他是其实并不知道自己在想些什麽。 所谓艺术或技巧，只属于那个能养成习惯，而且能依照规则来运作的人。 严格来说，对艺术家或雕塑家而言，世界上并没有最终的、不可打破的规则。但是画家或雕塑家一定要依循某些规则，否则他就没办法完成他想要做的作品了。 为了要忘掉这些单一的动作，一开始你必须先分别学会每一个单一的动作。 规则的多样化，意味著要养成一个习惯的複杂度，而非表示要形成许多个不同的习惯。在到达一个程度时，每个分开的动作自然会压缩、连结起来，变成一个完整的动作。当所有相关动作都能相当自然的做出来时，你就已经养成做这件事的习惯了。 你一定要知道自己在读的是哪一类书，而且要越早知道越好。 任何一本书，如果主要的内容是由一些观点、理论、假设、推断所组成，并且作者多少表示了这些主张是有根据的，有道理的，那这种书传达知识的书，就是一本论说性的书。 实用是与某种有效的做法有关，不管是立即或长程的功效。而理论所关注的却是去明白或瞭解某件事。 质疑某件事的有效性是理论，而质疑任何事的目的，却是实用。 历史的本质就是口述的故事，历史是某个特殊事件的知识，不只存在于过去，而且还历经时代的不同有一连串的演变。历史家在描述历史时，通常会带有个人色彩——个人的评论、观察或意见。 历史就是在处理一些发生在特定时间，特定地点的真实事件。","path":"2021/05/19/如何阅读一本书/","date":"05-19","excerpt":"蒙田说：“初学者的无知在于未学，而学者的无知在于学后。”第一种的无知是连字母都没有学过，当然无法阅读。第二种的无知却是读错了许多书。英国诗人亚历山大·蒲伯称这种人是书呆子，无知的阅读者。 希腊人给这种集阅读与愚蠢于一身的人一种特别称呼，这也可运用在任何年纪，好读书却读不懂的人身上。他们就叫“半瓶醋”。 为什麽许多人认为，比起辅助型学习，思考与非辅助型或研究型的自我发现学习更有关联，是因为他们假定阅读与倾听是丝毫不需要花力气的事。 我们称之为层次，而不称为种类的原因是，严格来说，种类是样样都不相同的，而层次却是再高的层次也包含了较低层次的特性。 佛兰西斯·培根曾经说过：“有些书可以浅尝即止，有些书是要生吞活剥，祇有少数的书是要咀嚼与消化的。” 大学的文凭应该代表著一般大学生毕业生的阅读水平，不但能够阅读任何一种普通的资料，还能针对任何一种主题做个人的研究。 无限制的受教育机会是一个社会能提供给人们最有价值的服务。 略读或粗读是检视阅读的第一个子层次。你脑中的目标是要发现这本书值不值得多花时间仔细阅读。其次，就算你决定了不再多花时间仔细阅读这本书，略读也能告诉你许多跟这本书有关的事。 不要忽略最后两三页，因为可能有作者整理的观点。 无论如何，任何複杂的工具其实都比不上你的一双手来得有用，你可以利用双手训练自己的眼睛，跟著章节段落移动得越来越快，你可以自己做这样的训练：将大拇指与食指、中指合併在一起，用这个“指针”顺著一行一行的字移动下去，速度要比你眼睛感觉的还要快一点。 理解力，是比回答书本内容一些简单问题还要多一点的东西。那种有限的理解力，不过是小学生回答“这是在说什麽？”之类问题的程度而已。一个读者要能够正确地回答许多更进一步的问题，才表示有更高一层的理解力。 在阅读一本书的时候，慢不该慢到不值得，快不该快到有损于满足与理解。","tags":[]},{"title":"8086宏汇编语言的源程序组成","text":"8086宏汇编语言的源程序组成源程序的分段结构 汇编语言源程序，是指用汇编语言的语句按汇编语言的语法结构编写而成的程序。这种源程序需要转换成机器语言程序，才能在计算机中运行；完成这种转换的工具软件称为汇编程序，而转换过程称为对源程序的汇编。宏汇编语言的汇编程序称为宏汇编程序。 汇编语言源程序釆用分段结构，将程序中的指令代码、数据变量、堆栈等分别定义在不同的主存段中。典型地，一个源程序包含三个段：代码段、数据段和堆栈段，其段地址分别存于段寄存器CS、DS和SS中。 由于一个主存段最大只有64KB，所以在一个段的存储容量不够时（如数据量过大， 程序代码过多等），可以多定义一些段（如定义多个数据段、多个代码段等）；有时，为使程序的结构更为合理、清晰，也会根据需要多定义几个段。总之，一个源程序可包含的段数是未受限制的。但是，8086 CPU只提供了4个段寄存器，所以，在一个源程序中最多只能同时操作4个段，如果需要操作当前4个段之外的其他段，必须先将该段的段地址存入某个段寄存器才行，当然，这样做会使该段寄存器原来定位的段变为不可操作。 汇编语言的语句结构 汇编语言源程序由一条条语句组成，这些语句用来描述程序中所需的各种操作，如段定义、变量定义、操作指令等。汇编语言语句的一般格式如下： ［名字项］操作项［操作数项］［;注释项］ 其中，带[]括号的为可选项。 汇编语言语句 根据语句所起作用的不同，汇编语言语句可以分为下列三类。 伪指令语句 伪指令语句用来说明程序运行的处理器平台，进行段定义、变量与常量定义、过程定义、宏定义以及源程序的开始与结束定义等。 伪指令语句所描述的操作，不是在程序运行时进行的，而是在汇编程序对源程序汇编的过程中进行的。也就是说，伪指令语句是用来指示汇编程序如何进行源程序汇编的，而不是用来直接实现程序操作功能的。 指令语句 一条指令语句包含一条汇编语言指令，程序的操作功能是由指令语句来实现的。指令语句经汇编形成机器指令，在程序运行时执行。 宏指令语句 宏指令是宏汇编语言允许程序员自定义的一种特殊形式的指令。一条宏指令实际上是由若干条指令组成的，相当于一小段程序。宏指令经定义后，可以像指令一样在源程序中使用。描述宏指令使用的语句就叫宏指令语句。 名字项 名字项就是一个符合特定规则的字符串，其最大长度不超过31个字符。组成名字项的字符规定为：26个英文字母（不分大、小写），数字符0〜9，以及?，.，_，@，$等。其中，数字不能作为名字项的第一个字符，而点号（.）只能作为第一个字符。 对不同类型的语句，名字项描述的对象有所不同。 伪指令语句中的名字项 伪指令语句中的名字项涉及如下。 段定义语句中的段名 段名具有段地址属性；源程序中使用段名主要就是利用其段地址属性获取段地址信息。此外，在进行多模块程序设计时，连接程序将把多个模块中段名相同的段按一定的方式进行连接，形成一个段。 变量定义语句中的变量名 变量经定义后，在源程序中可以直接用变量名对变量进行操作。变量名具有三个属性：类型属性、段地址属性和偏移地址属性。 类型属性体现变量的数据类型。8086汇编语言的变量类型有：字节类型、字类型、双字类型、四字类型和十字节类型。在源程序中对变量进行操作时，必须注意适用什么类型的变量，以及变量类型与其他操作数的类型是否匹配等问题。 段地址属性和偏移地址属性是指，变量名包含了变量所在段的段地址和段内偏移地址信息。可以通过汇编语言提供的特殊操作，从变量名提取这两项地址信息。 替代符定义语句中的替代符 替代符代表了所定义的对象。可替代的对象包括常量表达式以及其他合法表达式。替代符经定义后，可在源程序中直接引用，代表其所定义的对象。 过程定义语句中的过程名 过程也就是子程序。过程经定义后，在源程序中就可以直接通过过程名来调用过程。过程名也具有三个属性：类型属性、段地址属性和偏移地址属性。 类型属性体现过程的类型。过程有近（near）和远（far）两种类型。near类型是指所定义的过程与其调用程序均定义在同一个代码段内；far类型则指所定义的过程与其调用程序分别定义在不同的代码段内。两种类型的过程在调用与返回的操作上有所不同。 段地址属性和偏移地址属性与变量的这两个属性具有相同的意义。 宏定义语句中的宏指令名 宏指令名相当于宏指令的助记符，经定义后，就可以在源程序中使用。 指令语句中的名字项 指令语句中的名字项称为指令标号，使用时还需在指令标号后加上“：”，其使用格式为“指令标号：”。 指令标号的作用是标记当前指令的位置，通常在作为转移指令的目标指令上使用，以此指出目标指令的位置。 指令标号也有三个属性：类型属性、段地址属性和偏移地址属性。其中，类型属性有 近（near）和远（far）两种。如果一个指令标号是作为本代码段内的某条转移指令的转移目标，就是near类型；如果是作为其他代码段内转移指令的转移目标，即为far类型。段地址属性和偏移地址属性则与过程名的这两个属性具有相同的意义。 操作项 操作项用来描述一条语句的操作功能，是伪指令、指令或宏指令的操作助记符。除宏指令的操作助记符由程序员自定义外，其余两类均为汇编语言系统内部定义，程序员只能使用。 操作项是一条语句必不可少的组成部分。 操作数项 操作数项用来描述一条语句的操作对象。根据语句功能的不同，操作数项的数量不一， 也可以没有操作数项。在伪指令语句中，变量定义和常量定义语句需要操作数项来描述所定义的变量和常量，宏指令定义语句往往也需要操作数项来描述其参数；在指令语句中，一条指令所需要的操作数项是有规定的，对8086系统而言，根据指令的功能不同，其操作数项可以有一个、两个或者没有。 具体的操作数项可以是常量、变量、寄存器、指令标号、过程名、段名或表达式，其内容可以是数据或地址。 常量 常量的类型有数值常量和字符常量。 数值常量 数值常量可用十进制、二进制、十六进制或八进制形式表示，分别在所表示的数后用标记符号D、B、H或O加以区分；其中，十进制为默认数制，十进制数后可不用D进行标记。 对带符号数，可直接用+/-表示正/负号（即用数的真值表示），也可将数转换为补码表示。例如，下列均为正确的数值常量表示：95，-106，203CH，-1010010B （或用补码表示为10101110B）。 需要注意的是，在用十六进制表示数据时，如果数的最高位在A〜F范围内，必须在数的最高位上添加一个0，如0A234H，0D3CH，0B6H等。只有这样，汇编程序在汇编时才会将其当作十六进制常数处理，否则会被当作变量名、替代符或标号等进行处理。 此外，在描述数值常量时，要注意当前语句所处理的数据类型，不能超岀其数据表示范围。例如，在处理8位带符号数时，若出现128或-130这样的数据，就会产生错误。 字符常量 字符常量有两种表示方式：将字符置于一对单引号（或双引号）中表示，例如’字符’ （或”字符”）；或用字符的ASCII码表示，例如，字符A可表示为’A’、”A”或41H（或65, 01000001B等）。 字符数据在计算机中应按字节类型数据存储和处理，否则容易造成错误。 变量 变量需经定义方可使用。每个变量在主存中都占用一定数量的存储单元（视变量类型而定）。可以将数据存入变量，也可以将变量中所存的数据取出使用。 变量作为操作数项时，直接用其变量名表示。变量名的类型属性决定该变量的数据类型，地址属性指出该变量的存储地址。因此，对变量的操作，实际上就是按照变量的地址，向变量存入或从变量取出指定类型的数据。 寄存器 寄存器可以存放数据或地址，是指令语句中常用的操作数项。段寄存器用来存放段地址，部分16位寄存器（BX，BP，SI，DI，SP及IP）可用来存放段内偏移地址。寄存器存放地址信息时，是为了提供访问主存的地址。 指令标号和过程名 这两类操作数项主要作为程序控制类指令语句（如各种转移指令和过程调用指令）的操作对象，利用其类型属性及地址属性，准确实现程序执行流程的控制。 段名 段名具有段地址属性，使用段名作为操作数项就是为了获取段地址信息。 表达式 表达式是由常量、变量、指令标号、过程名等，与一些运算符所组成的运算式:通常，单个量也可称为表达式。表达式中允许使用圆括弧（）来改变运算的优先次序。 表达式只存在于源程序中，在汇编程序对源程序汇编期间完成计算。因此，程序真正投入运行时，都是直接使用表达式的计算结果作为操作数，而非临时进行计算的。正因如此，表达式中只能包含已知量，不能出现程序运行过程中动态确定的量。 表达式分数据表达式和地址表达式两类，其计算结果分别是数据和地址。 表达式中常用的运算符算术运算符 算术运算符有+（加）、-（减）、*（乘）、/（除后取商）和MOD（除后取余数）。 在对字符数据进行算术运算时，实际是对字符的ASCII码进行运算。此时需要注意运算的合理性。例如，两个字符之间的加、乘、除都是没有意义的；两个字符相减，可以理解为求两个字符ASCII码之间的距离，是有意义的；一个字符加或减一个常数，可以得到另一个字符的ASCII码，这也是有意义的。 对地址进行算术运算时，都是对偏移地址的运算，也要注意运算的合理性。例如，两个地址之间的加、乘、除都是没有意义的；两个地址之间相减，可以理解为求两个地址之间的距离（相隔的存储单元数），是有意义的；一个地址加或减一个常数，可以得到另一个地址，也是有意义的。 逻辑运算符 逻辑运算符有AND（与）、OR（或）、XOR（异或）和NOT（非）。 逻辑运算是一种按位运算。例如，逻辑表达式：·56H AND 0C3H`的运算过程如下： 01010110 AND 11000011 ------------- 01000010 其运算结果为01000010B（42H）。 逻辑运算符的优先次序由高到低是：NOT—&gt;AND—&gt;OR和XOR。 关系运算符 关系运算符有EQ（等于）、NE（不等于）、GT（大于）、LT（小于）、GE（大于等于）和LE（小于等于）。 关系运算符用于比较两个数之间的大小关系。如果关系成立，则表达式的运算结果为8位或16位全1（即0FFH或0FFFFH，视所处理数据的位数要求而定），否则结果为全0。 属性运算符 这类运算符专门针对变量和标号（包括过程名），用于获取其有关属性信息（如类型信息、地址信息等），或重新指定其有关属性。 属性运算符有很多，其中最常用的有OFFSET（取变量或标号的段内偏移地址）、SEG（取变量或标号的段地址）、PTR（重新指定变量、标号或地址表达式的访问类型）、段前缀（其形式是“段寄存器：”，用于指出所访问的变量或存储单元所在的段）、SHORT（无条件转移指令中，将用标号指出的转移目标指定为短距离）。 注释项 注释项必须以分号（；）开始，用于对一条语句的功能或作用等进行说明，以便于对源程序的阅读与理解。注释也可以单独作为源程序的一行（也以分号开始，称为注释行），用来说明其后一段程序的功能。适当地对源程序进行注释是一种良好的编程习惯。 注释项仅在源程序中可见，汇编程序在对源程序汇编时将忽略注释项。","path":"2021/05/18/8086宏汇编语言的源程序组成/","date":"05-18","excerpt":"8086宏汇编语言的源程序组成源程序的分段结构 汇编语言源程序，是指用汇编语言的语句按汇编语言的语法结构编写而成的程序。这种源程序需要转换成机器语言程序，才能在计算机中运行；完成这种转换的工具软件称为汇编程序，而转换过程称为对源程序的汇编。宏汇编语言的汇编程序称为宏汇编程序。 汇编语言源程序釆用分段结构，将程序中的指令代码、数据变量、堆栈等分别定义在不同的主存段中。典型地，一个源程序包含三个段：代码段、数据段和堆栈段，其段地址分别存于段寄存器CS、DS和SS中。 由于一个主存段最大只有64KB，所以在一个段的存储容量不够时（如数据量过大， 程序代码过多等），可以多定义一些段（如定义多个数据段、多个代码段等）；有时，为使程序的结构更为合理、清晰，也会根据需要多定义几个段。总之，一个源程序可包含的段数是未受限制的。但是，8086 CPU只提供了4个段寄存器，所以，在一个源程序中最多只能同时操作4个段，如果需要操作当前4个段之外的其他段，必须先将该段的段地址存入某个段寄存器才行，当然，这样做会使该段寄存器原来定位的段变为不可操作。 汇编语言的语句结构 汇编语言源程序由一条条语句组成，这些语句用来描述程序中所需的各种操作，如段定义、变量定义、操作指令等。汇编语言语句的一般格式如下： ［名字项］操作项［操作数项］［;注释项］ 其中，带[]括号的为可选项。","tags":[{"name":"汇编语言","slug":"汇编语言","permalink":"http://www.huangzihan.top/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"name":"8086系统","slug":"8086系统","permalink":"http://www.huangzihan.top/tags/8086%E7%B3%BB%E7%BB%9F/"},{"name":"寄存器","slug":"寄存器","permalink":"http://www.huangzihan.top/tags/%E5%AF%84%E5%AD%98%E5%99%A8/"}]},{"title":"存储器","text":"存储器8086系统的主存及其分段模式 计算机的存储器包括主存（也称内存）和辅存（也称外存，如硬盘存储器）。因为CPU只能直接访问计算机的主存，所以，CPU所执行的程序和处理的数据都是存在主存中的， 程序员编程时只需与主存打交道即可。 主存需要有较大的容量，才能使计算机高效地工作。主存容量是以存储单元的数量来计算的。现在，大多数计算机以1字节（8位二进制）的大小来定义一个存储单元，即一个存储单元可以存储一个8位二进制数，并常用以下符号表示存储容量的量级：KB（2^10 字节）、MB （2^20 字节）、GB（2^30 字节）以及TB（2^40 字节）。 为了准确描述数据在主存中的存储位置，计算机系统对主存的每个存储单元（字节）从0开始连续编号，并以此编号来确定存储单元的位置。存储单元编号也称为存储单元的地址，无论是向主存存数据（也称写数据），还是从主存取数据（也称读数据），都必须指出存储单元的地址才行。 地址是存储单元的编号，地址（编号）的位数决定了主存可以拥有的最大存储单元数。一般而言，如果计算机系统的地址位数为n位（二进制位），则其主存的最大容量可以达到2^n字节。例如，8086系统的主存地址位数是20位，其主存容量最大为2^20字节=1MB；80486系统的主存地址位数是32位，其主存容量最大可达2^32字节=4GB。 地址是在CPU对主存做读/写操作时，由CPU向主存发出的。所以，地址是在CPU中形成的。对8086系统，CPU要形成20位的主存地址，但是，CPU内部用于存放地址信息的寄存器均为16位寄存器（如前所述），无法存放一个完整的主存地址，为此，8086系 统对主存的使用采取了分段模式。 分段模式下，一个段的最大容量被限制在64KB，即2^16字节，因此，在一个段的范围内，只需16位地址就可以准确指出每个存储单元，16位的地址也可以用16位寄存器来存放了。但是，这个16位地址只是相对于一个段的内部来定义的，称为段内地址（或段内偏移地址），并不是20位的主存实际地址（也称主存物理地址），并不能直接用来访问主存。图（段内偏移地址与物理地址的关系）所示为段内偏移地址与主存物理地址的关系。 段内偏移地址与物理地址的关系 图（段内偏移地址与物理地址的关系）中，从物理地址处开始，定义了一个段，物理地址i称为该段的段首地址，简称段地址。显然，段内一个存储单元的物理地址是该存储单元的段内偏移地址与该段的段地址之和。由此可见，要得到段内一个存储单元的物理地址，除了需要该存储单元的段内偏移地址，还必须有该段的段地址。也就是说，在8086系统的主存分段模式下，一个存储单元的地址要用段地址和段内偏移地址两部分表示，这样表示的地址也称为逻辑地址，是汇编语言程序设计时所用的地址表示形式。 由于段地址本身是一个20位的物理地址，而CPU中用来存放段地址的段寄存器均为16位寄存器，如何解决这个矛盾呢？为此，8086系统规定，只有能被16整除的物理地址才能作为段地址；这样的物理地址其二进制表示形式有如下特征： xxxxxxxxxxxxxxxx0000 其中，X表示0或1。由于段地址的最低4位必为0，所以，CPU中的段寄存器实际只存放了段地址的高16位，这就解决了段地址在CPU中的表示问题。而CPU中专设的地址加法器，会在将逻辑地址转换成物理地址时，自动在16位段地址低位部分添加4个0，然后再与段内偏移地址相加。 8086系统中，逻辑地址通常表示为段地址：段内偏移地址 的格式。设某存储单元的逻辑地址用十六进制表示为138D：0200，求该存储单元的物理地址。 解：首先在段地址低位添0（对十六进制，只需添一个0），得到实际的段首地址138D0H，然后再与段内偏移地址0200H相加 138D0H + 0200H &#x3D; 13AD0H 所以，该存储单元的物理地址为13AD0H（二进制表示为00010011101011010000）。 数据在主存中的存储方式 8086系统中，根据数据的位数不同，定义了以下几种数据类型。 字节类型：数据位数为8位（1字节），在主存中存储时占用1个存储单元。 字类型：数据位数为16位（2字节），在主存中存储时占用2个存储单元。 双字类型：数据位数为32位（4字节），在主存中存储时占用4个存储单元。 四字类型：数据位数为64位（8字节），在主存中存储时占用8个存储单元。 十字节类型：数据位数为80位（10字节），在主存中存储时占用10个存储单元。 可见，数据位数均为字节的整数倍；位数多于1字节的，称为多字节数据。一个多字节数据在主存中存储时，需要占用地址连续的多个存储单元，数的低位字节存储在地址较低的存储单元，而该多字节数所占用的最低地址，就作为该数的地址。图（多字节数存储示例）所示为双字数据3A625C89H在主存中的存储情况，该数的地址为21004H。 段内偏移地址与物理地址的关系","path":"2021/05/18/存储器/","date":"05-18","excerpt":"存储器8086系统的主存及其分段模式 计算机的存储器包括主存（也称内存）和辅存（也称外存，如硬盘存储器）。因为CPU只能直接访问计算机的主存，所以，CPU所执行的程序和处理的数据都是存在主存中的， 程序员编程时只需与主存打交道即可。 主存需要有较大的容量，才能使计算机高效地工作。主存容量是以存储单元的数量来计算的。现在，大多数计算机以1字节（8位二进制）的大小来定义一个存储单元，即一个存储单元可以存储一个8位二进制数，并常用以下符号表示存储容量的量级：KB（2^10 字节）、MB （2^20 字节）、GB（2^30 字节）以及TB（2^40 字节）。 为了准确描述数据在主存中的存储位置，计算机系统对主存的每个存储单元（字节）从0开始连续编号，并以此编号来确定存储单元的位置。存储单元编号也称为存储单元的地址，无论是向主存存数据（也称写数据），还是从主存取数据（也称读数据），都必须指出存储单元的地址才行。 地址是存储单元的编号，地址（编号）的位数决定了主存可以拥有的最大存储单元数。一般而言，如果计算机系统的地址位数为n位（二进制位），则其主存的最大容量可以达到2^n字节。例如，8086系统的主存地址位数是20位，其主存容量最大为2^20字节=1MB；80486系统的主存地址位数是32位，其主存容量最大可达2^32字节=4GB。 地址是在CPU对主存做读/写操作时，由CPU向主存发出的。所以，地址是在CPU中形成的。对8086系统，CPU要形成20位的主存地址，但是，CPU内部用于存放地址信息的寄存器均为16位寄存器（如前所述），无法存放一个完整的主存地址，为此，8086系 统对主存的使用采取了分段模式。","tags":[]},{"title":"计算机中的数据存储","text":"计算机中的数据存储 汇编语言在处理数据时，必须准确指出数据存储的地方。计算机中可用于存储数据的装置有：CPU内部的寄存器；计算机的存储器；I/O端口（即I/O设备接口中的一些寄 存器）。 下面介绍8086系统的数据存储。 寄存器 图（8086的寄存器）所示为8086CPU中用于汇编语言程序设计的全部寄存器。根据用途不同，这些寄存器被分为三组：通用寄存器、专用寄存器和段寄存器。每个寄存器都有一个符号标志，作为寄存器的助记符。编程时，若所用数据存在某个寄存器中，就用其助记符来指出。 8086的寄存器 通用寄存器 通用寄存器用途多样，使用灵活，是编程时主要使用的寄存器。 AX寄存器 AX为16位寄存器，可以存放一个16位定点数，是使用最多的寄存器。AX在系统中有特殊的地位，称为16位累加寄存器，一些指令指定用AX存储数据。合理使用AX，还可以有效提高一些指令的时、空效率。 AX还可以分解为两个8位寄存器AH和AL。AH和AL可以作为独立的8位寄存器使用，也可以组合成16位的AX使用（AH为高8位，AL为低8位）。例如，若（AX）= 458EH，则(AH)= 45H，（AL） = 8EH。 在处理8位数据时，AL具有与AX类似的地位，称为8位累加寄存器。 BX、CX、DX寄存器 这三个寄存器也都是16位寄存器，也都能分解为两个8位寄存器使用（如图8086的寄存器所示）。 8086的FLAGS寄存器 它们与AX有着相同的基本用途，但也有各自的独特用法，如BX中的内容可被用来生成一个存储器地址，以便据此访问存储器；CX在一些指令中被指定作为计数器使用；DX则在某些指令中被指定与AX配合，存储一个32位数。 BP寄存器 BP是不能分解的16位寄存器，可以存放一个16位数据，其所存内容也可用来生成一个存储器地址，并据此访问存储器。 SI和DI寄存器 这两个寄存器也都是不能分解的16位寄存器，其基本用途与BP相似，且在某些指令中被指定使用。 专用寄存器 这几个专用寄存器都有专一的用途，不可挪作他用。 SP寄存器 SP也叫堆栈指针，是一个16位寄存器，存放的是堆栈栈顶的地址，其内容将随着进栈和出栈操作而动态改变。 IP寄存器 IP也叫指令指针，是一个16位计数寄存器，用来提供下一条要执行的指令的地址。CPU就是根据IP提供的指令地址，到存储器中取出要执行的指令，并执行该指令的。一 条指令被取出后，CPU会修改IP中的地址，使其指向下一条指令……如此进行下去，CPU就能把整个程序全部执行完。 在汇编语言中，不能显式使用IP，只有控制程序执行流程的一类指令（程序控制类指令）能够隐式修改IP中的内容。 FLAGS寄存器 FLAGS为16位寄存器，是CPU中的状态标志寄存器。8086系统使用该寄存器中的9位，记录了9种状态标志，如图（8086的FLAGS）所示。 8086的FLAGS寄存器 这些状态标志可分为两大类：条件标志和控制标志。 条件标志 条件标志记录运算所产生的一些状态，程序中可以根据这些状态决定后续的操作。也就是说，条件标志是用来决定程序后续操作的条件。FLAGS中的条件标志有6个。 CF标志（进位/借位标志）：主要用于记录加、减运算时，最高位上产生的进位或借位状态。CF=0，无进位或借位；CF=1，有进位或借位。 AF标志（辅助进位/借位标志）：用于记录加、减运算时，第3位上产生的进位或借位状态。AF=0，无进位或借位；AF=1，有进位或借位。 ZF标志（零标志）：用于记录运算结果是否为0。ZF=0，运算结果不为0；ZF=1, 运算结果为0。 SF标志（符号标志）：用于记录运算结果的符号位（或最高位）状态。SF=0，符号位为0（表示正号）；SF=1，符号位为1（表示负号）。该标志主要用于带符号数（补码）运算。 OF标志（溢出标志）：主要用于记录带符号数（补码）加、减运算时的溢出状态。OF=0，无溢出；OF=1，有溢出。 PF标志（奇偶标志）：用于记录运算结果的低8位中，“1”的个数是奇数个还是偶数个。PF=0，奇数个1；PF=1，偶数个1。该标志用于对数据进行奇偶校验。 分析以下加法运算后，各条件标志的状态 0 1 0 1 0 1 1 0 + 1 0 1 1 Q 1 1 1 -------------------- [1] 0 0 0 0 1 1 0 1 分析：由运算结果可知，最高位上产生了进位[1]，因此CF=1 （在计算机中，该进位不被纳入运算结果，而是记录在CF标志位上，如后续运算需要此进位，可从CF取得）；由 式中可知，第3位（式中带下画线的位）未产生进位，故AF=0；运算结果（排除最高位的进位，下同）不为0，所以ZF=0；运算结果中的最高位（对带符号数而言，为符号位）为0，故SF=0；如将式中两数视为带符号数的补码，则为异号数相加，其和不会溢出，所以OF=0；运算结果的8位二进制数中，共有3个1，3为奇数，故PF=0。 控制标志 控制标志用于对CPU的某些工作方式进行控制，可通过专门的指令对其进行设置。FLAGS中的控制标志有3个。 DF标志（方向标志）：用于在字符串操作时，控制串指针的修改方向。DF=O，增量修改；DF=1，减量修改。 IF标志（中断标志）：用于决定是否允许CPU响应外部的可屏蔽中断请求。IF=O，禁止响应；IF=1，允许响应。 TF标志（陷阱标志）：用于决定CPU是否以单步（也称单步陷阱）方式工作。TF=0，禁止单步方式；TF=1，允许单步方式。单步方式用于程序调试。在此方式下，CPU每执行完一条指令就会产生单步陷阱，暂停后续指令的执行。调试人员可以在此检查程序的执行状况是否正常，以便发现和排除程序中的错误。 段寄存器 8086系统由于硬件条件的限制，对存储器的使用釆取分段模式。此模式下，存储器地址分成段地址和段内偏移地址两部分表示。段寄存器就是专门用来存放段地址的寄存器。 8086系统中，一个汇编语言程序最多可以同时操作4个活跃的段，所以共设有4个段寄存器，均为16位寄存器。 CS寄存器 CS是代码段寄存器，存放代码段的段地址。代码段是存储程序中指令代码的段。 DS寄存器 DS是数据段寄存器，存放数据段的段地址。数据段是存储程序中定义的各种变量的段。 ES寄存器 ES是附加段寄存器，存放附加数据段的段地址。当一个数据段的存储空间不够用时，可以定义附加数据段。 SS寄存器 SS是堆栈段寄存器，存放堆栈段的段地址。堆栈段是在程序中作为堆栈使用的存储段。","path":"2021/05/18/计算机中的数据存储/","date":"05-18","excerpt":"计算机中的数据存储 汇编语言在处理数据时，必须准确指出数据存储的地方。计算机中可用于存储数据的装置有：CPU内部的寄存器；计算机的存储器；I/O端口（即I/O设备接口中的一些寄 存器）。 下面介绍8086系统的数据存储。 寄存器 图（8086的寄存器）所示为8086CPU中用于汇编语言程序设计的全部寄存器。根据用途不同，这些寄存器被分为三组：通用寄存器、专用寄存器和段寄存器。每个寄存器都有一个符号标志，作为寄存器的助记符。编程时，若所用数据存在某个寄存器中，就用其助记符来指出。 8086的寄存器 通用寄存器 通用寄存器用途多样，使用灵活，是编程时主要使用的寄存器。 AX寄存器 AX为16位寄存器，可以存放一个16位定点数，是使用最多的寄存器。AX在系统中有特殊的地位，称为16位累加寄存器，一些指令指定用AX存储数据。合理使用AX，还可以有效提高一些指令的时、空效率。 AX还可以分解为两个8位寄存器AH和AL。AH和AL可以作为独立的8位寄存器使用，也可以组合成16位的AX使用（AH为高8位，AL为低8位）。例如，若（AX）= 458EH，则(AH)= 45H，（AL） = 8EH。 在处理8位数据时，AL具有与AX类似的地位，称为8位累加寄存器。","tags":[]},{"title":"汇编语言的特点","text":"汇编语言的特点汇编语言与机器语言的关系 计算机的程序设计语言（简称计算机语言）是人们用来给计算机描述操作任务的工具。 由于计算机是一种数字逻辑设备，它只能识别用二进制代码表示的信息，所以，最初的计算机语言是直接用二进制代码来表述的，这就是机器语言。机器语言的基本要素是机器指令（简称指令），每条指令用于给计算机下达一个简单操作任务，一个复杂的解题任务需要按一定的顺序执行多条指令才能完成。这种按一定顺序排列起来的指令序列就是程序。 机器语言的优点是程序执行速度快、占用存储空间小，缺点是语言难以掌握，程序调试和排错困难，需要对计算机的硬件系统有较多的了解。 为了便于掌握和使用，人们将机器语言符号化，产生了汇编语言。汇编语言使用一些容易掌握和使用的符号来表示每条指令，使编程和调试更加方便。 例如，在8086系统中，以下机器指令代码 0000000111011000 所描述的操作为：将0号16位寄存器中的数据与3号16位寄存器中的数据相加，其和存入0号16位寄存器。这串二进制代码中，各部分所代表的含义如下图（机器指令代码分析）所示。 机器指令代码分析 显然，要熟练掌握和使用这种机器指令代码是很困难的。而汇编语言则把一条机器指令的操作性质和操作对象分别用符号表示。如在8086系统的汇编语言中，上述指令被符号化为： ADD AX , BX 其中，ADD代表相加操作，AX代表0号16位寄存器，BX代表3号16位寄存器。汇编语言指令中所使用的这些符号称为助记符，这种符号化的汇编语言指令显然更容易掌握和使用。 由于计算机不能直接理解汇编语言的符号系统，所以，需要一个转换工具来将用汇编语言编写的程序转换成机器语言程序，这个转换工具叫作汇编程序。 汇编语言与高级语言的主要差异 计算机的程序设计语言分为低级语言和高级语言两大类，其中，机器语言和汇编语言属于低级语言，其余均为高级语言。语言的“高级”与“低级”之分，并不是指语言之间的优劣，而是指语言的使用是否直接涉及计算机的硬件。高级语言在使用过程中，不用（或基本上不用）直接与计算机的硬件打交道，而使用低级语言则时刻需要直接操作计算机的硬件。 例如，用汇编语言编程时，必须准确指出数据存放的地方一一某个寄存器、某个存储单元或某个I/O端口，必须直接控制相关的设备完成数据的输入/输出。而用高级语言编程时，则无须关心一个数据究竟是存放在寄存器中，还是存放在内存中，而当需要输入或输出数据时，只要写出一条输入或输出语句即可，不用直接去控制相关的输入/输出设备。 相对于汇编语言，高级语言更便于描述复杂的程序控制结构及处理功能，更接近人们的语言习惯，并且基本上不直接涉及计算机硬件概念，所以更容易掌握和使用。但用任何一种高级语言编写的程序，都必须转换成机器语言程序才能被计算机执行。完成这种转换任务的工具叫作编译程序，每种高级语言都要配备自己的编译程序。 直接用汇编语言编程虽然困难一些，但编出的程序时、空效率高（即运行速度快，占用存储空间少）：而用高级语言编写的程序由编译程序转换为机器代码后，并不是最优化的执行代码，其时、空效率要低得多。此外，在需要直接控制计算机硬件的应用场合，汇编语言比高级语言更灵活、方便，甚至是非用汇编语言不可的。因此，汇编语言与高级语言各有其应用场合，学习和掌握汇编语言程序设计方法，是提高计算机应用能力的重要基础。 值得指出的是，低级语言是与计算机硬件系统的功能设计、组成结构密切相关的，因此，不同系列的计算机，其低级语言是不兼容的。尽管如此，其汇编语言的基本特点及程序设计的基本方法是相通的。","path":"2021/05/17/汇编语言的特点/","date":"05-17","excerpt":"汇编语言的特点汇编语言与机器语言的关系 计算机的程序设计语言（简称计算机语言）是人们用来给计算机描述操作任务的工具。 由于计算机是一种数字逻辑设备，它只能识别用二进制代码表示的信息，所以，最初的计算机语言是直接用二进制代码来表述的，这就是机器语言。机器语言的基本要素是机器指令（简称指令），每条指令用于给计算机下达一个简单操作任务，一个复杂的解题任务需要按一定的顺序执行多条指令才能完成。这种按一定顺序排列起来的指令序列就是程序。 机器语言的优点是程序执行速度快、占用存储空间小，缺点是语言难以掌握，程序调试和排错困难，需要对计算机的硬件系统有较多的了解。 为了便于掌握和使用，人们将机器语言符号化，产生了汇编语言。汇编语言使用一些容易掌握和使用的符号来表示每条指令，使编程和调试更加方便。 例如，在8086系统中，以下机器指令代码 0000000111011000 所描述的操作为：将0号16位寄存器中的数据与3号16位寄存器中的数据相加，其和存入0号16位寄存器。这串二进制代码中，各部分所代表的含义如下图（机器指令代码分析）所示。 机器指令代码分析 显然，要熟练掌握和使用这种机器指令代码是很困难的。而汇编语言则把一条机器指令的操作性质和操作对象分别用符号表示。如在8086系统的汇编语言中，上述指令被符号化为： ADD AX , BX 其中，ADD代表相加操作，AX代表0号16位寄存器，BX代表3号16位寄存器。汇编语言指令中所使用的这些符号称为助记符，这种符号化的汇编语言指令显然更容易掌握和使用。 由于计算机不能直接理解汇编语言的符号系统，所以，需要一个转换工具来将用汇编语言编写的程序转换成机器语言程序，这个转换工具叫作汇编程序。","tags":[]},{"title":"创建第一个Android项目","text":"创建第一个Android项目创建HelloWorld项目选择模板 在Android Studio的欢迎界面点击Start a new Android Studio project，会打开一个选择模板的界面，如下图所示： 选择模板 选择模板界面的英文翻译 英文 翻译 Phone and Tablet 手机和平板电脑 Wear OS 可穿戴智能设备 TV 电视 Android Auto 安卓汽车 Android Things 物联网和智能设备 Empty Activity 空活动 这里我们不仅可以选择创建手机和平板类型的项目，还可以选择创建可穿戴设备、电视，甚至汽车等类型的项目。不过手机和平板才是本书讨论的重点，其他类型的项目我们就不去关注了另外，Android Studio还提供了很多种内置模板，不过由于我们オ刚刚开始学习，用不着这么多复杂的模板，这里直接选择“ Empty Activity”，创建一个空的Activity就可以了。 配置项目继续点击Next，就会进入配置项目的界面，如下图所示： 一开始默认的项目路径 配置项目界面英文翻译及解释 英文 翻译 Configure you project 配置您的项目 Name （项目）名称 Package name （项目）包名 Language （编程）语言 Minimum API level 项目最低兼容版本 Your app will run on approximately xxx% of devices 您的应用程序可以在大约xxx%的设备上运行 This project will support instant apps 这个项目将支持即时应用 Previous 上一级 配置项目界面的注意事项Name的命名规范Name是项目名称，应用安装到手机之后会在手机上显示该名称。应用名称一开始显示的是My Application，这个名称含有空格，我直接把它改为MyApplication，这样一来就非常符合Java关键字规范（Kotlin也是基于Java写的），还有一个原因后面再说。 Package name的唯一性 Android系统就是通过包名来区分不同应用程序的，因此包名一定要具有唯一性。Android Studio会根据应用名称自动帮我们生成合适的包名，如果你不想使用默认生成的包名，也可以自行修改。 选择Minimum API levelMinimum API level，我们选择Your app will run on approximately 100% of devices这一项API15，也意味着我们的应用程序可以在任何的设备上都能运行。 Save location的常见错误你的项目路径包含非ASCII字符Your project path contains non-ASCII characters. 你的项目路径包含非ASCII字符 这种情况就像上面的截图一样，因为我计算机的用户名是黄子涵，所以默认就会出现这种情况，根据上面的提示，非ASCII字符，那啥是ASCII字符呢？一般来说，就是阿拉伯数字和大小写英文字母，这里我的是中文字符，所以就会报错，只要路径中是英文字母就好了。 项目位置不应该包含空格，这可能会导致问题NDK工具project location should not contain whitespace ,as this can cause problems with the NDK tools 项目位置不应该包含空格，这可能会导致问题NDK工具 这种情况就像下面的截图一样，大概意思就是我们项目路径不能有空格。这也是我上面把应用名称去掉空格的原因，我在AndroidStudioProjects文件夹下新建一个，直接把应用名称复制黏贴过去重命名，并把AndroidStudioProjects整个文件夹放到我的E盘下： 项目路径包含空格 项目创建成功点击finish就进入项目编辑界面，如下图： 项目创建成功 项目界面菜单栏英文翻译 英文 翻译 File 文件 Edit 编辑 View 视图 Navigate 导航 Code 代码 Analyze 分析 Refactor 重构 Build 构建 Run 运行 Tools 工具 VCS 编译型Verilog模拟器 Window 窗口 Help 帮助 创建和启动模拟器创建模拟器 由于Android Studio自动为我们生成了很多东西，你现在不需要编写任何代码， 项目就已经可以运行了。但是在此之前还必须要有一个运行的载体，可以是一部 Android手机，也可以是Android模拟器。 那么我们现在就来创建一个Android模拟器，观察Android Studio工具栏中的图标，下图红色划线部分的图标就是用来创建和启动模拟器的： 创建和启动模拟器的图标 当我们点击红色划线部分的图标，会弹出Android Virtual Devices Manager（安卓模拟器管理）的窗口： Android模拟器管理 查看模拟器细节目前我们的模拟器列表中有一个模拟器，鼠标移到模拟器上，右键点击，选择View Details查看模拟器的细节： 项目名称 相关信息 Name Nexus_5X_API_30_x86 CPU/ABI Google APIs Intel Atom (x86) Path C:\\Users\\黄子涵.android\\avd\\Nexus_5X_API_30_x86.avd Target google_apis [Google APIs] (API level 30) Skin: nexus_5x SD Card 800M 删除现有的模拟器但是这个模拟器和我的手机不一样，所以我们要先把这个模拟器删除，鼠标移到模拟器上，右键点击，选择delete，这样现有的模拟器就删除了，如下图： 删除模拟器之后 创建模拟器删除模拟器之后，我们现在需要新建一个模拟器，点击Create Virtual Device（创建模拟器）按钮就可以，如下图： 模拟器配置 新建硬件配置文件 这里有很多种设备可供我们选择，不仅能创建手机模拟器，还可以创建平板、手表、电视等模拟器。 但是，我在上面没有发现一个手机模拟器和华为荣耀9X的配置一样的，所以我们需要点击New Hardware Profile（新建硬件配置文件），进入硬件配置界面，如下图： 硬件文件配置 查看手机硬件配置信息首先我们要对调试的手机有所了解，我这里的华为荣耀9X，打开设置，下拉到最底部，点击关于手机里面查看手机的相关信息如下表： 名称 信息 设备名称 HONOR 9X Android版本 10 运行内存 6.0GB 屏幕 2340*1080 但是没有找到手机屏幕尺寸大小，百度搜索一下，是6.59英寸 配置硬件文件信息 在这里我们可以对模拟器的一些配置进行确认，比如说指定模拟器的名字、分辨率、横竖屏等信息，如果没有特殊需求的话，全部保持默认就可以了。 按照我们上面找到的硬件配置信息进行填写，填写完成之后，如下图： 配置硬件文件信息 成功新建硬件文件然后点击Finish完成模拟器的创建，然后会弹出如下图的窗口，我们可以在硬件文件列表上看到我们的模拟器，就证明我们已经成功新建硬件文件： 成功新建硬件文件 选择系统镜像接着点击next进入select a system image（选择一个系统镜像）界面，这里在上面我们已经查看调试模拟器的硬件信息，华为荣耀9X的Android操作系统的版本是Android 10，但是我发现这个Android 10还要下载，如下图： Android操作系统版本待下载 鼠标移动到Android 10那行，点击蓝色字体DownLoad进入同意许可证界面，点击acceptj选择接受许可证，再点击next，如下图： 同意许可证 点击next就会进入一个Component Installer（组件安装器）界面，表示组件正在下载： 请求的组件正在下载 等待下面Downloading进度条达到100%，点击finish重新回到select a system image（选择一个系统镜像）界面，这时候我们发现在Android 10的那一行已经没有Download蓝色字体了，就表示系统镜像已经下载成功，如下图所示： Android操作系统已下载 鼠标点击你要选择的Android操作系统版本的那一行，选中之后然后再点击next进入检查模拟器配置界面，： 检查模拟器配置 下载HAXM（硬件加速执行管理器）在这里我们可以看到Recommendation（建议）这里还没有下载HAXM，我们点击蓝色字体Install HAXM进入HAXM下载页面，如下图所示： 硬件加速执行管理器 没有别的需求选择recommend（建议的）就行了，再点击next进入调用安装程序界面，我们会看到它Installing（正在下载），等到我们看到successfully、Done就表示硬件加速执行器已经下载完成了，如下图所示： 调用安装程序 完成调用安装程序 等它下载完成之后，我们点击finish重新回到检查模拟器配置界面，如果我们还发现在Recommendation（建议）那里还有蓝色字体Install HAXM，没有关系只要我们上一步显示successfully、Done就表示硬件加速执行器已经下载完成了，这时候我们需要重新启动一次项目，把上面的流程重新走一遍，等我们再回到检查模拟器配置界面，会发现红色部分已经没有蓝色字体Install HAXM，如下图： HAXM已经安装 点击finish之后，我们会发现它弹出一个进度条，显示Creating Android Virtual Device（正在创建安卓模拟器），如下图： 正在创建模拟器 等到正在创建安卓模拟器的进度条完成之后，然后再回到Android Virtual Devices Manager（安卓模拟器管理）界面，就会看到模拟器列表中已经存在一个创建好的名叫HONOR 9X模拟器设备了，如下图： HONOR 9X模拟器 点击 Actions栏目中最左边的三角形按钮即可启动模拟器。模拟器会像手机一样，有一个开机过程，启动完成之后的界面，如下图所示： HONOR 9X模拟器 创建和启动模拟器过程中的常见错误新建模拟器不能启动开启虚拟化设备进入BIOS 开机——出现Lenovo字样—— 迅速按F2或Fn+F2。此种方法试了很多次并未找到BIOS。 我就使用这种方法就进入BIOS。 在BIOS开启虚拟化设备 进入BIOS——按键盘向右的箭头找到configuration选项—— 按键盘向下的箭头找到Intel virtual technology—— 按Fn+F5将disable改成enable——按fn+F10保存更改—— 回车“YES”——电脑自动重启——完成。 在我这里，Intel virtual technology已经是enable，所以不是开启虚拟化设备的问题。 安装硬件加速执行管理器在Android的SDK文件夹下有个可执行文件，可以直接点击安装，我这里的地址是： F:\\Android\\Sdk\\extras\\intel\\Hardware_Accelerated_Execution_Manager 但是，我在检查模拟器配置界面早就安装好了，所以也应该不是HAXM的问题。 设置Android相关的系统变量这个我是怎么发现的呢？是我开启模拟器之后，发现事件日志报错，事件日志在主界面的这个位置： 事件日志 在事件日志报错代码，有这样一行代码： Emulator: PANIC: Cannot find AVD system path. Please define ANDROID_SDK_ROOT 怪不得打不开模拟器，原来是没有设置AVD系统路径，在这里主要设置两个系统变量： ANDROID_HOME：这是sdk的路径 ANDROID_SDK_HOME：这是avd的路径 我的电脑是Win10系统，就拿我的电脑来举例，其他版本的系统需要百度一下。在桌面找到我的电脑或者此电脑，右键点击选择属性，会直接进入这个路径： 控制面板\\系统和安全\\系统 在系统窗口的左侧栏找到高级系统设置，如下图： 高级系统设置 点击高级系统设置，接着会弹出系统属性的窗口，选择高级那一项，选择下方的环境变量，如下图： 系统属性 在环境变量的窗口下面的系统变量那一栏中点击新建，在弹出的新建系统变量的窗口里填入以下信息，对于变量值可以直接复制地址栏的地址过来，也可以通过浏览目录或者浏览文件进行添加，我的设置是这样的： 变量名 变量值 说明 ANDROID_HOME F:\\Android\\Sdk 这是sdk的安装路径 ANDROID_SDK_HOME E:\\AndroidAvd 这是avd文件夹所在路径 填写完成之后，重启一下Android Studio就可以了。 安卓模拟器管理占用C盘内存我们首先找到安卓模拟器安装的位置，在我的电脑里是安装在这个路径下： C:\\Users\\黄子涵\\.android\\avd 一般来说，这个路径应该是这样的： C:\\Users\\计算机用户名\\.android\\avd 因为我这里计算机用户名是黄子涵（在电脑开机之后，输入密码时显示的那个用户名），所以Users下一级目录是黄子涵。 其中的avd文件夹就是用来存放，模拟器镜像文件的。相当占用c盘空间。 这句话说的不大对，应该是模拟器的操作系统镜像文件有点大，比如我这里是： 光盘映像文件大小 一个Android 10差不多500MB，如果以后继续添加操作系统的话，这个肯定是大块头，所以必须把它挪到其他磁盘。 首先，我们点进去我们之前说的这条路径C:\\Users\\黄子涵.android\\avd，现在这个路径下有一个AVD的文件夹和AVD的配置文件，格式像下面这样： HONOR_9X_API_29.avd HONOR_9X_API_29.ini ini格式文件就是我们要修改的配置文件，点进去会发现这样的一小段代码： avd.ini.encoding&#x3D;UTF-8 path&#x3D;C:\\Users\\黄子涵\\.android\\avd\\HONOR_9X_API_29.avd path.rel&#x3D;avd\\HONOR_9X_API_29.avd target&#x3D;android-29 path路径就是我们现在AVD存放路径，于是我到E盘新建一个存放AVD的文件夹，我直接存放在根目录下，还有这个文件夹命名为：AndroidAvd（这很符合Java的命名规范），我这样做的原因是，和我们之前的一个问题有关，文件夹路径不能包含空格和中文字符，所以我将要存放AVD的路径地址是： E:\\AndroidAvd 新建完存放AVD的文件夹之后，我们将原来AVD文件夹中的.avd文件夹移动到我们新建好存放AVD的文件夹中，过程如下图： 需要移动的.avd文件夹 把.avd文件夹移动到新建的文件夹 移动好.avd文件夹，将地址栏的地址复制好，开始修改ini配置文件中的path路径： 新建的AVD文件夹路径： E:\\AndroidAvd\\HONOR_9X_API_29.avd 原来ini配置文件中path路径： path&#x3D;C:\\Users\\黄子涵\\.android\\avd\\HONOR_9X_API_29.avd 修改好的ini配置文件中path路径： path&#x3D;E:\\AndroidAvd\\HONOR_9X_API_29.avd 最后，我们重新启动项目，点击AVD管理器进入Android Virtual Devices Manager（安卓模拟器管理）界面，我们点击模拟器那行Actions部分中的倒三角形会弹出一个下拉菜单栏，我们选择show in disk（在磁盘显示），就会弹出模拟器各类文件存放在磁盘的那个文件夹，，而这个文件夹就是我们刚刚新建的，这样就表示我们修改路径成功了，如下图 在磁盘显示模拟器文件夹","path":"2021/05/17/创建第一个Android项目/","date":"05-17","excerpt":"创建第一个Android项目创建HelloWorld项目选择模板 在Android Studio的欢迎界面点击Start a new Android Studio project，会打开一个选择模板的界面，如下图所示： 选择模板","tags":[]},{"title":"Android开发环境","text":"Android开发环境需要准备的工具 JDK Android SDK Android Studio 搭建开发环境集成安装包下载地址： http:&#x2F;&#x2F;www.android-studio.org&#x2F; 选择不导入配置选择下载 ANDROID STUDIO，下载完成之后，点击可执行文件android-studio-ide-191.5977832-windows.exe，它弹出一个对话框，让我们选择是否导入之前Android Studio版本的配置，因为我们是第一次，所以没有配置文件，这里就选择不导入： 选择不导入配置 无法访问add-on list的警告对话框然后弹出下面这样的对话框： 无法访问add-on list的警告对话框 这个对话框是在询问我们，无法访问Android SDK的ad- on list，是否要配置代理。由于我们使用的网络访问 Google的一些服务是受到限制的，因此オ会弹出这样一个对话框。不过这并不影响我们接下来的环境搭建，因此直接点击“Cancel”就可以了。 Android Studio的配置界面上面选择取消之后，就会进入Android Studio的配置界面，然后我们直接选择Next： Android Studio的配置界面 选择安装类型点击Next按钮之后，就开始进行具体配置，如下图： 选择安装类型 这里我们可以选择Android Studio的安装类型，有 Standard和Custom两种。Standard表示一切都使用默认的配置，比较方便;Custon则可以根据用户的特殊需求进行自定义。简单起见，这里我们就选择Standard类型了。继续点击“Next”会让你选择 Android Studio的主题风格。 选择Android Studio的主题风格 Android Studio内置了深色和浅色两种风格的主题，你可以根据自己的喜好选择。这里我就选择默认的浅色主题了，继续点击“Next”完成配置工作，如下图： 选择Android Studio的主题风格 选择SDK路径和虚拟设备接下来选择虚拟设备，用来进行测试（虽然我选择了虚拟设备，但是也会用手机进行调试，两种方法都尝试一下），还有SDK的安装位置，SDK安装的位置尽量不要安装在C盘，我把它安装Android Studio同一磁盘的根目录下（一开始它前面有个三角形提示你这个位置不能安装，只要你选择之后前面没有出现三角形就行了）： 选择SDK路径和虚拟设备 选择SDK的路径 确认设置点击“next”按钮，进入到下一步，这个界面会显示SDK组件的设置及其大小，如果我们之前的设置不需要改变的话，点击“finish”；如果需要改变，点击“previous”，返回上一级改变： 确认设置 Android Studio的欢迎界面 现在点击“Finish”按钮，配置工作就全部完成了。然后 Android Studio会尝试联网下载一些更新，等待更新完成后再点击“Finish”按钮，就会进入Android Studio的欢迎界面，如下图所示： Android Studio的欢迎界面 Android Studio欢迎界面的英文翻译 英文 翻译 Start a new Android Studio project 启动一个新的安卓工作室项目 Open an existing Android Studio project 导入现有的安卓工作室项目 Check out project from Version Control 从版本控制检出项目 Profile or debug APK 剖析或调试APK Import project（Gradle，Eclipse ADT，etc.） 导入项目(Gradle、Eclipse ADT等。) Import an Android code sample 导入一个安卓代码示例","path":"2021/05/17/Android开发环境/","date":"05-17","excerpt":"Android开发环境需要准备的工具 JDK Android SDK Android Studio 搭建开发环境集成安装包下载地址： http:&#x2F;&#x2F;www.android-studio.org&#x2F; 选择不导入配置选择下载 ANDROID STUDIO，下载完成之后，点击可执行文件android-studio-ide-191.5977832-windows.exe，它弹出一个对话框，让我们选择是否导入之前Android Studio版本的配置，因为我们是第一次，所以没有配置文件，这里就选择不导入： 选择不导入配置 无法访问add-on list的警告对话框然后弹出下面这样的对话框： 无法访问add-on list的警告对话框 这个对话框是在询问我们，无法访问Android SDK的ad- on list，是否要配置代理。由于我们使用的网络访问 Google的一些服务是受到限制的，因此オ会弹出这样一个对话框。不过这并不影响我们接下来的环境搭建，因此直接点击“Cancel”就可以了。","tags":[{"name":"Android","slug":"Android","permalink":"http://www.huangzihan.top/tags/Android/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"http://www.huangzihan.top/tags/Android-Studio/"}]},{"title":"Android应用开发特色","text":"Android应用开发特色四大组件 Activity Service Broadcastreceiver Contentprovider Activity Activity是所有Android应用程序的门面，凡是在应用中你看得到的东西，都是放在Activity中。 Service 你无法看到Service，但它会在后台默默地运行，即使用户退出了应用Service仍然是可以继续运行的。 Broadcastreceiver Broadcastreceiver允许你的应用接收来自各处的广播消息，比如电话、短信等，当然，你的应用也可以向外发出广播消息。 Contentprovider Contentprovider则为应用程序之间共享数据提供了可能，比如你想要读取系统通讯录中的联系人，就需要通过 Contentprovider来实现。 丰富的系统控件 Android系统为开发者提供了丰富的系统控件,使得我们可以很轻松地编写出漂亮的界面。当然如果你品位比较高，不满足于系统自带的控件效果，完全可以定制属于自己的控件。 Sqlite数据库 Android系统还自带了这种轻量级、运算速度极快的嵌入式关系型数据库。它不仅支持标准的SQL语法，还可以通过Android封装好的API进行操作，让存储和读取数据变得非常方便。 强大的多媒体 Android系统还提供了丰富的多媒体服务，如音乐、视频、录音、拍照等，这一切你都可以在程序中通过代码进行控制，让你的应用变得更加丰富多彩。","path":"2021/05/17/Android应用开发特色/","date":"05-17","excerpt":"Android应用开发特色四大组件 Activity Service Broadcastreceiver Contentprovider Activity Activity是所有Android应用程序的门面，凡是在应用中你看得到的东西，都是放在Activity中。 Service 你无法看到Service，但它会在后台默默地运行，即使用户退出了应用Service仍然是可以继续运行的。 Broadcastreceiver Broadcastreceiver允许你的应用接收来自各处的广播消息，比如电话、短信等，当然，你的应用也可以向外发出广播消息。 Contentprovider Contentprovider则为应用程序之间共享数据提供了可能，比如你想要读取系统通讯录中的联系人，就需要通过 Contentprovider来实现。 丰富的系统控件 Android系统为开发者提供了丰富的系统控件,使得我们可以很轻松地编写出漂亮的界面。当然如果你品位比较高，不满足于系统自带的控件效果，完全可以定制属于自己的控件。","tags":[{"name":"四大组件","slug":"四大组件","permalink":"http://www.huangzihan.top/tags/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"},{"name":"Activity","slug":"Activity","permalink":"http://www.huangzihan.top/tags/Activity/"},{"name":"Service","slug":"Service","permalink":"http://www.huangzihan.top/tags/Service/"},{"name":"Broadcastreceiver","slug":"Broadcastreceiver","permalink":"http://www.huangzihan.top/tags/Broadcastreceiver/"},{"name":"Contentprovider","slug":"Contentprovider","permalink":"http://www.huangzihan.top/tags/Contentprovider/"},{"name":"Sqlite","slug":"Sqlite","permalink":"http://www.huangzihan.top/tags/Sqlite/"}]},{"title":"Android系统架构","text":"Android系统架构 Linux内核层 系统运行库层 应用框架层 应用层 Android系统架构 Linux内核层 Android系统是基于Linux内核的，这一层为Android设备的各种硬件提供了底层的驱动，如显示驱动、音频驱动、照相机驱动、蓝牙驱动、Wi-Fi驱动、电源管理等。 系统运行库层 这一层通过一些C/C++库为Android系统提供了主要的特性支持。如 SQLite库提供了数据库的支持，OPENGL|ES库提供了3D绘图的支持，Webkit库提供了浏览器内核的支持等。 在这一层还有Android运行时库,它主要提供了一些核心库,允许开发者使用Java语言来编写Android应用。另外,,Android运行时库中还包含了Dalvik虚拟机（5.0系统之后改为ART运行环境），它使得每一个Android应用都能运行在独立的进程中，并且拥有一个自己的虚拟机实例。相较于Java虚拟机，Dalvik和ART都是专门为移动设备定制的，它针对手机内存、CPU性能有限等情况做了优化处理。 应用框架层 这一层主要提供了构建应用程序时可能用到的各种API,Android自带的一些核心应用就是使用这些API完成的，开发者可以使用这些API来构建自己的应用程序。 应用层 所有安装在手机上的应用程序都是属于这一层的，比如系统自带的联系人、短信等程序，或者是你从 Google Play上下载的小游戏，当然还包括你自己开发的程序。","path":"2021/05/17/Android系统架构/","date":"05-17","excerpt":"Android系统架构 Linux内核层 系统运行库层 应用框架层 应用层 Android系统架构 Linux内核层 Android系统是基于Linux内核的，这一层为Android设备的各种硬件提供了底层的驱动，如显示驱动、音频驱动、照相机驱动、蓝牙驱动、Wi-Fi驱动、电源管理等。 系统运行库层 这一层通过一些C/C++库为Android系统提供了主要的特性支持。如 SQLite库提供了数据库的支持，OPENGL|ES库提供了3D绘图的支持，Webkit库提供了浏览器内核的支持等。 在这一层还有Android运行时库,它主要提供了一些核心库,允许开发者使用Java语言来编写Android应用。另外,,Android运行时库中还包含了Dalvik虚拟机（5.0系统之后改为ART运行环境），它使得每一个Android应用都能运行在独立的进程中，并且拥有一个自己的虚拟机实例。相较于Java虚拟机，Dalvik和ART都是专门为移动设备定制的，它针对手机内存、CPU性能有限等情况做了优化处理。 应用框架层 这一层主要提供了构建应用程序时可能用到的各种API,Android自带的一些核心应用就是使用这些API完成的，开发者可以使用这些API来构建自己的应用程序。","tags":[{"name":"Linux内核层","slug":"Linux内核层","permalink":"http://www.huangzihan.top/tags/Linux%E5%86%85%E6%A0%B8%E5%B1%82/"},{"name":"系统运行库层","slug":"系统运行库层","permalink":"http://www.huangzihan.top/tags/%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E5%BA%93%E5%B1%82/"},{"name":"应用框架层","slug":"应用框架层","permalink":"http://www.huangzihan.top/tags/%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6%E5%B1%82/"},{"name":"应用层","slug":"应用层","permalink":"http://www.huangzihan.top/tags/%E5%BA%94%E7%94%A8%E5%B1%82/"}]},{"title":"第一行代码的思维导图","text":"第一行代码（第三版）书上的思维导图 Android Kotlin","path":"2021/05/17/第一行代码的思维导图/","date":"05-17","excerpt":"","tags":[]},{"title":"浏览文件系统","text":"浏览文件系统 当登录系统并获得shell命令提示符后，你通常位于自己的主目录中。 我一登录进去是这样的，第一行是登录时间，第二行是一个类似IP地址的东西，但是是哪里的IP地址，暂时不知道，最后是第三行，我搜索一下我之前的笔记，root是用户ID，huangzihan是系统名，#是bash shell提示符，然后#提示符之前应该是目录名，代码如下： Last login: Sun May 2 12:10:32 2021 from 113.116.156.243 root@huangzihan:~# 文件系统Windows的文件系统 你将注意到的第一个不同点是，Linux在路径名中不使用驱动器盘符。在Windows中，PC上安装的物理驱动器决定了文件的路径名。Windows会为每个物理驱动词驱动盘分配一个盘符，每个驱动器都会有自己的目录结构，以便访问存储其中的文件。 当我们双击点开我的电脑或者此电脑，可以看到设备和驱动器下有一个个命名为C、D、E、F的磁盘（物理驱动器），而这些C、D、E、F就是磁盘的符号。 举个例子在，Windows中经常看到这样的文件路径： D:\\linux-0.01内核\\.git\\hooks\\update.sample 这种Windows文件路径表明了文件update.sample究竟位于哪个磁盘分区中，这里我们可以看出这个文件位于我们的D盘。 如果你将test.doc保存在闪存上，该闪存由J来标识那么文件的路径就是J:\\test.doc。该路径表明文件位于J盘的根目录下。 Linux的文件系统虚拟目录 Linux则采用了一种不同的方式。Linux将文件存储在单个目录结构中，这个目录被称为虚拟目录（virtual directory） 根目录 Linux虚拟目录结构只包含一个称为根（root）目录的基础目录。根目录下的目录和文件会按照访问它们的目录路径一一列出，这点跟Windows类似。 窍门：你将会发现Linux使用正斜线（/）而不是反斜线（\\）在文件路径中划分目录。在Linux中，反斜线用来标识转义字符，要是用在文件路径中的话会导致各种各样的问题。 现在我们要进入这条路径/sys/kernel/debug/usb/ehci，操作代码如下： root@huangzihan:&#x2F;# ls -a . bin dev home lib32 libx32 media opt root sbin swapfile tmp var .. boot etc lib lib64 lost+found mnt proc run srv sys usr root@huangzihan:&#x2F;# cd sys&#x2F; root@huangzihan:&#x2F;sys# ls -a . .. block bus class dev devices firmware fs hypervisor kernel module power root@huangzihan:&#x2F;sys# cd kernel&#x2F; root@huangzihan:&#x2F;sys&#x2F;kernel# ls -a . cgroup fscaps kexec_crash_loaded livepatch profiling security tracing vmcoreinfo .. config iommu_groups kexec_crash_size mm rcu_expedited slab uevent_helper boot_params debug irq kexec_loaded notes rcu_normal software_nodes uevent_seqnum root@huangzihan:&#x2F;sys&#x2F;kernel# cd .. root@huangzihan:&#x2F;sys# cd kernel&#x2F; root@huangzihan:&#x2F;sys&#x2F;kernel# cd debug&#x2F; root@huangzihan:&#x2F;sys&#x2F;kernel&#x2F;debug# ls -a . cleancache dri gpio opp regmap split_huge_pages virtio-ports .. clear_warn_once dynamic_debug hid pinctrl regulator suspend_stats wakeup_sources acpi clk error_injection iosf_sb pm_genpd remoteproc swiotlb x86 bdi device_component extfrag kprobes pm_qos sched_debug sync zswap block devices_deferred fault_around_bytes mce pwm sched_features tracing cec dma_buf frontswap memcg_slabinfo ras sleep_time usb root@huangzihan:&#x2F;sys&#x2F;kernel&#x2F;debug# cd usb&#x2F; root@huangzihan:&#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;usb# ls -a . .. devices ehci ohci uhci xhci root@huangzihan:&#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;usb# cd ehci&#x2F; root@huangzihan:&#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;usb&#x2F;ehci# ls -a . .. root@huangzihan:&#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;usb&#x2F;ehci# 我们沿着这条路径一直cd进去，最后到了ehci，在这个目录下是没有文件的，sys的下一级目录是kernel，kernel的下一级目录是debug，debug的下一级目录是usb，usb下一级目录是ehci。 路径本身并没有提供任何有关文件究竟存放在哪个物理磁盘上的信息。 这个和Windows的相比较就知道了，Windows的路径最前面会有一个盘符，而Linux的路径就没有，而是一个/。 挂载点 Linux会在根驱动器上创建一些特别的目录，我们称之为挂载点（mount point）。挂载点是虚拟目录中用于分配额外存储设备的目录。虚拟目录会让文件和目录出现在这些挂载点目录中，然后而实际上它们却存储在另外一个驱动器中。 通常系统文件会存储在根目录中，而用户文件则存储在另一个驱动器，如下图： Linux文件结构 图文件结构展示了计算机中的两块硬盘。一块硬盘和虚拟目录的根目录（由正斜线/表示）关联起来。剩下的硬盘就可以挂载到虚拟目录结构中的任何地方。在这个例子中，第二块硬盘被挂载到了/home位置，用户目录都位于这个位置。 常见的Linux目录名称 目录 用途 / 虚拟目录的根目录。通常不会在这里存储文件 /bin 二进制目录，存放许多用户级的GNU工具 /boot 启动目录，存放启动文件 /dev 设备目录，Linux在这里创建设备节点 /etc 系统配置文件目录 /home 主目录，Linux在这里创建用户目录 /lib 库目录，存放系统和应用程序的库文件 /media 媒体目录，可移动媒体设备的常用挂载点 /mnt 挂载目录，另一个可移动媒体设备的常用挂载点 /opt 可选目录，常用于存放第三方软件包和数据文件 /proc 进程目录 /root root用户的主目录 /sbin 系统二进制目录，存放许多GNU管理员级工具 /run 运行目录，存放系统运行时的运行的数据 /srv 服务目录，存放本地服务的相关文件 /sys 系统目录，存放系统硬件信息的相关文件 /tmp 临时目录，可以在该目录中创建和删除临时工作文件 /usr 用户二进制目录，大量用户级的GNU工具和数据文件都存储在这里 /var 可变目录，用以存放经常变化的文件，比如日志文件 我使用了ls -a这条指令查看了我云服务器上的Ubuntu系统的根目录下有哪些目录，代码如下： root@huangzihan:&#x2F;# ls -a . bin dev home lib32 libx32 media opt root sbin swapfile tmp var .. boot etc lib lib64 lost+found mnt proc run srv sys usr 再对比一下，我这个版本Ubuntu系统和上面表格上，多出了: lib32 lib64 lost+found libx32 swapfile 文件系统层级标准（FHS） 常见的目录名均基于文件系统层级标准（filesystem hierarchy standard，FHS）。FHS官方主页：http://www.pathname.com/fhs 在登陆系统并获得一个shell CLI提示符后，会话将从主目录开始。主目录是分配给用户账户的一个特有目录。用户账户在创建之后，系统通常会为其分配一个特有的目录。 可以使用图形界面在虚拟目录中跳转。想要在CLI提示符下切换虚拟目录，需要使用cd命令。 遍历目录cd命令 在Linux文件系统上，可以使用切换目录命令cd将shell会话切换到另一个目录。 cd命令可接受单个参数destination，用以指定想切换到的目录名。如果没有为cd命令指定目标路径，它将切换到用户主目录。 destination参数可以用两种方式表示：一种是使用绝对文件路径，另一种是使用相对文件路径。 绝对文件路径 用户可在虚拟目录中采用绝对文件路径引用目录名。绝对文件路径定义了在虚拟目录结构中该目录的确切位置，以虚拟目录的根目录开始，相当于目录的全名。 绝对文件路径总是以正斜线（/）作为起始，指明虚拟文件系统的根目录。因此，如果要指向usr目录所包含的bin目录下的用户二进制文件，可以使用如下绝对文件路径： &#x2F;usr&#x2F;bin 使用绝对文件路径可以清晰表明用户想切换到的确切位置。要用绝对文件路径来切换文件系统中的某个特定位置，只需在cd命令后指定全路径名： 根据上面说的，如果我们知道我们要找的目录或者文件的路径，就可以直接cd到该路径下，所以下面两种方法等效的： root@huangzihan:&#x2F;# ls -a . bin dev home lib32 libx32 media opt root sbin swapfile tmp var .. boot etc lib lib64 lost+found mnt proc run srv sys usr root@huangzihan:&#x2F;# root@huangzihan:&#x2F;# cd usr root@huangzihan:&#x2F;usr# ls -a . .. bin games include lib lib32 lib64 libx32 local sbin share src root@huangzihan:&#x2F;usr# cd bin&#x2F; root@huangzihan:&#x2F;usr&#x2F;bin# ls -a . dpkg-shlibdeps m4 setleds .. dpkg-source mail setlogcons &#39;[&#39; dpkg-split mail.mailutils setmetamode ... ... ... root@huangzihan:&#x2F;# cd &#x2F;usr&#x2F;bin root@huangzihan:&#x2F;usr&#x2F;bin# ls -a . dpkg-shlibdeps m4 setleds .. dpkg-source mail setlogcons &#39;[&#39; dpkg-split mail.mailutils setmetamode ... ... ... 提示符中一开始有一个波浪号（~）。在切换到另一个目录之后，这个波浪号被/usr/bin替代了。CLI提示符正是用它来帮助你跟踪当前所在虚拟目录结构中的位置。波浪号表明shell会话位于你的主目录中。在切换出主目录之后，如果提示符已经进行了相关配置的话，绝对文件路径就会显示在提示符中。 在我这里提示符是#，当我打开控制台终端的那一刻，进入的是主目录，这时候#之前是波浪号~；当我切换cd到根目录的时候，#之前的是正斜线（/），再cd到绝对路径usr/bin/，提示符之前就是绝对路径usr/bin/。 Last login: Sun May 2 17:17:22 2021 from 113.116.156.243 root@huangzihan:~# ls -a . .. .bash_history .bashrc .cache .pip .profile .pydistutils.cfg .ssh .viminfo .Xauthority root@huangzihan:~# cd .. root@huangzihan:&#x2F;# cd usr&#x2F;bin&#x2F; root@huangzihan:&#x2F;usr&#x2F;bin# pwd命令和当前目录 如果没有配置好提示符来显示当前shell会话的绝对文件路径，也可以使用shell命令来显示所处的位置。pwd命令可以显示出shell会话的当前目录，这个目录被称为当前工作目录。 root@huangzihan:&#x2F;# ls -a . bin dev home lib32 libx32 media opt root sbin swapfile tmp var .. boot etc lib lib64 lost+found mnt proc run srv sys usr root@huangzihan:&#x2F;# pwd &#x2F; root@huangzihan:&#x2F;# ls -a . bin dev home lib32 libx32 media opt root sbin swapfile tmp var .. boot etc lib lib64 lost+found mnt proc run srv sys usr root@huangzihan:&#x2F;# cd run root@huangzihan:&#x2F;run# ls -a . atd.pid chronyd.pid crond.pid initctl log NetworkManager shm sudo udev uuidd .. blkid cloud-init crond.reboot initramfs motd.dynamic resolvconf sshd systemd user agetty.reload chrony console-setup dbus lock mount sendsigs.omit.d sshd.pid tmpfiles.d utmp root@huangzihan:&#x2F;run# pwd &#x2F;run root@huangzihan:&#x2F;run# cd log root@huangzihan:&#x2F;run&#x2F;log# pwd &#x2F;run&#x2F;log root@huangzihan:&#x2F;run&#x2F;log# 根据上面这段代码，我们不难发现，当我们使用pwd命令查看当前目录的时候，所显示出来的目录和提示符#之前的路径是一致的。 窍门：在切换到新的当前目录时使用pwd命令，是很好的习惯。因为很多shell命令都是在当前工作目录中操作的，在发出命令之前，你应该始终确保自己处在正确的目录中。 root@huangzihan:&#x2F;run&#x2F;log# cd root@huangzihan:~# cd &#x2F;run&#x2F;log root@huangzihan:&#x2F;run&#x2F;log# 这上面一段代码告诉我们，我们可以使用cd 绝对路径到我们想要的位置，也可以使用cd直接返回到主目录。","path":"2021/05/16/浏览文件系统/","date":"05-16","excerpt":"浏览文件系统 当登录系统并获得shell命令提示符后，你通常位于自己的主目录中。 我一登录进去是这样的，第一行是登录时间，第二行是一个类似IP地址的东西，但是是哪里的IP地址，暂时不知道，最后是第三行，我搜索一下我之前的笔记，root是用户ID，huangzihan是系统名，#是bash shell提示符，然后#提示符之前应该是目录名，代码如下： Last login: Sun May 2 12:10:32 2021 from 113.116.156.243 root@huangzihan:~# 文件系统Windows的文件系统 你将注意到的第一个不同点是，Linux在路径名中不使用驱动器盘符。在Windows中，PC上安装的物理驱动器决定了文件的路径名。Windows会为每个物理驱动词驱动盘分配一个盘符，每个驱动器都会有自己的目录结构，以便访问存储其中的文件。 当我们双击点开我的电脑或者此电脑，可以看到设备和驱动器下有一个个命名为C、D、E、F的磁盘（物理驱动器），而这些C、D、E、F就是磁盘的符号。 举个例子在，Windows中经常看到这样的文件路径： D:\\linux-0.01内核\\.git\\hooks\\update.sample 这种Windows文件路径表明了文件update.sample究竟位于哪个磁盘分区中，这里我们可以看出这个文件位于我们的D盘。 如果你将test.doc保存在闪存上，该闪存由J来标识那么文件的路径就是J:\\test.doc。该路径表明文件位于J盘的根目录下。","tags":[]},{"title":"bash手册","text":"bash手册man命令 man命令用来访问存储在Linux系统上的手册页面。在想要查找的工具的名称前面输入man命令，就可以找到那个工具相应的手册条目。 man man 窍门：bash手册甚至包含了一份有关其自身的参考信息。输入man man来查看与手册页相关的手册页。 根据上面的提示，我在控制台终端输入这行代码： root@huangzihan:&#x2F;# man man 然后它弹出这样一个页面： MAN(1) Manual pager utils MAN(1) NAME man - an interface to the system reference manuals SYNOPSIS man [man options] [[section] page ...] ... man -k [apropos options] regexp ... man -K [man options] [section] term ... man -f [whatis options] page ... man -l [man options] file ... man -w|-W [man options] page ... DESCRIPTION man is the system&#39;s manual pager. Each page argument given to man is normally the name of a program, utility or function. The manual page associated with each of these arguments is then found and displayed. A section, if provided, will direct man to look only in that section of the manual. The default action is to search in all of the available sections following a pre- defined order (see DEFAULTS), and to show only the first page found, even if page exists in several sections. ... ... ... 如果我们想退出这个页面，直接按q键就可以。然后我又查了我平时用的那条ls指令，整个过程代码如下： root@huangzihan:&#x2F;# man ls LS(1) User Commands LS(1) NAME ls - list directory contents SYNOPSIS ls [OPTION]... [FILE]... DESCRIPTION List information about the FILEs (the current directory by default). Sort entries alphabetically if none of -cftuvSUX nor --sort is specified. Mandatory arguments to long options are mandatory for short options too. -a, --all do not ignore entries starting with . ... ... ... 窍门：如果你是新接触bash shell，可能一开始会觉得手册页面并不太用。但是如果养成了阅读手册的习惯，尤其是阅读第一段或是DESCRIPTION部分的前两段，最终你会学到各种技术行话，手册页也会变得越来越有用。 分页程序（page） 当使用man命令查看命令手册的时候，这些手册页是由分页程序（page）来显示的。分页程序是一种实用工具，能够逐页显示文本。可以通过点击空格键进行翻页，或是使用回车键逐行查看。另外还可以使用箭头键向前向后滚动手册页的内容（假设你用的终端仿真软件包支持箭头键功能）。 在分页程序最下面的一行有这样一条语句： Manual page ls(1) line 1&#x2F;218 15% (press h for help or q to quit) 当我们使用回车键和箭头键向前向后的时候，这句话在中的1/218的1不断地增加。 读完了手册页，可以点击q键退出。退出手册页之后，你会重新获得shell CLI提示符，这表示shell正在等待接受下一条命令。 手册页将与命令相关的信息分成了不同的节。每一节惯用的命名标准如表Linux手册页惯用的节名 Linux手册页惯用的节名 节 描述 Name 显示命令名和一段简短的描述 Synopsis 命令的语法 Confi guration 命令配置信息 Description 命令的一般性描述 Options 命令选项描述 Exit Status 命令的退出状态指示 Return Value 命令的返回值 Errors 命令的错误消息 Environment 描述所使用的环境变量 Files 命令用到的文件 Versions 命令的版本信息 Conforming To 命令所遵从的标准 Notes 其他所遵从的标准 Bugs 提供提交bug的途径 Example 展示命令的用法 Authors 命令开发人员的信息 Copyright 命令源代码的版权状况 See Also 与该命令类型的其他命令 窍门：如果不记得命令名怎么办？可以使用关键字搜索手册页。语法是：man -k 关键字。例如，要查找与终端相关的命令，可以输入man -k terminal。 除了对节按照惯例进行命名，手册页还有对应的内容区域。每个内容区域都分配了一个数字，从1开始，一直到9，如下表Linux手册页的内容区域 Linux手册页的内容区域 区域号 所涵盖的内容 1 可执行程序或shell命令 2 系统调用 3 库调用 4 特殊文件 5 文件格式与约定 6 游戏 7 概览、约定及杂项 8 超级用户和系统管理员命令 9 内核例程 查看命令在Linux手册页中的区域 man工具通常提供的是命令所对应的最低编号的内容。 当我在命令行输入man ls，在弹出来的分页程序中的第一行和最后一行，发现这两条语句中的LS和ls后面的括号有一个数字：（1）。这表示所显示的手册页来自内容区域1（可执行程序或shell命令） LS(1) User Commands LS(1) Manual page ls(1) line 1&#x2F;218 15% (press h for help or q to quit) 一个命令偶尔会在多个内容区域都有对应的手册页。比如说，有个叫作hostname的命令。手册页中既包括该命令的相关信息，也包括对系统主机名的概述。想要查看所需要的页面，可以输入man section# topic。对手册页的第一部分而言，就是输入man 1 hostname。对于手册页中的第7部分，就是输入man 7 hostname。 我根据上面的提示分别打开了hostname的第1部分和第7部分，部分代码如下： root@huangzihan:&#x2F;# man 1 hostname HOSTNAME(1) Linux Programmer&#39;s Manual HOSTNAME(1) NAME hostname - show or set the system&#39;s host name domainname - show or set the system&#39;s NIS&#x2F;YP domain name ypdomainname - show or set the system&#39;s NIS&#x2F;YP domain name nisdomainname - show or set the system&#39;s NIS&#x2F;YP domain name dnsdomainname - show the system&#39;s DNS domain name ... ... ... root@huangzihan:&#x2F;# man 7 hostname HOSTNAME(7) Linux Programmer&#39;s Manual HOSTNAME(7) NAME hostname - hostname resolution description ... ... ... 你也可以只看各部分内容的简介：输入man 1 intro阅读第1部分，输入man 2 intro阅读第2部分，输入man 3 intro阅读第3部分，等等。 根据上面的提示，我在提示符#后面分别输入man 1 intro和man 7 intro，控制台终端的输出如下： root@huangzihan:&#x2F;# man 1 intro INTRO(1) Linux User&#39;s Manual INTRO(1) NAME intro - introduction to user commands ... ... ... root@huangzihan:&#x2F;# man 7 intro INTRO(7) Linux Programmer&#39;s Manual INTRO(7) NAME intro - introduction to overview and miscellany section ... ... ... 当我想查看ls的第2部分、第3部分、第4部分，在shell提示符#后面分别输入man 2 ls、man 3 ls、man 4 ls，但是因为ls这条命令没有这三部分，所以控制台终端输出是这样的： root@huangzihan:&#x2F;# man 2 ls No manual entry for ls in section 2 root@huangzihan:&#x2F;# man 3 ls No manual entry for ls in section 3 root@huangzihan:&#x2F;# man 4 ls No manual entry for ls in section 4 info页面 手册页不是唯一的参考资料。还有另一种叫作info页面的信息。可以输入info info来了解info页面的相关内容。 根据上面的提示，我在提示符#后面输入info info，控制台终端的输出如下： Next: Stand-alone Info, Up: (dir) Stand-alone GNU Info ******************** This documentation describes the stand-alone Info reader which you can use to read Info documentation. ... ... ... 如果想查看ls的info页面，我们可以把上面那条命令改为info ls，对应的控制台的输出为： root@huangzihan:&#x2F;# info ls Next: dir invocation, Up: Directory listing 10.1 ‘ls’: List directory contents &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; The ‘ls’ program lists information about files (of any type, including directories). Options and file arguments can be intermixed arbitrarily, as usual. ... ... ... help帮助 另外，大多数命令都可以接受-help或--help选项。例如你可以输入hostname -help来查看帮助。关于帮助的更多信息，可以输入help help。（看出这里面的门道没？） 根据上面的提示，我在shell提示符#后面输入help help，对应的控制台终端输出是这样的： root@huangzihan:&#x2F;# help help help: help [-dms] [pattern ...] Display information about builtin commands. Displays brief summaries of builtin commands. If PATTERN is specified, gives detailed help on all commands matching PATTERN, otherwise the list of help topics is printed. ... ... ... 如果想查看ls命名，可以在shell提示符#后面输入ls --help，这个查看ls的命令只有这个是对的，中途我还输错了几次，整个过程代码是这样的： root@huangzihan:&#x2F;# ls -help ls: invalid option -- &#39;e&#39; Try &#39;ls --help&#39; for more information. root@huangzihan:&#x2F;# ls --help Usage: ls [OPTION]... [FILE]... List information about the FILEs (the current directory by default). Sort entries alphabetically if none of -cftuvSUX nor --sort is specified. ... ... ...","path":"2021/05/16/bash手册/","date":"05-16","excerpt":"bash手册man命令 man命令用来访问存储在Linux系统上的手册页面。在想要查找的工具的名称前面输入man命令，就可以找到那个工具相应的手册条目。 man man 窍门：bash手册甚至包含了一份有关其自身的参考信息。输入man man来查看与手册页相关的手册页。 根据上面的提示，我在控制台终端输入这行代码： root@huangzihan:&#x2F;# man man 然后它弹出这样一个页面： MAN(1) Manual pager utils MAN(1) NAME man - an interface to the system reference manuals SYNOPSIS man [man options] [[section] page ...] ... man -k [apropos options] regexp ... man -K [man options] [section] term ... man -f [whatis options] page ... man -l [man options] file ... man -w|-W [man options] page ... DESCRIPTION man is the system&#39;s manual pager. Each page argument given to man is normally the name of a program, utility or function. The manual page associated with each of these arguments is then found and displayed. A section, if provided, will direct man to look only in that section of the manual. The default action is to search in all of the available sections following a pre- defined order (see DEFAULTS), and to show only the first page found, even if page exists in several sections. ... ... ... 如果我们想退出这个页面，直接按q键就可以。然后我又查了我平时用的那条ls指令，整个过程代码如下： root@huangzihan:&#x2F;# man ls LS(1) User Commands LS(1) NAME ls - list directory contents SYNOPSIS ls [OPTION]... [FILE]... DESCRIPTION List information about the FILEs (the current directory by default). Sort entries alphabetically if none of -cftuvSUX nor --sort is specified. Mandatory arguments to long options are mandatory for short options too. -a, --all do not ignore entries starting with . ... ... ... 窍门：如果你是新接触bash shell，可能一开始会觉得手册页面并不太用。但是如果养成了阅读手册的习惯，尤其是阅读第一段或是DESCRIPTION部分的前两段，最终你会学到各种技术行话，手册页也会变得越来越有用。","tags":[]},{"title":"基本的BashShell命令","text":"基本的bash shell命令启动shell GNU bash shell 能提供对Linux系统的交互式访问。它是作为普通程序运行的，通常是在用户登录终端时启动。登录时系统启动的shell依赖于用户账户的配置。 etc/passwd文件包含了所有系统用户账户列表以及每个用户的基本配置信息。 根据这个提示，我cd进去etc文件夹，用vi打开这个passwd文件，整个过程如下面代码所示： root@huangzihan:~# cd .. root@huangzihan:&#x2F;# ls -a . bin dev home lib32 libx32 media opt root sbin swapfile tmp var .. boot etc lib lib64 lost+found mnt proc run srv sys usr root@huangzihan:&#x2F;# cd etc root@huangzihan:&#x2F;etc# ls -a . default iproute2 mke2fs.conf protocols ssl .. deluser.conf issue modprobe.d .pwd.lock subgid adduser.conf depmod.d issue.net modules python2.7 subuid ... ... ... root@huangzihan:&#x2F;etc# vi passwd root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash daemon:x:1:1:daemon:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;sbin&#x2F;nologin bin:x:2:2:bin:&#x2F;bin:&#x2F;usr&#x2F;sbin&#x2F;nologin ... ... ... 每个条目有七个字段，字段之间用冒号分隔。系统使用字段中的数据来赋予用户账号某些特定特性。其中的大多数条目将在第7章有更加详细的介绍。现在先将注意力放在最后一个字段上，该字段指定了用户使用的shell程序。 在前面的/etc/passwd样例条目中，其中root:x:0:0:root:/root:/bin/bash表示的是，用户root使用/bin/bash作为自己的默认shell程序。这意味着当用户登录Linux系统后，bash shell会自动启动。 尽管bash shell会在登录时自动启动，但是，是否会出现shell命令行界面（CLI）则依赖于所使用的登录方式。如果采用虚拟控制台终端登录，CLI提示符会自动出现，你可以输入shell命令。但如果是通过图形化桌面环境登录Linux系统，你就需要启动一个图形化终端仿真器来访问shell CLI提示符。 shell提示符 默认bash shell提示符是美元符号（$），这个符号表明shell在等待用户输入。 我这里用的是Ubuntu系统，这里是显示的bash shell提示符的是#： Last login: Fri Apr 30 23:49:46 2021 from 113.87.91.187 root@huangzihan:~# cd .. root@huangzihan:&#x2F;# ls -a . bin dev home lib32 libx32 media opt root sbin swapfile tmp var .. boot etc lib lib64 lost+found mnt proc run srv sys usr root@huangzihan:&#x2F;# 窍门：在输入shell命令之后，需要按回车键才能让shell执行你输入的命令。 除了作为shell的入口，提示符还能够提供其他的辅助信息。在上面那段代码中，提示符所在的一行显示了当前用户ID名root，还包括系统名huangzihan。","path":"2021/05/16/基本的BashShell命令/","date":"05-16","excerpt":"","tags":[]},{"title":"shell","text":"shell命令行文本命令行界面(command line interface,CLI) 在图形化桌面之前，与Unix系统进行交互的唯一方式就是借助由shell所提供的文本命令行界面(command line interface,CLI)。 由于这些限制，输出设备并不需要多华丽。通常只需要一个简单的哑终端就可以使用Unix系统。所谓的哑终端无非就是利用通信电缆（一般是一条多线束的串行电缆）连接到Unix系统上的一台显示器和一个键盘。这种简单的组合可以轻松地向Unix系统中输入文本数据，并查看文本输出结果。 控制台终端 进入CLI的一种方法是让Linux系统退出图形化桌面模式，进入文本模式。这样在显示器上就只有一个简单的shell CLI，跟图形化桌面出现以前一样。这种模式称作Linux控制台，因为它仿真了早期的硬接线控制台终端，而且是一种同Linux系统交互的直接接口。 Linux系统启动后，它会自动创建出一些虚拟控制台。虚拟控制台是运行在Linux系统内存中的终端会话。无需在计算机上连接多个哑终端，大多数Linux发行版会启动5~6个（有时会更多）虚拟控制台，你在一台计算机的显示器和键盘上就可以访问它们。","path":"2021/05/16/shell/","date":"05-16","excerpt":"","tags":[]},{"title":"初识LinuxShell","text":"初识Linux shellLinux系统 Linux可划分为以下四部分： Linux内核 GNU工具 图形化桌面环境 应用软件 每一部分在Linux系统中各司其职。但就单个部分而言，其作用并不大，如下图，是一个基本结构框架，展示了各部分是如何协作起来构成整个Linux系统的。 Linux系统 Linux内核 Linux系统的核心是内核。内核控制着计算机系统上的所有硬件和软件，在必要时分配硬件，并根据需要执行软件。 内核主要负责以下四种功能： 系统内存管理 软件程序管理 硬件设备管理 文件系统管理 系统内存管理 操作系统内核的主要功能之一就是内存管理。内核不仅管理服务器上的物理内存，还可以创建和管理虚拟内存（即实际并不存在的内存） 交换空间 内核通过硬盘上的存储空间来实现虚拟内存，这块区域称为交换空间（swap space）。内核不断地在交换空间和实际的物理内存之间反复交换虚拟内存中的内容。这使得系统以为它拥有比物理内存更多的可用内存，如图所示： Linux系统内存映射 页面 内存存储单元按组划分成很多块，这些块称作页面（page）。内核将每个内存页面放在物理内存或交换空间。然后，内核会维护一个内存页面表，指明哪些页面位于物理内存内，哪些页面被换到了磁盘上。 换出 内核会记录哪些内存页面正在使用中，并自动把一段时间未访问的内存页面复制到交换空间区域（称为换出，swapping out）——即使还有可用内存。当程序要访问一个已被换出的内存页面时，内核必须从物理内存换出另外一个内存页面给它让出空间，然后从交换空间换入请求的内存页面。显然，这个过程要花费时间，拖慢运行中的进程。只要Linux系统在运行，为运行中程序换出内存页面的过程就不会停歇。 软件程序管理Linux中的进程 Linux操作系统将运行中的程序称为进程。进程可以在前台运行，将输出显示在屏幕上，也可以在后台运行，隐藏到幕后。内核控制着Linux系统如何管理运行在系统上的所有进程。 内核创建了第一个进程（称为init进程）来启动系统上所有其他进程。当内核启动时，它会将init进程加载到虚拟内存中。内核在启动任何其他进程时，都会在虚拟内存中给新进程分配一块专有区域来存储该进程用到的数据和代码。 一些Linux发行版使用一个表来管理在系统开机时要自动启动进程。在Linux系统上，这个表通常位于专门文件/etc/inittab中。 然后我就cd到/etc目录下，果真发现这个目录，然后我再cd进去这个目录，就发现这些文件： root@huangzihan:&#x2F;# cd .. root@huangzihan:&#x2F;# ls -a . bin dev home lib32 libx32 media opt root sbin swapfile tmp var .. boot etc lib lib64 lost+found mnt proc run srv sys usr root@huangzihan:&#x2F;# cd etc root@huangzihan:&#x2F;etc# ls -a . default iproute2 mke2fs.conf protocols ssl .. deluser.conf issue modprobe.d .pwd.lock subgid adduser.conf depmod.d issue.net modules python2.7 subuid adjtime dhcp kernel modules-load.d python3 sudoers alternatives dpkg kernel-img.conf motd python3.8 sudoers.d ... ... ... 另外一些系统（比如现在流行的Ubuntu Linux发行版）则采用/etc/init.d目录，将开机时启动或停止某个应用的脚本放在这个目录下。这些脚本通过/etc/rcX.d目录下的入口（entry）启动，这里的X代表运行级（run level）。 root@huangzihan:&#x2F;etc# cd init.d root@huangzihan:&#x2F;etc&#x2F;init.d# ls -a . apparmor console-setup.sh fio irqbalance ntp procps rsyslog udev .. atd cron grub-common keyboard-setup.sh plymouth resolvconf ssh ufw aegis chrony dbus hwclock.sh kmod plymouth-log rsync sysstat uuidd Linux系统的运行级 Linux操作系统的init系统采用了运行级。运行级决定了init进程运行/etc/init.d文件或/etc/rcX.d目录中定义好的某些特定类型的进程。Linux操作系统有5个启动运行级。 同样，我也发现了这个/etc/rcX.d，而且还不止一个，分别是rc0.d、rc1.d、rc2.d、rc3.d、rc4.d、rc5.d、rc6.d、rcS.d根据上面的意思，这里的X代表运行级（run level），那么这里的运行级分别是0、1、2、3、4、5、6、S，而且我还cd进去看看这里面都有什么文件，过程代码如下： root@huangzihan:&#x2F;etc# cd rc0.d root@huangzihan:&#x2F;etc&#x2F;rc0.d# ls -a . .. K01atd K01chrony K01irqbalance K01plymouth K01resolvconf K01rsyslog K01udev K01uuidd root@huangzihan:&#x2F;etc&#x2F;rc0.d# cd .. root@huangzihan:&#x2F;etc# cd rc1.d root@huangzihan:&#x2F;etc&#x2F;rc1.d# ls -a . .. K01atd K01chrony K01irqbalance K01rsyslog K01ufw K01uuidd root@huangzihan:&#x2F;etc&#x2F;rc1.d# cd .. root@huangzihan:&#x2F;etc# cd rc2.d root@huangzihan:&#x2F;etc&#x2F;rc2.d# ls -a . K01irqbalance S01atd S01console-setup.sh S01dbus S01plymouth S01rsyslog S01sysstat S80aegis .. K01ntp S01chrony S01cron S01grub-common S01rsync S01ssh S01uuidd root@huangzihan:&#x2F;etc&#x2F;rc2.d# cd .. root@huangzihan:&#x2F;etc# cd rc3.d root@huangzihan:&#x2F;etc&#x2F;rc3.d# ls -a . K01irqbalance S01atd S01console-setup.sh S01dbus S01plymouth S01rsyslog S01sysstat S80aegis .. K01ntp S01chrony S01cron S01grub-common S01rsync S01ssh S01uuidd root@huangzihan:&#x2F;etc&#x2F;rc3.d# cd .. root@huangzihan:&#x2F;etc# cd rc4.d root@huangzihan:&#x2F;etc&#x2F;rc4.d# ls -a . K01irqbalance S01atd S01console-setup.sh S01dbus S01plymouth S01rsyslog S01sysstat S80aegis .. K01ntp S01chrony S01cron S01grub-common S01rsync S01ssh S01uuidd root@huangzihan:&#x2F;etc&#x2F;rc4.d# cd .. root@huangzihan:&#x2F;etc# cd rc5.d root@huangzihan:&#x2F;etc&#x2F;rc5.d# ls -a . K01irqbalance S01atd S01console-setup.sh S01dbus S01plymouth S01rsyslog S01sysstat S80aegis .. K01ntp S01chrony S01cron S01grub-common S01rsync S01ssh S01uuidd root@huangzihan:&#x2F;etc&#x2F;rc5.d# cd .. root@huangzihan:&#x2F;etc# cd rc6.d root@huangzihan:&#x2F;etc&#x2F;rc6.d# ls -a . .. K01atd K01chrony K01irqbalance K01plymouth K01resolvconf K01rsyslog K01udev K01uuidd root@huangzihan:&#x2F;etc&#x2F;rc6.d# cd .. root@huangzihan:&#x2F;etc# cd rcS.d root@huangzihan:&#x2F;etc&#x2F;rcS.d# ls -a . .. S01apparmor S01keyboard-setup.sh S01kmod S01plymouth-log S01procps S01resolvconf S01udev S01ufw 运行级为1时，只启动基本的系统进程以及一个控制台终端进程。显然，在这种模式下，仅有一个人（通常是系统管理员）能登录到系统上操作数据。 标准的启动运行级是3。在这个运行级上，大多数应用软件，比如网络支持程序，都会启动。另一个Linux中常见的运行级是5。在这个运行级上系统会启动图形化的X Windows系统，允许用户通过图形化桌面窗口登录系统。 硬件设备管理 内核的另一职责是管理硬件设备。任何Linux系统需要与之通信的设备，都需要在内核代码中加入其驱动程序代码。驱动程序代码相当于应用程序和硬件设备的中间人，允许内核与设备之间交换数据。 插入设备驱动代码的方法： 在Linux内核中有两种方法用于插入设备驱动代码： 编译进内核的设备驱动代码 可插入内核的设备驱动模块 设备文件 Linux系统将硬件设备当成特殊的文件，称为设备文件。设备文件有3种分类： 字符型设备文件：指处理数据时每次只能处理一个字符的设备。大多数类型的调制解调器和终端都是作为字符型设备文件创建的。 块设备文件：指处理数据时每次能处理大块数据的设备，比如硬盘。 网络设备文件：指采用数据包发送和接收数据的设备，包括各种网卡和一个特殊的回环设备。这个回环设备允许Linux系统使用常见的网络编程协议同自身通信。 Linux为系统上的每个设备都创建一种称为节点的特殊文件。与设备的所有通信都通过设备节点完成。每个节点都有唯一的数值对供Linux内核标识它。数值对包括一个主设备号和一个次设备号。类似的设备被划分到同样的主设备号下。次设备号用于标识主设备组下的某个特定设备。 文件系统管理 不同于其他一些操作系统，Linux内核支持通过不同类型的文件系统从硬盘中读写数据。除了自有的诸多文件系统外，Linux还支持从其他操作系统（比如Microsoft Windows）采用的文件系统中读写数据。 Linux系统用来读写数据的标准文件系统 文件系统 描述 ext Linux扩展文件系统，最早的Linux文件系统 ext2 第二扩展文件系统，在ext的基础上提供了更多的功能 ext3 第三扩展文件系统，支持日志功能 ext4 第四扩展文件系统，支持高级日志功能 hpfs OS/2高性能文件系统 jfs IBM日志文件系统 iso9660 ISO 9660文件系统（CD-ROM） minix MINIX文件系统 msdos 微软的FAT16 ncp Netware文件系统 nfs 网络文件 ntfs 支持Microsoft NT文件系统 proc 访问系统文件 ReiserFS 高级Linux文件系统，能提供更好的性能和硬盘恢复功能 smb 支持网络访问的Samba SMB文件系统 sysv 较早期的Unix文件系统 ufs BSD文件系统 umsdos 建立在msdos上的类Unix文件系统 vfat Windows 95 XFS 高性能64位日志文件系统 Linux服务器所访问的所有硬盘都必须格式化成Linux系统用来读写数据的标准文件系统这份表格所列文件系统类型中的一种。 Linux内核采用虚拟文件系统（Virtual File System，VFS）作为和每个文件系统交互的接口。这为Linux内核同任何类型文件系统通信提供了一个标准接口。当每个文件系统都被挂载和使用时，VFS将信息都缓存在内存中。 GNU工具核心GNU工具GNU coreutils软件包由三部分构成： 用以处理文件的工具 用以操作文本的工具 用以管理进程的工具 shell GNU/Linux shell是一种特殊的交互式工具。它为用户提供了启动程序、管理文件系统中文件以及运行在Linux系统上的进程的途径。shell的核心是命令行提示符。命令行提示符是shell负责交互的部分。它允许你输入文本命令，然后解释命令，并在内核中执行。 shell包含了一组内部命令，用这些命令可以完成诸如复制文件、移动文件、重命名文件、显示和终止系统中正运行的程序等操作。shell也允许你在命令行提示符中输入程序的名称，它会将程序名传递给内核以启动它。 你也可以将多个shell命令放入文件中作为程序执行。这些文件被称作shell脚本。你在命令行上执行的任何命令都可放进一个shell脚本中作为一组命令执行。这为创建那种需要把几个命令放在一起来工作的工具提供便利。","path":"2021/05/16/初识LinuxShell/","date":"05-16","excerpt":"初识Linux shellLinux系统 Linux可划分为以下四部分： Linux内核 GNU工具 图形化桌面环境 应用软件 每一部分在Linux系统中各司其职。但就单个部分而言，其作用并不大，如下图，是一个基本结构框架，展示了各部分是如何协作起来构成整个Linux系统的。 Linux系统 Linux内核 Linux系统的核心是内核。内核控制着计算机系统上的所有硬件和软件，在必要时分配硬件，并根据需要执行软件。 内核主要负责以下四种功能： 系统内存管理 软件程序管理 硬件设备管理 文件系统管理 系统内存管理 操作系统内核的主要功能之一就是内存管理。内核不仅管理服务器上的物理内存，还可以创建和管理虚拟内存（即实际并不存在的内存）","tags":[]},{"title":"ls命令剖析","text":"ls资料翻译 ls - list contents of directory ls - 列出目录的内容 SYNOPSIS 使用方式ls [ -ltasdruifg ] name ... DESCRIPTION 说明参数的说明 For each directory argument, ls lists the contents of the directory; for each file argument, ls repeats its name andany other information requested. The output is sorted alphabetically by default. When no argument is given, the current directory is listed. When several arguments are given, the arguments are first sorted appropriately, but file arguments appear before directories and their contents.There are several options: 对于每个目录参数，ls列出目录内容；对于每个文件参数，ls重复其名称和要求的任何其他信息。输出已排序默认按字母顺序排列。当没有给出任何论据时，当前目录已列出。当几个参数给定，参数首先被适当地排序，但是文件参数出现在目录及其内容之前。有几种选择： -l list in long format, giving mode, number of links,owner, size in bytes, and time of last modification for each file. (See below.) If the file is a special filethe size field will instead contain the major and minor device numbers. -l 长格式列表，给出模式，链接数，所有者、字节大小和每个文件上次修改的时间(如果文件是特殊文件“大小”字段将改为包含“主要”和“次要”字段设备编号。 -t sort by time modified (latest first) instead of by name,as is normal. -t 按修改的时间（最新的第一个）排序，而不是按名称排序，一切正常 -a list all entries; usually those beginning with `.’ are suppressed -a 列出所有条目；通常以“.”开头的被发表 -s give size in blocks for each entry -s 为每个条目提供块大小 -d if argument is a directory, list only its name, not its contents (mostly used with -l to get status on directory) -d 如果参数是目录，则只列出它的名称，而不列出它的内容（主要与-l一起使用以获取目录的状态） -r reverse the order of sort to get reverse alphabetic or oldest first as appropriate -r 颠倒排序顺序，以获得颠倒的字母顺序或最早的优先顺序（视情况而定） -u use time of last access instead of last modification for sorting (-t) or printing (-l) -u 使用上次访问的时间而不是上次修改排序（-t）或打印（-l） -i print i-number in first column of the report for each file listed -i 在报告的第一列中为列出的每个文件打印i号 -f force each argument to be interpreted as a directory and list the name found in each slot. This option turns off -l, -t, -s, and -r, and turns on -a; the order is the order in which entries appear in the directory. -f 强制将每个参数解释为目录和列出每个插槽中找到的名称。此选项将关闭-l、 -t、-s和-r，并打开-a；顺序是条目在目录中出现的顺序。 -g Give group ID instead of owner ID in long listing. -g 在长列表中提供组ID而不是所有者ID。 -l 参数字符的解释 The mode printed under the -l option contains 11 characters which are interpreted as follows: the first character is 在-l选项下打印的模式包含11个字符，解释如下：第一个字符是: d if the entry is a directory; b if the entry is a block-type special file; c if the entry is a character-type special file; (-) if the entry is a plain file. d 如果条目是目录； b 如果条目是块类型特殊文件； c 如果条目是字符类型的特殊文件； (-) 如果条目是普通文件。 文件权限的解释 The next 9 characters are interpreted as three sets of three bits each. The first set refers to owner permissions; the next to permissions to others in the same user-group; and the last to all others. Within each set the three characters indicate permission respectively to read, to write, or to execute the file as a program. For a directory, `execute’ permission is interpreted to mean permission to search the directory for a specified file. The permissions are indicated as follows: 接下来的9个字符被解释为三组三个字符每一位。第一组是所有者权限；同一用户组中其他用户的权限旁边的；最后一个给所有其他人。在每个集合中，三个字符分别表示读取、写入或作为程序执行文件的权限。对于目录，“execute”权限被解释为在目录中搜索指定文件的权限。权限如下所示： r if the file is readable w if the file is writable x if the file is executable (-) if if the indicated permission is not granted r if 如果文件可读 w 如果文件是可写的 x 如果文件是可执行的 (-) 如果未授予指定的权限 The group-execute permission character is given as s if the file has set-group-ID mode; likewise the user-execute permission character is given as s if the file has set-user-ID mode. 如果文件已设置组ID模式；同样地，如果文件设置了用户ID，则用户执行权限字符被赋予s模式。 The last character of the mode is normally blank but is printed as ``t’’ if the 1000 bit of the mode is on. Seechmod (I) for the current meaning of this mode. 模式的最后一个字符通常为空，但为空如果模式的1000位为on，则打印为“t”。看到了吗chmod（I）表示该模式的当前含义。 FILES 文件夹 /etc/passwd 获取ls-l的用户ID 实战演练ls 命令# ls bin dev etc hpunix lib mnt rkunix rpunix tmp unix usr ls -l 命令# ls -l total 247 drwxrwxr-x 2 bin 1104 May 14 00:47 bin drwxrwxr-x 2 bin 1824 Oct 10 12:35 dev drwxrwxr-x 2 bin 496 Oct 10 12:53 etc -rwxrwxrwx 1 root 29074 Oct 10 12:28 hpunix drwxrwxr-x 2 bin 464 May 13 23:35 lib drwxrwxr-x 2 bin 32 May 13 20:01 mnt -rwxrwxrwx 1 root 28836 Oct 10 12:22 rkunix -rwxrwxrwx 1 root 29020 Oct 10 12:25 rpunix drwxrwxrwx 2 bin 272 Oct 10 13:43 tmp -rwxrwxrwx 1 root 30346 Oct 10 12:32 unix drwxrwxr-x 15 bin 240 Oct 10 12:36 usr ls -t 命令# ls -t total 247 tmp etc usr dev unix hpunix rpunix rkunix bin lib mnt ls -a 命令# ls -a . .. bin dev etc hpunix lib mnt rkunix rpunix tmp unix usr ls -s 命令# ls -s total 247 3 bin 4 dev 1 etc 58 hpunix 1 lib 1 mnt 58 rkunix 58 rpunix 1 tmp 61 unix 1 usr ls -d 命令# ls -d . ls -r 命令# ls -r usr unix tmp rpunix rkunix mnt lib hpunix etc dev bin ls -u 命令# ls -u bin dev etc hpunix lib mnt rkunix rpunix tmp unix usr ls -i 命令# ls -i 101 bin 100 dev 99 etc 397 hpunix 98 lib 97 mnt 198 rkunix 396 rpunix 96 tmp 363 unix 95 usr ls -g 命令# ls -g bin dev etc hpunix lib mnt rkunix rpunix tmp unix usr","path":"2021/04/25/ls命令剖析/","date":"04-25","excerpt":"ls资料翻译 ls - list contents of directory ls - 列出目录的内容 SYNOPSIS 使用方式ls [ -ltasdruifg ] name ... DESCRIPTION 说明参数的说明 For each directory argument, ls lists the contents of the directory; for each file argument, ls repeats its name andany other information requested. The output is sorted alphabetically by default. When no argument is given, the current directory is listed. When several arguments are given, the arguments are first sorted appropriately, but file arguments appear before directories and their contents.There are several options: 对于每个目录参数，ls列出目录内容；对于每个文件参数，ls重复其名称和要求的任何其他信息。输出已排序默认按字母顺序排列。当没有给出任何论据时，当前目录已列出。当几个参数给定，参数首先被适当地排序，但是文件参数出现在目录及其内容之前。有几种选择： -l list in long format, giving mode, number of links,owner, size in bytes, and time of last modification for each file. (See below.) If the file is a special filethe size field will instead contain the major and minor device numbers. -l 长格式列表，给出模式，链接数，所有者、字节大小和每个文件上次修改的时间(如果文件是特殊文件“大小”字段将改为包含“主要”和“次要”字段设备编号。 -t sort by time modified (latest first) instead of by name,as is normal. -t 按修改的时间（最新的第一个）排序，而不是按名称排序，一切正常 -a list all entries; usually those beginning with `.’ are suppressed -a 列出所有条目；通常以“.”开头的被发表 -s give size in blocks for each entry -s 为每个条目提供块大小 -d if argument is a directory, list only its name, not its contents (mostly used with -l to get status on directory) -d 如果参数是目录，则只列出它的名称，而不列出它的内容（主要与-l一起使用以获取目录的状态） -r reverse the order of sort to get reverse alphabetic or oldest first as appropriate -r 颠倒排序顺序，以获得颠倒的字母顺序或最早的优先顺序（视情况而定） -u use time of last access instead of last modification for sorting (-t) or printing (-l) -u 使用上次访问的时间而不是上次修改排序（-t）或打印（-l） -i print i-number in first column of the report for each file listed -i 在报告的第一列中为列出的每个文件打印i号 -f force each argument to be interpreted as a directory and list the name found in each slot. This option turns off -l, -t, -s, and -r, and turns on -a; the order is the order in which entries appear in the directory. -f 强制将每个参数解释为目录和列出每个插槽中找到的名称。此选项将关闭-l、 -t、-s和-r，并打开-a；顺序是条目在目录中出现的顺序。 -g Give group ID instead of owner ID in long listing. -g 在长列表中提供组ID而不是所有者ID。","tags":[]},{"title":"Linux内核学习","text":"Linux内核学习前言为什么要看从Unix看起呢？因为Linux之父是参考Unix写出Linux的，所以追根溯源我就找到这里，打算从Unix源码看起，加上自己学习操作系统的学得很烂，不知道是自己的学习问题？还是操作系统理论知识本身就很抽象？于是，我就找到了《Unix内核源码剖析》这本书，从看源码然后再回头翻操作系统理论的书，沿着Unix-&gt;Linux-&gt;Android这条路走下去，逐步地对操作系统有进一步地理解。 Unix源码阅读前期环境搭建资料下载在网上找到书上学习Unix内核的材料，网盘地址如下： 链接：https:&#x2F;&#x2F;pan.baidu.com&#x2F;s&#x2F;1upOLt8h0U93spDuSEz4C4g 提取码：34cb Simh 中配置安装 Unix V6下载解压Unix V6上面的网盘地址如果失效，请联系本人更新地址，然后下载Unix V6解压里面的三个压缩文件到本地，应该看到这样的三个文件夹： simhv39-0-exe Unix-v6-Ken-Wellsch.tap v6src 重命名Unix-v6-Ken-Wellsch.tap将Unix-v6-Ken-Wellsch.tap这个文件夹中的Unix-v6-Ken-Wellsch.tap这个文件首先重命名为dist.tap，再复制黏贴到simhv39-0-exe这个文件夹里。这里为什么要重命名呢？因为在后面加载boot这段代码中有这样一行代码sim&gt; attach tm0 dist.tap，这里的dist.tap在我们下载到的三个文件夹中都没有，所以由此可以推断它是重命名来的，但是它有什么作用呢？暂时留下一个疑问。 查看simhv39-0-exe文件目录下的文件为什么这里会有一步查看这个文件夹下的所有文件呢？因为我发现配置参数之后，会在这个文件夹目录下新生成一些文件，所以在这里先把原有的所有文件做一个记录，到时候方便分析生成的过程发生了什么。 cmd方式查看考虑到有些同学没有在电脑里安装Git，就使用Windows最原始的方法去查看，快捷键win+R，在这里win一般表示的是在键盘左下方的微软图标，然后弹出来的运行窗口输入cmd，一般一开始的路径是： C:\\Users\\Administrator&gt; 然后我们需要切换到simhv39-0-exe这个文件夹的磁盘下，所以我们要光标处输入磁盘符，我这个文件夹在e盘，我的输入是这样的： C:\\Users\\Administrator&gt;e: 然后显示代码是这样的： C:\\Users\\Administrator&gt;e: E:\\&gt; 这个就表示我们已经进入到e盘的路径下，接着切换到该文件夹路径下，Tab键对文件夹的名字进行补全，由于我是在百度网盘下载的，所以我这里e盘的根目录下是BaiduNetdiskDownload文件夹，使用cd 文件名（注意这里有个空格）进入文件夹目录下，由于cmd窗口的代码不能复制黏贴，所以整个过程大致输入如下： C:\\Users\\Administrator&gt;e: E:\\&gt;BaiduNetdiskDownload&gt;cd &quot;Unix V6&quot; E:\\&gt;BaiduNetdiskDownload\\Unix V6&gt;cd simhv39-0-exe&gt; E:\\&gt;BaiduNetdiskDownload\\Unix V6\\simhv39-0-exe&gt; 最后，成功显示这样的路径***:\\&gt;***\\Unix V6\\simhv39-0-exe&gt;就表示已经进入simhv39-0-exe文件夹中了，然后使用dir命令查看这个文件夹中的所有文件,由于文件比较多，所以就截图了： Git Bash Here方式Git Bash Here方式就比较简单，这个要在电脑上事先安装Git软件，直接进入到simhv39-0-exe文件夹下，右键点击该文件夹选择Git Bash Here，然后使用ls -lt命令进行查看： Administrator@PC-20210109IEYU MINGW64 &#x2F;d&#x2F;simhv39-0-exe $ ls -lt total 13984 -rw-r--r-- 1 Administrator 197121 6291996 四月 19 14:54 dist.tap -rwxr-xr-x 1 Administrator 197121 201223 五月 4 2012 swtp6800mp-a2.exe* -rwxr-xr-x 1 Administrator 197121 198732 五月 4 2012 swtp6800mp-a.exe* -rwxr-xr-x 1 Administrator 197121 192894 五月 4 2012 h316.exe* -rwxr-xr-x 1 Administrator 197121 158566 五月 4 2012 lgp.exe* -rwxr-xr-x 1 Administrator 197121 214245 五月 4 2012 sds.exe* -rwxr-xr-x 1 Administrator 197121 244623 五月 4 2012 id32.exe* -rwxr-xr-x 1 Administrator 197121 234367 五月 4 2012 id16.exe* -rwxr-xr-x 1 Administrator 197121 233236 五月 4 2012 ibm1130.exe* -rwxr-xr-x 1 Administrator 197121 293948 五月 4 2012 i7094.exe* -rwxr-xr-x 1 Administrator 197121 161305 五月 4 2012 gri.exe* -rwxr-xr-x 1 Administrator 197121 661949 五月 4 2012 altairz80.exe* -rwxr-xr-x 1 Administrator 197121 161691 五月 4 2012 altair.exe* -rwxr-xr-x 1 Administrator 197121 182294 五月 4 2012 s3.exe* -rwxr-xr-x 1 Administrator 197121 193458 五月 4 2012 i1620.exe* -rwxr-xr-x 1 Administrator 197121 188159 五月 4 2012 i1401.exe* -rwxr-xr-x 1 Administrator 197121 437997 五月 4 2012 hp2100.exe* -rwxr-xr-x 1 Administrator 197121 263665 五月 4 2012 eclipse.exe* -rwxr-xr-x 1 Administrator 197121 199700 五月 4 2012 nova.exe* -rwxr-xr-x 1 Administrator 197121 563019 五月 4 2012 vax780.exe* -rwxr-xr-x 1 Administrator 197121 497421 五月 4 2012 vax.exe* -rwxr-xr-x 1 Administrator 197121 341096 五月 4 2012 pdp10.exe* -rwxr-xr-x 1 Administrator 197121 584150 五月 4 2012 pdp11.exe* -rwxr-xr-x 1 Administrator 197121 241230 五月 4 2012 pdp15.exe* -rwxr-xr-x 1 Administrator 197121 233454 五月 4 2012 pdp9.exe* -rwxr-xr-x 1 Administrator 197121 262525 五月 4 2012 pdp8.exe* -rwxr-xr-x 1 Administrator 197121 226422 五月 4 2012 pdp7.exe* -rwxr-xr-x 1 Administrator 197121 224715 五月 4 2012 pdp4.exe* -rwxr-xr-x 1 Administrator 197121 199295 五月 4 2012 pdp1.exe* -rw-r--r-- 1 Administrator 197121 131072 四月 1 2008 ka655x.bin -rwxr-xr-x 1 Administrator 197121 44544 五月 5 2005 vmb.exe* 配置 Unix V6 的系统启动参数运行pdp11.exe可执行程序打开simhv39-0-exe这个文件夹，找到可执行程序pdp11.exe，点击该程序，然后会弹出这个一个窗口，然后我们就可以配置 Unix V6 的系统启动参数。本来按照网上的教程应该是，复制下面这段代码，这里的复制是指一行一行地复制，而不是一整段复制，鼠标右键黏贴到弹出的窗口后的光标处，但是不知道是不是我是win7，教程博主用的是win10，所以我这里是黏贴不了的。 set cpu 11&#x2F;40 set tm0 locked attach tm0 dist.tap attach rk0 rk0 attach rk1 rk1 attach rk2 rk2 d cpu 100000 012700 d cpu 100002 172526 d cpu 100004 010040 d cpu 100006 012740 d cpu 100010 060003 d cpu 100012 000777 g 100000 加载boot于是，我就按照上面这段代码的顺序在弹出窗口的光标处依次输入，直到最后一行，我这里的窗口与显示的代码大致如下： PDP-11 simulator V3.9-0 sim&gt; set cpu 11&#x2F;40 Disabling XQ sim&gt; set tm0 locked sim&gt; attach tm0 dist.tap sim&gt; attach rk0 rk0 RK:creating new file sim&gt; attach rk1 rk1 RK:creating new file sim&gt;attach rk2 rk2 RK:creating new file sim&gt;d cpu 100000 012700 sim&gt;d cpu 100002 172526 sim&gt;d cpu 100004 010040 sim&gt;d cpu 100006 012740 sim&gt;d cpu 100010 060003 sim&gt;d cpu 100012 000777 sim&gt;g 100000 加载引导块 将根分区加载到 rk 文件上去 这是网摘对这个过程的解释，先找照着做，以后再回来进行补充说明。 再次查看所有文件到这里我们看到的是光标在那里闪，我们再用上面的两种方法去查看经过这次输入之后会生成那些文件，我这里用的是第二种方式，回到simhv39-0-exe目录下右键选择Git Bash Here Administrator@PC-20210109IEYU MINGW64 &#x2F;e&#x2F;BaiduNetdiskDownload&#x2F;Unix V6&#x2F;simhv39-0- $ ls -lt total 13984 -rw-r--r-- 1 Administrator 197121 0 四月 19 14:43 rk2 -rw-r--r-- 1 Administrator 197121 0 四月 19 14:42 rk1 -rw-r--r-- 1 Administrator 197121 0 四月 19 14:41 rk0 -rw-r--r-- 1 Administrator 197121 6291996 四月 19 11:20 dist.tap -rwxr-xr-x 1 Administrator 197121 201223 五月 4 2012 swtp6800mp-a2.exe* -rwxr-xr-x 1 Administrator 197121 198732 五月 4 2012 swtp6800mp-a.exe* -rwxr-xr-x 1 Administrator 197121 192894 五月 4 2012 h316.exe* -rwxr-xr-x 1 Administrator 197121 158566 五月 4 2012 lgp.exe* -rwxr-xr-x 1 Administrator 197121 214245 五月 4 2012 sds.exe* -rwxr-xr-x 1 Administrator 197121 244623 五月 4 2012 id32.exe* -rwxr-xr-x 1 Administrator 197121 234367 五月 4 2012 id16.exe* -rwxr-xr-x 1 Administrator 197121 233236 五月 4 2012 ibm1130.exe* -rwxr-xr-x 1 Administrator 197121 293948 五月 4 2012 i7094.exe* -rwxr-xr-x 1 Administrator 197121 161305 五月 4 2012 gri.exe* -rwxr-xr-x 1 Administrator 197121 661949 五月 4 2012 altairz80.exe* -rwxr-xr-x 1 Administrator 197121 161691 五月 4 2012 altair.exe* -rwxr-xr-x 1 Administrator 197121 182294 五月 4 2012 s3.exe* -rwxr-xr-x 1 Administrator 197121 193458 五月 4 2012 i1620.exe* -rwxr-xr-x 1 Administrator 197121 188159 五月 4 2012 i1401.exe* -rwxr-xr-x 1 Administrator 197121 437997 五月 4 2012 hp2100.exe* -rwxr-xr-x 1 Administrator 197121 263665 五月 4 2012 eclipse.exe* -rwxr-xr-x 1 Administrator 197121 199700 五月 4 2012 nova.exe* -rwxr-xr-x 1 Administrator 197121 563019 五月 4 2012 vax780.exe* -rwxr-xr-x 1 Administrator 197121 497421 五月 4 2012 vax.exe* -rwxr-xr-x 1 Administrator 197121 341096 五月 4 2012 pdp10.exe* -rwxr-xr-x 1 Administrator 197121 584150 五月 4 2012 pdp11.exe* -rwxr-xr-x 1 Administrator 197121 241230 五月 4 2012 pdp15.exe* -rwxr-xr-x 1 Administrator 197121 233454 五月 4 2012 pdp9.exe* -rwxr-xr-x 1 Administrator 197121 262525 五月 4 2012 pdp8.exe* -rwxr-xr-x 1 Administrator 197121 226422 五月 4 2012 pdp7.exe* -rwxr-xr-x 1 Administrator 197121 224715 五月 4 2012 pdp4.exe* -rwxr-xr-x 1 Administrator 197121 199295 五月 4 2012 pdp1.exe* -rw-r--r-- 1 Administrator 197121 131072 四月 1 2008 ka655x.bin -rwxr-xr-x 1 Administrator 197121 44544 五月 5 2005 vmb.exe* 对比差异对比上次的输出，我们会发现新生成三个文件分别是rk0、rk1、rk2： -rw-r--r-- 1 Administrator 197121 0 四月 19 14:43 rk2 -rw-r--r-- 1 Administrator 197121 0 四月 19 14:42 rk1 -rw-r--r-- 1 Administrator 197121 0 四月 19 14:41 rk0 其实，我们在PDP-11那个窗口输入时，所输出的这行代码RK:creating new file，也可以知道这三个文件是新生成的。 退出加载，配置磁盘我们接着这里的输出代码：加载boot，快捷键Ctrl + E退出加载过程，然后窗口会输出这样一段代码Simulation stopped,PC:100012&lt;BR 100012&gt;,表示模拟器已经停止了，我们接着输入g 0进行配置磁盘信息，然后窗口输出=，在光标处接着输入以下代码： sim&gt; g 0 &#x3D;tmrk disk offset 0 tape offset 100 count 1 &#x3D;tmrk disk offset 1 tape offset 101 count 3999 &#x3D; [## Hit CTRL-E here] Simulation stopped, PC: 137300 (BGE 137274) sim&gt; q 就这一段代码 &#x3D; [## Hit CTRL-E here] 有点坑，我还照着上面进行输入，结果不是，应该是在显示=后，我们快捷键Ctrl + E,退出配置过程，最后在光标处输入q，到目前为止，窗口显示的情况如下： 安装磁盘在上一步我们在光标处输入q，再按下Enter键就可以退出pdp11.exe这个可执行程序，我们再重新点击这个可执行文件，输入以下代码进行： set cpu 11&#x2F;40 set tto 7b set tm0 locked attach tm0 dist.tap attach rk0 rk0 attach rk1 rk1 attach rk2 rk2 dep system sr 173030 boot rk0 当我们输完上面的代码，新一行会显示一个@，我们输入以下代码，告诉模拟器我们要加载 Unix 核心模块： rkunix 到这里为止，PDP-11可执行程序窗口的运行情况如图所示： 修改大小写为什么要修改大小写呢？因为无论我们在#后面的光标处输入什么，它都输出大写，所以我们这里需要把它改为小写，输入以下代码修改为小写： # STTY -LCASE 重新构建内核在#后的光标处接着输入以下代码进行重构内核，记得每输完一行按Enter进行确认： chdir &#x2F;usr&#x2F;sys&#x2F;conf cc mkconf.c mv a.out mkconf 配置mkconf输入以下代码配置mkconf： # .&#x2F;mkconf rk tm tc 8dc lp done # 编译配置，将其余的库文件进行链接，最后复制到unix目录下： as m40.s mv a.out m40.o cc -c c.c as l.s ld -x a.out m40.o c.o ..&#x2F;lib1 ..&#x2F;lib2 mv a.out &#x2F;unix","path":"2021/04/20/Linux内核学习/","date":"04-20","excerpt":"Linux内核学习前言为什么要看从Unix看起呢？因为Linux之父是参考Unix写出Linux的，所以追根溯源我就找到这里，打算从Unix源码看起，加上自己学习操作系统的学得很烂，不知道是自己的学习问题？还是操作系统理论知识本身就很抽象？于是，我就找到了《Unix内核源码剖析》这本书，从看源码然后再回头翻操作系统理论的书，沿着Unix-&gt;Linux-&gt;Android这条路走下去，逐步地对操作系统有进一步地理解。 Unix源码阅读前期环境搭建资料下载在网上找到书上学习Unix内核的材料，网盘地址如下： 链接：https:&#x2F;&#x2F;pan.baidu.com&#x2F;s&#x2F;1upOLt8h0U93spDuSEz4C4g 提取码：34cb Simh 中配置安装 Unix V6下载解压Unix V6上面的网盘地址如果失效，请联系本人更新地址，然后下载Unix V6解压里面的三个压缩文件到本地，应该看到这样的三个文件夹： simhv39-0-exe Unix-v6-Ken-Wellsch.tap v6src 重命名Unix-v6-Ken-Wellsch.tap将Unix-v6-Ken-Wellsch.tap这个文件夹中的Unix-v6-Ken-Wellsch.tap这个文件首先重命名为dist.tap，再复制黏贴到simhv39-0-exe这个文件夹里。这里为什么要重命名呢？因为在后面加载boot这段代码中有这样一行代码sim&gt; attach tm0 dist.tap，这里的dist.tap在我们下载到的三个文件夹中都没有，所以由此可以推断它是重命名来的，但是它有什么作用呢？暂时留下一个疑问。","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.huangzihan.top/tags/Linux/"},{"name":"内核","slug":"内核","permalink":"http://www.huangzihan.top/tags/%E5%86%85%E6%A0%B8/"},{"name":"Unix V6","slug":"Unix-V6","permalink":"http://www.huangzihan.top/tags/Unix-V6/"}]}],"categories":[],"tags":[{"name":"类","slug":"类","permalink":"http://www.huangzihan.top/tags/%E7%B1%BB/"},{"name":"超类","slug":"超类","permalink":"http://www.huangzihan.top/tags/%E8%B6%85%E7%B1%BB/"},{"name":"子类","slug":"子类","permalink":"http://www.huangzihan.top/tags/%E5%AD%90%E7%B1%BB/"},{"name":"super","slug":"super","permalink":"http://www.huangzihan.top/tags/super/"},{"name":"extends","slug":"extends","permalink":"http://www.huangzihan.top/tags/extends/"},{"name":"this","slug":"this","permalink":"http://www.huangzihan.top/tags/this/"},{"name":"多态","slug":"多态","permalink":"http://www.huangzihan.top/tags/%E5%A4%9A%E6%80%81/"},{"name":"动态绑定","slug":"动态绑定","permalink":"http://www.huangzihan.top/tags/%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/"},{"name":"继承链","slug":"继承链","permalink":"http://www.huangzihan.top/tags/%E7%BB%A7%E6%89%BF%E9%93%BE/"},{"name":"替换原则","slug":"替换原则","permalink":"http://www.huangzihan.top/tags/%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/"},{"name":"重载解析","slug":"重载解析","permalink":"http://www.huangzihan.top/tags/%E9%87%8D%E8%BD%BD%E8%A7%A3%E6%9E%90/"},{"name":"方法表","slug":"方法表","permalink":"http://www.huangzihan.top/tags/%E6%96%B9%E6%B3%95%E8%A1%A8/"},{"name":"final","slug":"final","permalink":"http://www.huangzihan.top/tags/final/"},{"name":"访问控制修饰符","slug":"访问控制修饰符","permalink":"http://www.huangzihan.top/tags/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6/"},{"name":"abstract","slug":"abstract","permalink":"http://www.huangzihan.top/tags/abstract/"},{"name":"抽象类","slug":"抽象类","permalink":"http://www.huangzihan.top/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/"},{"name":"内联","slug":"内联","permalink":"http://www.huangzihan.top/tags/%E5%86%85%E8%81%94/"},{"name":"字符串","slug":"字符串","permalink":"http://www.huangzihan.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"Java","slug":"Java","permalink":"http://www.huangzihan.top/tags/Java/"},{"name":"String","slug":"String","permalink":"http://www.huangzihan.top/tags/String/"},{"name":"substring方法","slug":"substring方法","permalink":"http://www.huangzihan.top/tags/substring%E6%96%B9%E6%B3%95/"},{"name":"equals方法","slug":"equals方法","permalink":"http://www.huangzihan.top/tags/equals%E6%96%B9%E6%B3%95/"},{"name":"运算符","slug":"运算符","permalink":"http://www.huangzihan.top/tags/%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"name":"floorMod方法","slug":"floorMod方法","permalink":"http://www.huangzihan.top/tags/floorMod%E6%96%B9%E6%B3%95/"},{"name":"sqrt方法","slug":"sqrt方法","permalink":"http://www.huangzihan.top/tags/sqrt%E6%96%B9%E6%B3%95/"},{"name":"静态方法","slug":"静态方法","permalink":"http://www.huangzihan.top/tags/%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/"},{"name":"Math类","slug":"Math类","permalink":"http://www.huangzihan.top/tags/Math%E7%B1%BB/"},{"name":"强制类型转换","slug":"强制类型转换","permalink":"http://www.huangzihan.top/tags/%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"},{"name":"三元操作符","slug":"三元操作符","permalink":"http://www.huangzihan.top/tags/%E4%B8%89%E5%85%83%E6%93%8D%E4%BD%9C%E7%AC%A6/"},{"name":"掩码技术","slug":"掩码技术","permalink":"http://www.huangzihan.top/tags/%E6%8E%A9%E7%A0%81%E6%8A%80%E6%9C%AF/"},{"name":"汇编语言","slug":"汇编语言","permalink":"http://www.huangzihan.top/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"name":"8086系统","slug":"8086系统","permalink":"http://www.huangzihan.top/tags/8086%E7%B3%BB%E7%BB%9F/"},{"name":"寄存器","slug":"寄存器","permalink":"http://www.huangzihan.top/tags/%E5%AF%84%E5%AD%98%E5%99%A8/"},{"name":"Android","slug":"Android","permalink":"http://www.huangzihan.top/tags/Android/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"http://www.huangzihan.top/tags/Android-Studio/"},{"name":"四大组件","slug":"四大组件","permalink":"http://www.huangzihan.top/tags/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"},{"name":"Activity","slug":"Activity","permalink":"http://www.huangzihan.top/tags/Activity/"},{"name":"Service","slug":"Service","permalink":"http://www.huangzihan.top/tags/Service/"},{"name":"Broadcastreceiver","slug":"Broadcastreceiver","permalink":"http://www.huangzihan.top/tags/Broadcastreceiver/"},{"name":"Contentprovider","slug":"Contentprovider","permalink":"http://www.huangzihan.top/tags/Contentprovider/"},{"name":"Sqlite","slug":"Sqlite","permalink":"http://www.huangzihan.top/tags/Sqlite/"},{"name":"Linux内核层","slug":"Linux内核层","permalink":"http://www.huangzihan.top/tags/Linux%E5%86%85%E6%A0%B8%E5%B1%82/"},{"name":"系统运行库层","slug":"系统运行库层","permalink":"http://www.huangzihan.top/tags/%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E5%BA%93%E5%B1%82/"},{"name":"应用框架层","slug":"应用框架层","permalink":"http://www.huangzihan.top/tags/%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6%E5%B1%82/"},{"name":"应用层","slug":"应用层","permalink":"http://www.huangzihan.top/tags/%E5%BA%94%E7%94%A8%E5%B1%82/"},{"name":"Linux","slug":"Linux","permalink":"http://www.huangzihan.top/tags/Linux/"},{"name":"内核","slug":"内核","permalink":"http://www.huangzihan.top/tags/%E5%86%85%E6%A0%B8/"},{"name":"Unix V6","slug":"Unix-V6","permalink":"http://www.huangzihan.top/tags/Unix-V6/"}]}